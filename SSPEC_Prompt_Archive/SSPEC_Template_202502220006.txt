‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SSPEC PossPath Essential Files ‚ïë
‚ïë Date: 2025-02-22               ‚ïë
‚ïë Version: 0006                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
üåêStructured Speculation Possibility Pathfinder or "SSPEC PossPath" for short. Your task to develop the Flask Web App as an innovative tool for mass collaboration across divides. Essential app files:
üü• routes.py:
# routes.py (Refactored and Async - CORRECTED)
from flask import Flask, Blueprint, render_template, request, flash, redirect, url_for, jsonify, make_response, current_app, send_from_directory
import os
import json
import uuid
import pdfkit
import logging
from bs4 import BeautifulSoup
from app import app, USE_DATABASE
from uuid import UUID
from models import SSOL, COS, CE
from store import ce_store, cos_store, ssol_store
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from werkzeug.exceptions import BadRequest, NotFound
from utilities import generate_goal, get_domain_icon_and_name, generate_outcome_data, analyze_user_input, generate_sentiment_analysis #Imported analyze_user_input and generate_sentiment_analysis
from speculate import get_badge_class_from_status, delete_cos_by_id, update_cos_by_id, analyze_cos
from datetime import datetime
from dotenv import load_dotenv
from speculate import create_cos, delete_cos_by_id, update_cos_by_id, get_badge_class_from_status, get_ce_by_id, extract_conditional_elements
from ce_nodes import NODES #Import NODES for outcome route

# Load environment variables
load_dotenv()

# Set the secret key and database URI from the environment variables
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('SQLALCHEMY_DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Configure logging
logging.basicConfig(level=logging.WARNING)

# Register Jinja filter
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

routes_bp = Blueprint('routes_bp', __name__)

@routes_bp.route('/favicon.ico')
def favicon():
    return send_from_directory(os.path.join(current_app.root_path, 'static'), 'favicon.ico', mimetype='image/vnd.microsoft.icon')

@routes_bp.route('/')
def index():
    return render_template('input.html')

@routes_bp.route('/about')
def about():
    return render_template('about.html')

@routes_bp.route('/goal_selection', methods=['POST']) #Expect POST only
async def goal_selection(): # REFACTORED - async
    if request.method == 'POST':
        user_input = request.form['user_text'].strip()
        if not user_input:
            flash("Please enter your possibility or goal.", "error")
            return render_template('input.html') # Render input page with error

        try:
            logging.info(f"User Input: '{user_input}'. Calling generate_goal...")
            goal_options = await generate_goal(user_input) # REFACTORED - await
            logging.debug(f"generate_goal returned: {goal_options}")

            if not goal_options:
                flash("Could not generate goal options. Please try again with a different input.", "warning")
                return render_template('input.html')

            for goal in goal_options:
                logging.info(f"Calling get_domain_icon_and_name for goal: {goal['title']}")
                goal['icon'], goal['domain'] = await get_domain_icon_and_name(goal['title']) # REFACTORED - await
                logging.debug(f"get_domain_icon_and_name returned: icon={goal['icon']}, domain={goal['domain']}")

            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify(goals=goal_options, user_input=user_input)

            return render_template('goal_selection.html', goals=goal_options, user_input=user_input)

        except ValueError as e:
            flash(str(e), "error")
            logging.error(f"ValueError in goal_selection: {e}", exc_info=True) # Log traceback
            # Render input.html and pass error message
            return render_template('input.html', user_text=user_input, error_message=str(e)) # Pass error to template

        except Exception as e:
            flash("An unexpected error occurred. Please try again.", "error")
            logging.error(f"Unexpected error in goal_selection: {e}", exc_info=True) # Log traceback
            # Render input.html and pass error message
            return render_template('input.html', user_text=user_input, error_message=str(e)) # Pass error to template

    return redirect(url_for('routes_bp.index')) # Redirect for non-POST requests - unchanged


@routes_bp.route('/outcome', methods=['POST']) #Expect POST only
async def outcome(): # REFACTORED - async
    if request.method == 'POST':
        logging.info(f"Outcome route - Form data received: {request.form}")
        selected_goal = request.form.get('selected_goal', '').strip()
        domain = request.form.get('domain', '').strip()
        domain_icon = request.form.get('domain_icon', '').strip()

        if not selected_goal:
            flash("No goal selected. Please return to goal selection and choose a goal.", "error")
            return redirect(url_for('routes_bp.index')) # Or redirect to goal_selection if more appropriate

        try:
            logging.info("Calling generate_outcome_data...")
            outcome_data = await generate_outcome_data(request, 'POST', selected_goal, domain, domain_icon) # REFACTORED - await
            logging.debug(f"generate_outcome_data returned keys: {outcome_data.keys() if outcome_data else None}")
            return render_template('outcome.html', ssol=outcome_data, nodes=NODES) # Pass NODES here

        except Exception as e:
            app.logger.error(f"Error generating outcome data: {e}", exc_info=True)
            flash("Error generating outcome data. Please try again.", "error")
            return redirect(url_for('routes_bp.goal_selection')) # Or back to input.html


    flash("Invalid request method for outcome.", "error")
    return redirect(url_for('routes_bp.index')) # Or redirect to goal_selection if more appropriate

@routes_bp.route('/analyze_input', methods=['POST']) # New route for analyzing user input
async def analyze_input_route(): # REFACTORED - async
    if request.method == 'POST':
        user_text = request.form.get('user_text')
        if not user_text:
            return jsonify({'error': 'No text provided'}), 400

        try:
            keywords = await analyze_user_input(user_text) # REFACTORED - await
            sentiment = await generate_sentiment_analysis(user_text) # REFACTORED - await
            return jsonify({'keywords': keywords, 'sentiment': sentiment})
        except Exception as e:
            logging.error(f"Error analyzing user input: {e}", exc_info=True)
            return jsonify({'error': 'Error analyzing input'}), 500
    return jsonify({'error': 'Invalid request method'}), 405


@routes_bp.route('/save_as_pdf/<uuid:ssol_id>', methods=['POST'])
def save_as_pdf(ssol_id):
    try:
        data = request.get_json()
        html_content = data['htmlContent']
        if not html_content:
            raise ValueError("No HTML content provided.")

        css_file_path = os.path.join(current_app.root_path, current_app.static_folder, 'styles.css')
        html_content = html_content.replace('src="/static/', f'src="{url_for("static", filename="", _external=True)}')

        options = {
            "page-size": "Letter", "margin-top": "0.75in", "margin-right": "0.75in",
            "margin-bottom": "0.75in", "margin-left": "0.75in", "encoding": "UTF-8",
            "custom-header": [("Accept-Encoding", "gzip")], "no-outline": None, "enable-local-file-access": None,
        }

        pdf = pdfkit.from_string(html_content, False, options=options, css=css_file_path)

        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename="Structured Solution {ssol_id}.pdf"'
        return response

    except Exception as e:
        current_app.logger.error(f"Exception in save_as_pdf: {e}")
        return jsonify(success=False, error=str(e)), 500

@routes_bp.route('/update_cos/<uuid:cos_id>', methods=['PUT'])
def update_cos_route(cos_id):
    try:
        data = request.get_json()
        if not data: raise BadRequest('No JSON payload received')

        cos_id_str = str(cos_id)
        update_result = update_cos_by_id(cos_id_str, data)

        if update_result['success']: return jsonify(success=True, cos=update_result['cos']), 200
        else: return jsonify(success=False, error=update_result['message']), 404

    except BadRequest as e: return jsonify(error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Error updating COS with ID {cos_id}: {e}", exc_info=True)
        return jsonify(error="An unexpected error occurred while updating the COS."), 500

@routes_bp.route('/delete_cos/<uuid:cos_id>', methods=['DELETE'])
def delete_cos_route(cos_id):
    try:
        cos_id_str = str(cos_id)
        if delete_cos_by_id(cos_id_str):
            flash('COS has been successfully deleted.', 'success')
            return jsonify(success=True), 200
        else: raise NotFound('Condition of Satisfaction could not be found or deleted.')

    except NotFound as e:
        logging.warning(f"NotFound: {e}")
        return jsonify(success=False, error=str(e)), 404
    except Exception as e:
        logging.error(f"Unexpected error occurred: {e}", exc_info=True)
        return jsonify(success=False, error=str(e)), 500

@routes_bp.route('/get_ce_by_id', methods=['GET'])
def get_ce_by_id_route():
    ce_id = request.args.get('ce_id')
    try:
        ce = get_ce_by_id(ce_id)
        if ce:
            ce_data = ce.to_dict()
            return jsonify(ce=ce_data)
        else: return jsonify(error="CE not found"), 404
    except Exception as e:
        logging.error(f"Error retrieving CE by ID: {e}", exc_info=True)
        return jsonify(error="Error fetching CE"), 500

@app.route('/analyze_cos/<string:cos_id>', methods=['GET'])
def analyze_cos_route(cos_id):
    logging.info(f"Analyzing COS with ID: {cos_id}")
    try:
        analysis_result = analyze_cos_by_id(cos_id)
        if analysis_result['success']: return jsonify(analysis_result['analysis_results']), 200
        else: return jsonify({'error': analysis_result['message']}), 404
    except ValueError: return jsonify({'error': "Invalid COS ID"}), 400
    except Exception as e:
        logging.error(f"Error analyzing COS ID {cos_id}: {e}", exc_info=True)
        return jsonify({'error': "Error analyzing COS"}), 500

def analyze_cos_by_id(cos_id_str):
    try:
        cos = COS.query.get(cos_id_str) if USE_DATABASE else cos_store.get(cos_id_str)
        if not cos: return {'success': False, 'message': "COS not found."}
        analysis_results = analyze_cos(cos.content if USE_DATABASE else cos['content'])
        return {'success': True, 'analysis_results': analysis_results}
    except Exception as e:
        logging.error(f"Error in analyze_cos_by_id: {e}", exc_info=True)
        return {'success': False, 'message': f"An unexpected error occurred during COS analysis: {str(e)}"}

app.register_blueprint(routes_bp)


üüß ai_service.py:
# ai_service.py (Option 10 - Corrected typo and added generation_config)
import os
import json
import logging
import asyncio
import google.generativeai as genai
from google.generativeai import types # Keep types import for generation_config
from dotenv import load_dotenv
from utilities import Logger # Keep Logger import if used
from flask import current_app
from ce_nodes import get_valid_node_types
from openai import AzureOpenAI # Keep AzureOpenAI import

# Load environment variables
load_dotenv()
google_gemini_api_key = os.environ["GOOGLE_GEMINI_API"]
gemini_model_name = os.getenv("GEMINI_MODEL_NAME")
azure_openai_key = os.environ["AZURE_OPENAI_API_KEY"]
azure_openai_endpoint = os.environ["AZURE_OPENAI_ENDPOINT"]
azure_openai_deployment_name = os.environ["AZURE_DEPLOYMENT_NAME"]
azure_openai_api_version = os.environ["AZURE_DALLE_API_VERSION"]

# Configure generative AI client - Gemini
genai.configure(api_key=google_gemini_api_key)

# Generation config from user's snippet - Option 10: Added generation_config
generation_config = {
  "temperature": 0.75, # Adjusted temperature to 0.75 (from previous 1) - closer to our default
  "top_p": 0.95,
  "top_k": 40, # Adjusted top_k to 40 (from previous 64) - more common value
  "max_output_tokens": 2048, # Adjusted max_output_tokens to 2048 (from previous 8192 - might be too large)
  # "response_mime_type": "text/plain", # Removed response_mime_type for now - might not be needed
}


# Initialize Gemini model with systemInstruction AND generation_config - Option 10
model = genai.GenerativeModel(
    model_name=gemini_model_name,
    generation_config=generation_config, # Pass generation_config here
    system_instruction="You are a helpful assistant, skilled in structured problem-solving and collaborative speculation. Please provide concise, accurate, and helpful responses in JSON format when requested."
)

# Initialize Azure OpenAI client - Keep this as is
azure_openai_client = AzureOpenAI(
    api_version=os.environ["AZURE_OPENAI_API_VERSION"],
    api_key=azure_openai_key,
    azure_endpoint=azure_openai_endpoint
)

async def send_request_to_gemini(messages, generation_config=None, logger=None):
    """
    Asynchronously sends a request to the Google Gemini API and returns the response.
    ... (rest of the function documentation is the same) ...
    """
    if logger is None:
        logger = logging.getLogger()
    try:
        logger.debug(f"Sending request to Gemini with messages: {messages}")

        model = genai.GenerativeModel(gemini_model_name)

        # Format messages for Gemini API - Using types.Content and types.TextPart - CORRECTED to use types. again
        gemini_contents = []
        system_instruction_content = ""

        for message in messages:
            role = message.get("role")
            content = message.get("content")

            if role == "system":
                system_instruction_content = content

            elif role and role != "system":
                gemini_contents.append(types.Content(role=role, parts=[types.TextPart(text=content)])) # Corrected: using types.Content and types.TextPart again
            elif content and role != "system":
                gemini_contents.append(types.Content(parts=[types.TextPart(text=content)])) # Corrected: using types.Content and types.TextPart again


        final_contents = gemini_contents

        if not final_contents and not system_instruction_content:
            raise ValueError("No valid content in messages to send to Gemini API.")

        response = model.generate_content(
            contents=final_contents,
            generation_config=generation_config
        )

        if response.text is None:
            raise ValueError(f"Gemini API returned an empty response. Raw response: {response}")

        logger.debug(f"Gemini API response: {response.text}")
        return response.text

    except Exception as e:
        logger.error(f"Error sending request to Gemini API: {e}", exc_info=True)
        raise


async def generate_chat_response(messages, role, task, model=None, temperature=0.75, retries=3, backoff_factor=2, logger=None, generation_config=None):
    """
    Asynchronously sends a request to the Gemini API and returns the response. Includes retries.
    """
    if logger is None:
        logger = logging.getLogger()
    last_exception = None
    for retry_attempt in range(retries):
        try:
            logger.debug(f"Sending request to Gemini API with messages: {messages}, attempt {retry_attempt + 1}")
            response_content = await send_request_to_gemini(messages, generation_config, logger)
            return response_content

        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                logger.warning(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.")
                await asyncio.sleep(sleep_time)
            else:
                logger.error(f"Error in generate_chat_response: {e}. All retries exhausted.")

    if last_exception:
        raise last_exception


async def generate_chat_response_with_node_types(messages, role, task, temperature=0.75, retries=3, backoff_factor=2, logger=None):
    """
    Asynchronously sends a request to the Gemini API, including node type context.
    """
    if logger is None:
        logger = logging.getLogger()
    last_exception = None
    for retry_attempt in range(retries):
        try:
            node_types = get_valid_node_types()
            node_types_str = ', '.join(node_types)

            system_message = {
                # Removed system role from message - Option 9: Relying on systemInstruction only
                "content": "You are a helpful assistant. Please respond with information in JSON format. Valid Node Types: " + node_types_str + " **The response should be valid JSON.**" # System message content remains, but role is ignored by send_request_to_gemini now
            }
            messages_with_json = [system_message] + messages
            response_content =  await generate_chat_response(messages_with_json, role, task, temperature, retries, backoff_factor, logger)
            Logger.log_message(f"SSPEC Response ({role} - {task}): {response_content}", 'debug')
            return response_content
        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                Logger.log_message(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.", 'error')
                await asyncio.sleep(sleep_time)
            else:
                Logger.log_message(f"Error in generate_chat_response: {e}. All retries exhausted.", 'error')

    if last_exception:
        raise last_exception


üü® utilities.py:
# utilities.py (Refactored and Async - Corrected generate_goal call + Circular Import Fix)
import io
import os
import re
import html
import json
import time
import uuid
import logging
import warnings
from uuid import uuid4
from PIL import Image
from bs4 import BeautifulSoup
from dotenv import load_dotenv
from app import USE_DATABASE, db
from ce_nodes import get_valid_node_types
from models import COS, CE, SSOL, COS_CE_Link
from store import ssol_store, cos_store, ce_store
from flask import current_app, flash, render_template
import asyncio
import aiohttp
import requests
from google.generativeai import types

# Load environment variables - Unchanged
load_dotenv()
azure_oai_key = os.getenv("AZURE_OPENAI_API_KEY")
azure_oai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
azure_oai_deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")
azure_oai_model = os.getenv("AZURE_MODEL_NAME")
azure_dalle_api_version = os.getenv("AZURE_DALLE_API_VERSION")

class Logger: #Logger Class - Unchanged
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    @staticmethod
    def log_message(message, level='info'):
        if level == 'info':
            formatted_message = f"{Logger.OKCYAN}{message}{Logger.ENDC}"
        elif level == 'warning':
            formatted_message = f"{Logger.WARNING}{message}{Logger.ENDC}"
        elif level == 'error':
            formatted_message = f"{Logger.FAIL}{message}{Logger.ENDC}"
        elif level == 'debug':
            formatted_message = f"{Logger.OKBLUE}{message}{Logger.ENDC}"
        else:
            formatted_message = message

        print(formatted_message)

def parse_ai_response_and_generate_html(response_json): #Unchanged
    structured_solution = {}
    expected_phases = ["Discovery", "Engagement", "Action", "Completion", "Legacy"]

    for phase in expected_phases:
        structured_solution[phase] = []
        for cos in response_json.get(phase, []):
            cos_id = str(uuid.uuid4())
            cos_html = cos['content']
            ces = []

            soup = BeautifulSoup(cos_html, 'html.parser')
            for ce_tag in soup.find_all('ce'):
                ce_uuid = str(uuid.uuid4())
                new_tag = soup.new_tag('span', attrs={
                    'class': 'badge rounded-pill bg-secondary ce-pill',
                    'data-ce-id': ce_uuid,
                    'data-ce-type': ce_tag['type']
                })
                new_tag.string = ce_tag.string
                ce_tag.replace_with(new_tag)

                ce_data = {
                    'id': ce_uuid,
                    'content': ce_tag.string,
                    'status': 'Proposed',
                    'type': ce_tag['type']
                }
                ces.append(ce_data)

                # Store the CEs
                if USE_DATABASE:
                    ce_instance = CE(id=ce_uuid, content=ce_tag.string, node_type=ce_tag['type'])
                    db.session.add(ce_instance)
                else:
                    ce_store[ce_uuid] = ce_data

            if USE_DATABASE:
                db.session.commit()

            structured_solution[phase].append({
                'id': cos_id,
                'content': str(soup),
                'status': 'Proposed',
                'ces': ces
            })

    return structured_solution

async def generate_outcome_data(request, method, selected_goal=None, domain=None, domain_icon=None): # REFACTORED - async
    from ai_service import generate_chat_response, azure_openai_client # Local import - now includes azure_openai_client

    outcome_data = {
        'user_input': '', 'selected_goal': selected_goal, 'domain_icon': domain_icon, 'domain': domain,
        'ssol_id': None, 'ssol_summary': "An error occurred while processing the summary data.",
        'phases': {}, 'generated_image_path': 'images/sspec_default.png'
    }

    user_input = request.form.get('user_text', '').strip() if method == 'POST' else request.args.get('user_text', '').strip()
    outcome_data['user_input'] = user_input
    outcome_data['ssol_id'] = generate_ssol_id(USE_DATABASE, ssol_store, selected_goal)

    summary_messages = [
        {"role": "system", "content": "Assume it is possible to fulfill any outcome, generate a high-level summary ..."},
        {"role": "user", "content": f"Generate a high-level, elegantly-formatted summary for the goal: '{selected_goal}'. ..."}
    ]

    try:
        current_app.logger.info("Generating summary from AI...")
        summary_response = await generate_chat_response(summary_messages, role='Outcome Summary', task='Generate Summary') # REFACTORED - await - added role and task
        current_app.logger.debug(f"Summary AI Response: {summary_response}")
        summary_data = json.loads(summary_response)
        outcome_data['ssol_summary'] = summary_data.get('summary', "Summary not available.")
    except json.JSONDecodeError as e:
        current_app.logger.error(f"JSON decoding error when generating summary: {e}", exc_info=True)
        outcome_data['ssol_summary'] = "Summary generation failed due to JSON error."
    except Exception as e:
        current_app.logger.error(f"Error in generate_outcome_data (summary): {e}", exc_info=True)
        outcome_data['ssol_summary'] = "Summary generation failed."

    structured_solution_messages = [
        {"role": "system", "content": "You are a helpful assistant. Generate detailed Conditions of Satisfaction (COS) ..."},
        {"role": "user", "content": f"Generate a concise Structured Solution for the project '{selected_goal}'. ..."}
    ]
    try:
        current_app.logger.info("Generating structured solution from AI...")
        structured_solution_response = await generate_chat_response(structured_solution_messages, role='Structured Solution', task='Generate Solution') # REFACTORED - await - added role and task
        current_app.logger.debug(f"Structured Solution AI Response: {structured_solution_response}")
        structured_solution_json = json.loads(structured_solution_response)
        if isinstance(structured_solution_json, dict):
            outcome_data['phases'] = parse_ai_response_and_generate_html(structured_solution_json)
        else:
            logging.error("Expected a dictionary for the structured solution JSON response.")
            outcome_data['phases'] = {}
    except json.JSONDecodeError as e:
        logging.error(f"JSON decoding error when generating structured solution: {e}")
        outcome_data['phases'] = {}
    except Exception as e:
        logging.error(f"Error in generate_outcome_data (structured solution): {e}", exc_info=True)
        outcome_data['phases'] = {}

    try:
        image_prompt = f"A colorful, visually stunning photograph of a retro-futuristic tableau depicting '{selected_goal}' as a fulfilled goal, diverse,It's a Small World, 1962, photo-realistic, isometric, tiltshift "
        web_image_path = await generate_dalle_image(image_prompt, azure_openai_client) # REFACTORED - await - pass azure_openai_client locally now
        outcome_data['generated_image_path'] = web_image_path
    except Exception as e:
        current_app.logger.error(f"Error generating image: {e}", exc_info=True)
        outcome_data['generated_image_path'] = 'images/sspec_default.png'

    return outcome_data

async def analyze_user_input(text): #Unchanged - local import already
    from ai_service import generate_chat_response # Local import
    messages = [
        {"role": "system", "content": "You are an AI that analyzes user inputs and extracts keywords. **Respond with JSON.**"},
        {"role": "user", "content": text},
    ]
    response_text = await generate_chat_response(messages, role='Keyword Extraction', task='Extract Keywords', temperature=0.75) # Local import - added role and task
    keywords = response_text.split(', ')
    print(f"Keywords: {keywords}")
    return keywords

async def generate_sentiment_analysis(text, temperature=0.7): #Unchanged - local import already
    from ai_service import generate_chat_response # Local import
    messages = [
        {"role": "system", "content": "You are an AI trained to analyze sentiment and return POSITIVE, NEGATIVE, or NEUTRAL **in JSON format**"},
        {"role": "user", "content": f"What sentiment is expressed in the following text: '{text}'?"},
    ]
    response_text = await generate_chat_response(messages, role='Sentiment Analysis', task='Analyze Sentiment', model="gemini-2.0-flash", temperature=temperature) # Local import - added role and task
    sentiment = "NEUTRAL"
    if "positive" in response_text.lower(): sentiment = "POSITIVE"
    elif "negative" in response_text.lower(): sentiment = "NEGATIVE"
    elif "neutral" in response_text.lower(): sentiment = "NEUTRAL"
    return sentiment

async def generate_goal(user_input): #Unchanged - local import already
    from ai_service import send_request_to_gemini, generate_chat_response # Local import

    goal_options = []
    temperatures = [0.6, 0.8, 1.0]

    async def generate_single_goal(temp):
        messages = [
            {"role": "system", "content": "You are an AI that generates innovative and unique goal outcomes ..."},
            {"role": "user", "content": user_input},
        ]
        response = await generate_chat_response(messages, role='Goal Generation', task='Generate Goal Option') # Local import - corrected call - added role and task
        goal_option = response.strip()
        goal_compliant, non_compliance_reason = await is_goal_compliant(goal_option)
        if goal_compliant: return {'title': goal_option, 'compliant': True, 'reason': non_compliance_reason}
        else: return {'title': goal_option, 'compliant': False, 'reason': non_compliance_reason}

    async def main():
        tasks = [generate_single_goal(temp) for temp in temperatures]
        results = await asyncio.gather(*tasks)
        unique_goals = []
        seen_titles = set()
        for result in results:
            if result and result['title'] not in seen_titles:
                unique_goals.append(result)
                seen_titles.add(result['title'])
                if len(unique_goals) >= 3: break
        if len(unique_goals) < 3: raise ValueError("Failed to generate 3 unique goals. Please try again.")
        return unique_goals

    return await main()

async def is_goal_compliant(selected_goal): #Unchanged - local import already
    from ai_service import generate_chat_response # Local import
    messages = [
        {"role": "system", "content": "You are a goal compliance checker. You are given a goal and must determine if it meets the following criteria:\n1. ..."},
        {"role": "user", "content": f"Goal: '{selected_goal}'"}
    ]
    response_text = await generate_chat_response(messages, role='Goal Compliance Check', task='Check Compliance') # Local import - added role and task
    try:
        response_data = json.loads(response_text)
        compliance = response_data.get('compliance', 'COMPLIANT').upper()
        reason = response_data.get('reason', '')
        if compliance == 'COMPLIANT': return True, reason
        else: return False, reason
    except json.JSONDecodeError: return True, "Compliance check failed."

async def get_domain_icon_and_name(goal_domain): # REFACTORED - local import
    from ai_service import generate_chat_response # Local import

    messages = [
        {"role": "system", "content": "You are an AI that suggests a domain and FontAwesome 6 Solid (fas) class icon based on the goal domain. ..."},
        {"role": "user", "content": f"What is the best domain and corresponding FontAwesome icon class for the goal related to '{goal_domain}'?"}
    ]
    response_content = await generate_chat_response(messages, role='Domain and Icon', task='Fetch Domain and Icon', temperature=0.37) # REFACTORED - await - added role and task

    try:
        response_data = json.loads(response_content)
        domain = response_data.get("domain")
        icon_class = response_data.get("iconClass")

        if not domain or not icon_class:
            Logger.log_message("Missing 'domain' or 'iconClass' in AI response.", 'warning')
            raise ValueError("Failed to generate domain and icon. Please try again.")

        return icon_class, domain

    except json.JSONDecodeError as e:
        Logger.log_message(f"JSON parsing error: {e}", 'error')
        raise ValueError("Failed to parse JSON response. Please try again.")

    except Exception as e:
        Logger.log_message(f"Unexpected error: {e}", 'error')
        raise

def get_cos_by_guid(ssol, cos_guid): #Unchanged
    for phase in ssol['phases'].values():
        for cos in phase:
            if cos['id'] == cos_guid: return cos
    return None

def update_cos_content_by_guid(ssol, cos_guid, new_content): #Unchanged
    cos = get_cos_by_guid(ssol, cos_guid)
    if cos: cos['content'] = new_content; return True
    return False

def sanitize_filename(filename): #Unchanged
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', filename)
    filename = re.sub(r'[\s]+', '_', filename)
    return filename[:255]

async def generate_dalle_image(prompt, azure_openai_client): #Unchanged - local import already
    from ai_service import azure_openai_client as client_module # Local import - alias

    try:
        client = azure_openai_client if azure_openai_client else client_module # Use passed client or local import if None
        result = await client.images.generate(
            model="dall-e-3", prompt=prompt, n=1, size="1024x1024",
        )
        image_url = result.data[0].url
        unique_filename = f"generated_image_{uuid.uuid4().hex}.png"
        static_folder = current_app.static_folder
        image_folder = os.path.join(static_folder, 'images')
        os.makedirs(image_folder, exist_ok=True)
        image_file_path = os.path.join(image_folder, unique_filename)
        image_response = requests.get(image_url)
        image_response.raise_for_status()
        with open(image_file_path, 'wb') as image_file: image_file.write(image_response.content)
        web_path = os.path.join('images', unique_filename).replace("\\", "/")
        return web_path
    except Exception as e:
        current_app.logger.error(f"Error in generate_dalle_image: {e}", exc_info=True)
        raise

def generate_structured_solution(selected_goal): #Unchanged - local import already
    from ai_service import generate_chat_response # Local import
    structured_solution = {}
    system_message = {
        "role": "system",
        "content": "You are an AI that generates a structured solution for a project. ...",
    }
    user_message = {
        "role": "user",
        "content": f"Generate a Structured Solution for the project '{selected_goal}'. ...",
    }
    messages = [system_message, user_message]
    try:
        response_text = generate_chat_response(
            messages, role='Structured Solution Generation', task='Generate Solution', # Local import - added role and task
            temperature=0.75, retries=3, backoff_factor=2
        )
        if response_text and response_text.strip().endswith('}'):
            response_json = json.loads(response_text)
        else: raise ValueError("Incomplete JSON response received from AI.")

        structured_solution['phases'] = {
            phase: [
                {'id': cos.get('id', str(uuid.uuid4())), 'status': 'Proposed', 'cos_text': cos['cos_text'], 'ces': cos.get('CEs', [])}
                for cos in response_json.get(phase, [])
            ]
            for phase in ['Discovery', 'Engagement', 'Action', 'Completion', 'Legacy']
        }
        return structured_solution

    except json.JSONDecodeError as e:
        current_app.logger.error(f"Error parsing JSON response: {e}", exc_info=True)
        raise ValueError("Failed to parse JSON response.")
    except ValueError as e:
        current_app.logger.error(f"Error in generating structured solution: {e}", exc_info=True)
        raise
    except Exception as e:
        current_app.logger.error(f"Unexpected error in generating structured solution: {e}", exc_info=True)
        raise ValueError("Failed to generate structured solution.")

async def generate_chat_response_with_node_types(messages, role, task, temperature=0.75, retries=3, backoff_factor=2): #Unchanged - local import already
    from ai_service import generate_chat_response # Local import
    last_exception = None
    for retry_attempt in range(retries):
        try:
            node_types = get_valid_node_types()
            node_types_str = ', '.join(node_types)
            system_message = {
                "role": "system",
                "content": "You are a helpful assistant. Please respond with information in JSON format. Valid Node Types: " + node_types_str + " **The response should be valid JSON.**"
            }
            messages_with_json = [system_message] + messages
            response_content =  await generate_chat_response(messages_with_json, role, task, temperature, retries, backoff_factor, current_app.logger) # Local import - added role and task
            Logger.log_message(f"SSPEC Response ({role} - {task}): {response_content}", 'debug')
            return response_content
        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                Logger.log_message(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.", 'error')
                await asyncio.sleep(sleep_time)
            else:
                Logger.log_message(f"Error in generate_chat_response: {e}. All retries exhausted.", 'error')
        raise last_exception

def generate_ssol_id(USE_DATABASE, ssol_store, selected_goal): #Helper function - Unchanged
    from models import SSOL # Local import to avoid circular dependency

    if USE_DATABASE:
        ssol_instance = SSOL.query.filter_by(title=selected_goal).first()
        if not ssol_instance:
            ssol_instance = SSOL(title=selected_goal, description='')
            db.session.add(ssol_instance)
            db.session.commit()
        return ssol_instance.id
    else:
        ssol_instance = next((ssol for ssol in ssol_store.values() if ssol['title'] == selected_goal), None)
        if not ssol_instance:
            ssol_id = str(uuid4())
            ssol_instance = {'id': ssol_id, 'title': selected_goal, 'description': ''}
            ssol_store[ssol_id] = ssol_instance
        return ssol_instance['id']


üü© goal_selection.html:
<!-- goal_selection.html -->
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
  <h1>What is your Commitment?</h1>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Your Input</th>
        <th class="text-end">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="user-input">{{ user_input }}</td>
        <td class="text-end">
          <button type="button" class="btn btn-primary btn-sm edit-user-input">Edit</button>
          <button type="button" class="btn btn-success btn-sm save-user-input d-none">Update</button>
          <button type="button" class="btn btn-danger btn-sm cancel-user-input d-none">Cancel</button>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    Based on your input, we have speculated three high-level outcomes.
    Please choose the one that is closest to your desired result, or click the "Speculate New Outcomes" button to
    generate a new set of possibilities.
  </p>
  <!-- Add the class 'card-container' to the div below -->
  <div class="row card-container">
    {% for goal in goals %}
      <div class="col-md-4 mb-4">
        <div class="card retro-futuristic-card text-center {% if not goal.compliant %}non-compliant{% endif %}">
          <div class="card-body card-content">
            <i class="{{ goal.icon }} fa-2x mb-3"></i>
            <p class="domain domain-text">{{ goal.domain | title }}</p>
            <div class="card-title" style="text-align: left;">
                {{ goal.title | replace('\n', '<br>') | safe }}
            </div>
            {% if goal.compliant %}
            <form action="/outcome" method="post" class="goal-selection-form">
              <input type="hidden" name="selected_goal" value="{{ goal.title }}">
              <input type="hidden" name="domain" value="{{ goal.domain }}">
              <input type="hidden" name="domain_icon" value="{{ goal.icon }}">
              <input type="hidden" name="user_text" value="{{ user_input }}">
              <button type="submit" class="btn btn-primary">Select</button>
            </form>
            {% else %}
            <button type="button" class="btn btn-danger" onclick="window.location.href='/';">Start Over</button>
            {% endif %}
          </div>
        </div>
      </div>
    {% endfor %}

  </div>
  <div class="text-center">
    <button type="button" class="btn btn-outline-primary" id="generate-new-goals">
      <span class="refresh-icon"><i class="fas fa-sync-alt"></i></span> Speculate New Outcomes</button>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module" src="{{ url_for('static', filename='js/goal_selection.js') }}"></script>
{% endblock %}


üü¶ outcome.html:
{% extends 'base.html' %}

{% block content %}
<div class="container">
    <div class="row outcome-header">
        <div class="col-md-4 text-center">
            {% if ssol.generated_image_path %}
                <img src="{{ url_for('static', filename=ssol.generated_image_path) }}" alt="Generated Image" class="rounded mb-3 generated-image" style="width: 100%; max-width: 300px;">
            {% endif %}
            <h2>Domain</h2>
            <i class="{{ ssol.domain_icon }} fa-3x mb-3"></i>
            <p class="domain domain-text text-center">{{ ssol.domain | title }}</p>
            <h2>Fulfilled Goal</h2>
            <p><strong>{{ ssol.selected_goal | safe }}</strong></p>
            <div id="ssol-goal" style="display: none;">{{ ssol.selected_goal | safe }}</div>
            <div class="text-center mt-4">
                <button id="save-as-pdf-button" data-ssol-id="{{ ssol_id }}" class="btn btn-info" title="Save as PDF">
                    <i class="fas fa-download me-2"></i>PDF
                </button>
            </div>
        </div>
        <div class="col-md-8">
            <h1>Preliminary Structured Solution</h1>
            <p id="ssol-summary">{{ ssol.ssol_summary | safe }}</p>
        </div>
    </div>

    <div class="row">
        <h1>Phases & Conditions of Satisfaction</h1>
        <div class="col">
            <div class="accordion mt-4" id="phase-accordion">
                {% for phase_name, cos_list in ssol.phases.items() %}
                <div class="accordion-item">
                    <h2 class="accordion-header phase-colors" id="heading-{{ phase_name | replace(' ', '_') }}">
                        <button
                            class="accordion-button"
                            type="button"
                            data-bs-toggle="collapse"
                            data-bs-target="#collapse-{{ phase_name | replace(' ', '_') }}"
                            aria-expanded="true"
                            aria-controls="collapse-{{ phase_name | replace(' ', '_') }}"
                            style="background-color: var(--phase-{{ loop.index0 }});">
                            {{ phase_name | title }} PHASE
                        </button>
                    </h2>
                    <div
                        id="collapse-{{ phase_name | replace(' ', '_') }}"
                        class="accordion-collapse collapse show"
                        aria-labelledby="heading-{{ phase_name | replace(' ', '_') }}"
                        data-bs-parent="#phase-accordion">
                        <div class="accordion-body" data-ssol-id="{{ ssol_id }}" style="border: 2px solid var(--phase-{{ loop.index0 }});">
                            {% if cos_list %}
                            <table class="table table-striped phase-table" id="{{ phase_name | replace(' ', '_') }}-table">
                                <thead>
                                    <tr>
                                        <th scope="col">Status</th>
                                        <th scope="col">Condition of Satisfaction</th>
                                        <th scope="col">Accountable Party</th>
                                        <th scope="col">Completion Date</th>
                                        <th scope="col" class="text-end actions-header">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for cos in cos_list %}
                                    <tr class="cos-row" data-cos-id="{{ cos.id }}" data-editing="false">
                                        <td class="status-cell">
                                            <span class="status-pill {{ cos.status | get_badge_class_from_status }}">{{ cos.status | upper }}</span>
                                        </td>
                                        <td class="cos-content-cell">{{ cos.content | safe }}</td>
                                        <td class="cos-accountable-party-cell">{{ cos.accountable_party }}</td>
                                        <td class="cos-completion-date-cell">{{ cos.completion_date }}</td>
                                        <td class="text-end actions-cell">
                                            <div class="cos-actions">
                                                <button class="btn btn-sm btn-primary edit-cos-button">Edit</button>
                                                <button class="btn btn-sm btn-success update-cos-button d-none">Update</button>
                                                <button class="btn btn-sm btn-secondary cancel-cos-button d-none">Cancel</button>
                                                <button class="btn btn-sm btn-danger delete-cos-button">Delete</button>
                                                <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="{{ cos.id }}">Analyze</button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                            <button class="btn btn-success btn-sm add-cos" data-bs-toggle="modal" data-bs-target="#addCOSModal" data-phase="{{ phase_name | replace(' ', '_') }}">Add Condition of Satisfaction</button>
                            {% else %}
                            <p>No Conditions of Satisfaction found for this phase.</p>
                            {% endif %}
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="errorModalLabel">Error</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">{{ error_message }}</div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Placeholder for dynamic modals -->
    <div id="dynamicModalContainer"></div>
</div>
{% endblock %}

{% block scripts %}
<!-- Necessary JS files -->
<script type="module">
  import { showLoadingSpinner, hideLoadingSpinner } from './static/js/base_functions.js';

  document.addEventListener('DOMContentLoaded', () => {
    showLoadingSpinner('Loading data...'); // Show spinner when the page is loading

    window.addEventListener('load', () => {
      hideLoadingSpinner(); // Hide spinner when the page is fully loaded
    });
  });
</script>
<script src="{{ url_for('static', filename='js/cos_table.js') }}"></script>
<script src="{{ url_for('static', filename='js/ce_table.js') }}"></script>
<script src="{{ url_for('static', filename='js/ce_cards.js') }}" type="module"></script>

<!-- Include Tabulator CSS and JS -->
<link href="https://unpkg.com/tabulator-tables@4.9.3/dist/css/tabulator.min.css" rel="stylesheet">
<script src="https://unpkg.com/tabulator-tables@4.9.3/dist/js/tabulator.min.js"></script>

<!-- Initialize event listeners for COS table handling -->
<script>
    document.addEventListener('DOMContentLoaded', () => {
        initializePhaseTableEventListeners();
    });
</script>

<!-- Pass necessary data to JavaScript -->
<script>
    const NODES = {{ nodes|tojson }};
    const tableData = {};  // Define tableData here. Update this with actual data if needed.
</script>
{% endblock %}



üü™ cos_table.js:
function getBadgeClassFromStatus(status) {
  switch (status) {
    case 'Proposed': return 'bg-info';
    case 'In Progress': return 'bg-warning text-dark';
    case 'Completed': return 'bg-success';
    case 'Rejected': return 'bg-danger';
    default: return 'bg-secondary';
  }
}

// Function to add event listeners to the phase table
function initializePhaseTableEventListeners() {
  const phaseTables = document.querySelectorAll('.phase-table');
  phaseTables.forEach(table => {
      table.addEventListener('click', handlePhaseTableClick);
  });
}

// Handles clicks within the phase table
function handlePhaseTableClick(event) {
  const target = event.target;
  const row = target.closest('tr.cos-row');
  if (!row) return;

  const cosId = row.dataset.cosId;

  if (target.matches('.edit-cos-button')) {
      turnRowToEditMode(row);
  } else if (target.matches('.update-cos-button')) {
      handleUpdate(row, cosId);
  } else if (target.matches('.cancel-cos-button')) {
      cancelEditMode(row);
  } else if (target.matches('.delete-cos-button')) {
      deleteCOS(cosId, row);
  }
}

function toggleEditMode(row, editing) {
  const editButton = row.querySelector('.edit-cos-button');
  const updateButton = row.querySelector('.update-cos-button');
  const cancelButton = row.querySelector('.cancel-cos-button');

  if (editing) {
    editButton.classList.add('d-none');
    updateButton.classList.remove('d-none');
    cancelButton.classList.remove('d-none');
  } else {
    editButton.classList.remove('d-none');
    updateButton.classList.add('d-none');
    cancelButton.classList.add('d-none');
  }
}

function turnRowToEditMode(row) {
  storeOriginalValues(row);

  const statusCell = row.querySelector('.status-cell');
  const contentCell = row.querySelector('.cos-content-cell');
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');
  const completionDateCell = row.querySelector('.cos-completion-date-cell');

  const currentStatus = statusCell.textContent.trim();
  const currentContent = contentCell.textContent.trim();
  const currentAccountableParty = accountablePartyCell.textContent.trim();
  const currentCompletionDate = completionDateCell.textContent.trim();

  statusCell.innerHTML = createStatusDropdown(currentStatus);
  contentCell.innerHTML = `<textarea class="form-control form-control-sm" rows="3">${currentContent}</textarea>`;
  accountablePartyCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentAccountableParty}">`;
  completionDateCell.innerHTML = `<input type="date" class="form-control form-control-sm" value="${currentCompletionDate}">`;

  toggleEditMode(row, true);
}

function handleUpdate(row, cosId) {
  const contentInput = row.querySelector('.cos-content-cell textarea');
  const newContent = contentInput ? contentInput.value.trim() : '';
  const statusSelect = row.querySelector('.status-cell select');
  const statusInput = statusSelect.options[statusSelect.selectedIndex].value;
  const accountablePartyInput = row.querySelector('.cos-accountable-party-cell input').value.trim();
  const completionDateInput = row.querySelector('.cos-completion-date-cell input').value;

  const payload = {
    content: newContent,
    status: statusInput,
    accountable_party: accountablePartyInput,
    completion_date: completionDateInput
  };

  fetch(`/update_cos/${cosId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    body: JSON.stringify(payload)
  })
  .then(response => {
    if (!response.ok) {
      return response.json().then(errorData => {
        throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);
      });
    }
    return response.json();
  })
  .then(data => {
    if (data.success) {
      updateRowWithNewValues(row, data.cos);
      toggleEditMode(row, false);
    } else {
      throw new Error(data.error || 'An error occurred while updating the entry.');
    }
  })
  .catch(error => {
    console.error('Error updating COS:', error);
    alert(`An error occurred while updating the entry: ${error.message}`);
  });
}

function createStatusDropdown(selectedStatus) {
  const statuses = ['Proposed', 'In Progress', 'Completed', 'Rejected'];
  return `<select class="form-select form-select-sm">${statuses.map(status => `<option value="${status}"${status === selectedStatus ? ' selected' : ''}>${status}</option>`).join('')}</select>`;
}

function cancelEditMode(row) {
  revertToOriginalValues(row);
  toggleEditMode(row, false);
}

function addCOS(phaseName, ssolId) {
  const payload = {
    content: 'New Condition of Satisfaction',
    status: 'Proposed',
    accountable_party: '',
    completion_date: '',
    ssol_id: ssolId
  };

  fetch(`/create_cos`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    body: JSON.stringify(payload)
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      const phaseTable = document.querySelector(`#${phaseName.replace(' ', '_')}-table tbody`);
      const newRow = document.createElement('tr');
      newRow.classList.add('cos-row');
      newRow.setAttribute('data-cos-id', data.cos.id);
      newRow.innerHTML = `
        <td class="status-cell"><span class="status-pill bg-info ${getBadgeClassFromStatus('Proposed')}">Proposed</span></td>
        <td class="cos-content-cell">${data.cos.content}</td>
        <td class="cos-accountable-party-cell">${data.cos.accountable_party}</td>
        <td class="cos-completion-date-cell">${data.cos.completion_date}</td>
        <td class="text-end actions-cell">
          <div class="cos-actions">
            <button class="btn btn-sm btn-primary edit-cos-button">Edit</button>
            <button class="btn btn-sm btn-success update-cos-button d-none">Update</button>
            <button class="btn btn-sm btn-secondary cancel-cos-button d-none">Cancel</button>
            <button class="btn btn-sm btn-danger delete-cos-button">Delete</button>
            <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="${data.cos.id}">Analyze</button>
          </div>
        </td>
      `;
      phaseTable.appendChild(newRow);
      initializePhaseTableEventListeners();
    } else {
      throw new Error(data.error || 'An error occurred while creating the entry.');
    }
  })
  .catch(error => {
    console.error('Error creating COS:', error);
    alert(`An error occurred while creating the entry: ${error.message}`);
  });
}

document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.add-cos').forEach(button => {
    button.addEventListener('click', (event) => {
      const phaseName = event.target.getAttribute('data-phase');
      const ssolId = document.querySelector('#ssol-goal').getAttribute('data-ssol-id');
      addCOS(phaseName, ssolId);
    });
  });
});

function deleteCOS(cosId, row) {
  if (confirm(`Really delete Condition of Satisfaction?`)) {
    fetch(`/delete_cos/${cosId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    })
    .then(response => {
      if (!response.ok) {
        return response.json().then(errorData => {
          throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);
        });
      }
      return response.json();
    })
    .then(data => {
      if (data.success) {
        row.remove();
      } else {
        throw new Error(data.error || 'An error occurred while deleting the entry.');
      }
    })
    .catch(error => {
      console.error('Error deleting COS:', error);
      alert(`An error occurred while deleting the entry: ${error.message}`);
    });
  }
}

function analyzeCOS(cosId) {
  fetch(`/analyze_cos/${cosId}`)
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        const cosRow = document.querySelector(`tr[data-cos-id="${cosId}"] .cos-content-cell`);
        const newContent = data.analyzed_cos;
        cosRow.innerHTML = replaceCETagsWithPills(newContent);
        initializeCEPillEventListeners();
      } else {
        throw new Error(data.error || 'An error occurred while analyzing the entry.');
      }
    })
    .catch(error => {
      console.error('Error analyzing COS:', error);
      alert(`An error occurred while analyzing the entry: ${error.message}`);
    });
}

document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      analyzeCOS(cosId);
    });
  });
});

function storeOriginalValues(row) {
  const statusCell = row.querySelector('.status-cell');
  const contentCell = row.querySelector('.cos-content-cell');
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');
  const completionDateCell = row.querySelector('.cos-completion-date-cell');

  // Store original values including CE pills
  row.dataset.originalValues = JSON.stringify({
    status: statusCell.textContent.trim(),
    contentWithPills: contentCell.innerHTML.trim(),  // Store the HTML content with CE pills
    accountableParty: accountablePartyCell.textContent.trim(),
    completionDate: completionDateCell.textContent.trim()
  });
}

function revertToOriginalValues(row) {
  const originalValues = JSON.parse(row.dataset.originalValues);
  row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(originalValues.status)}">${originalValues.status}</span>`;
  row.querySelector('.cos-content-cell').innerHTML = originalValues.contentWithPills;
  row.querySelector('.cos-accountable-party-cell').textContent = originalValues.accountableParty;
  row.querySelector('.cos-completion-date-cell').textContent = originalValues.completionDate;
}

function updateRowWithNewValues(row, cos) {
  // Check if the cos object and its properties are defined
  if (cos && cos.status && cos.content) {
    row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(cos.status)}">${cos.status}</span>`;
    row.querySelector('.cos-content-cell').textContent = cos.content;
    row.querySelector('.cos-accountable-party-cell').textContent = cos.accountable_party || '';
    row.querySelector('.cos-completion-date-cell').textContent = cos.completion_date || '';
  } else {
    // If cos or any required property is undefined, log an error or handle appropriately
    console.error('Error: COS data is undefined or missing required properties', cos);
    alert('An error occurred while updating the entry. Please try again.');
  }
}

// Function to add event listeners to the phase table
function initializePhaseTableEventListeners() {
  const phaseTables = document.querySelectorAll('.phase-table');
  phaseTables.forEach(table => {
      table.addEventListener('click', handlePhaseTableClick);
  });
}

function handleResponse(response) {
  if (!response.ok) {
    return response.json().then(errorData => {
      throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);
    });
  }
  return response.json();
}


// Handles clicks within the phase table
function handlePhaseTableClick(event) {
  const target = event.target;
  const row = target.closest('tr.cos-row');
  if (!row) return;

  const cosId = row.dataset.cosId;

  if (target.matches('.edit-cos-button')) {
      turnRowToEditMode(row);
  } else if (target.matches('.update-cos-button')) {
      handleUpdate(row, cosId);
  } else if (target.matches('.cancel-cos-button')) {
      cancelEditMode(row);
  } else if (target.matches('.delete-cos-button')) {
      deleteCOS(cosId, row);
  }
}

// Function to fetch and display analyzed COS for a given COS ID
function fetchAndDisplayAnalyzedCOS(cosId) {
  fetch(`/analyze_cos/${cosId}`)
    .then(response => {
      if (!response.ok) {
        return response.json().then(errorData => {
          throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);
        });
      }
      return response.json();
    })
    .then(data => {
      if (data.success) {
        const cosRow = document.querySelector(`tr[data-cos-id="${cosId}"] .cos-content-cell`);
        if (cosRow) {
          const newContent = data.analyzed_cos;
          cosRow.innerHTML = replaceCETagsWithPills(newContent);
        }
      } else {
        throw new Error(data.error || 'An error occurred while analyzing the entry.');
      }
    })
    .catch(error => {
      console.error('Error analyzing COS:', error);
      alert(`An error occurred while analyzing the entry: ${error.message}`);
    });
}


// Event listener to fetch and display analyzed COS content after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  const analyzeButtons = document.querySelectorAll('.analyze-cos-button');
  analyzeButtons.forEach(button => {
    button.addEventListener('click', function () {
      const cosId = this.getAttribute('data-cos-id');
      fetchAndDisplayAnalyzedCOS(cosId);
    });
  });
});


// Function to add event listeners to CE pills
function initializeCEPillEventListeners() {
  const cePills = document.querySelectorAll('.ce-pill');
  cePills.forEach(pill => {
      pill.addEventListener('click', handleCEPillClick);
  });
}

function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  console.log(`CE Pill with ID ${ceId} clicked`);

  // Example logic to fetch CE details and display in a modal or another UI element
  fetch(`/get_ce_by_id/${ceId}`)
      .then(response => response.json())
      .then(data => {
          if (data && data.ce) {
              displayCEDetails(data.ce); // Function to display CE details
          } else {
              console.error('CE details not found or error in response:', data);
          }
      })
      .catch(error => {
          console.error('Error fetching CE details:', error);
      });
}



// Event listener to initialize phase table event listeners after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.add-cos').forEach(button => {
    button.addEventListener('click', (event) => {
      const phaseName = event.target.getAttribute('data-phase');
      const ssolId = document.querySelector('#ssol-goal').getAttribute('data-ssol-id');
      addCOS(phaseName, ssolId);
    });
  });
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      analyzeCOS(cosId);
    });
  });
});

// Function to add event listeners to CE pills
function initializeCEPillEventListeners() {
  const cePills = document.querySelectorAll('.ce-pill');
  cePills.forEach(pill => {
      pill.addEventListener('click', handleCEPillClick);
  });
}

// Event listener to initialize phase table event listeners after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      if (cosId) {
        fetchAndDisplayAnalyzedCOS(cosId);
      }
    });
  });

  // Add event listener to the Analyze button
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.analyze-cos-button').forEach(button => {
      button.addEventListener('click', (event) => {
        const cosId = event.target.getAttribute('data-cos-id');
        if (cosId) {
          fetchAndDisplayAnalyzedCOS(cosId);
        }
      });
    });
  });

  function extractCosContentForEditing(cosContentCell) {
    const badgeElements = cosContentCell.querySelectorAll('.badge');
    badgeElements.forEach((badge) => {
      const ceContent = badge.textContent;
      // Replace the badge HTML with a placeholder or markup that includes the CE content
      badge.outerHTML = `[CE]${ceContent}[/CE]`;
    });
    return cosContentCell.innerHTML; // This now contains the editable content with [CE][/CE] placeholders
  }


  document.addEventListener('DOMContentLoaded', () => {
    // Get all COS content cells
    const cosContentCells = document.querySelectorAll('.cos-content-cell');

    // Loop over each cell and replace CE tags with pills
    cosContentCells.forEach(cell => {
      const content = cell.textContent;
      const newContent = replaceCETagsWithPills(content); // This is your existing JS function
      cell.innerHTML = newContent;
    });

    // Now that the DOM has been updated, add event listeners to the new pill elements
    addEventListenersToCELabels();
  });
})

// Function to save the content as PDF
function saveAsPDF(ssolId) {
  const htmlContent = document.documentElement.outerHTML; // Get the entire HTML content of the page
  fetch(`/save_as_pdf/${ssolId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ htmlContent: htmlContent })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`Server responded with status ${response.status}`);
    }
    return response.blob();
  })
  .then(blob => {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = `${ssolId}.pdf`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  })
  .catch((error) => {
    console.error('Error saving PDF:', error);
  });
}

// Event listener to initialize after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', function () {
  const saveButton = document.getElementById('save-as-pdf-button');
  if (saveButton) {
    saveButton.addEventListener('click', function (event) {
      event.preventDefault(); // Prevent the default button click action
      const ssolId = saveButton.dataset.ssolId;
      saveAsPDF(ssolId);
    });
  }
});



‚¨ú speculate.py:
# speculate.py
import re
import os
import html
import json
import uuid
from uuid import UUID
import logging
from bs4 import BeautifulSoup
from app import USE_DATABASE, db
from ce_nodes import NODES
from ce_templates import replace_ce_tags_with_pills
from models import session
from sqlalchemy.inspection import inspect
from sqlalchemy.exc import SQLAlchemyError
from ai_service import generate_chat_response, generate_chat_response_with_node_types
from models import COS, CE, SSOL, COS_CE_Link
from store import ssol_store, cos_store, ce_store
from sqlalchemy.orm import relationship, sessionmaker
from flask import render_template, jsonify, current_app
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Date, ForeignKey, create_engine
from utilities import  get_valid_node_types


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def create_cos(ssol_id, content, status, accountable_party=None, completion_date=None):
    try:
        # Analyze the COS content to identify conditional elements
        analyzed_content = analyze_cos(content)
        if 'content_with_ce' not in analyzed_content:
            raise KeyError("Expected 'content_with_ce' in analyzed content")

        content_with_ce = analyzed_content['content_with_ce']

        if USE_DATABASE:
            cos = COS(content=content_with_ce, status=status, accountable_party=accountable_party,
                      completion_date=completion_date, ssol_id=ssol_id)
            db.session.add(cos)
            for ce_data in analyzed_content['ces']:
                ce = CE(content=ce_data['content'], node_type=ce_data['ce_type'])
                db.session.add(ce)
                cos.conditional_elements.append(ce)
            db.session.commit()
            return cos.id
        else:
            cos_id = str(uuid.uuid4())
            cos = {'id': cos_id, 'content': content_with_ce, 'status': status, 'ssol_id': ssol_id}
            cos_store[cos_id] = cos
            for ce_data in analyzed_content['ces']:
                ce_id = str(uuid.uuid4())
                ce = {'id': ce_id, 'content': ce_data['content'], 'node_type': ce_data['ce_type']}
                ce_store[ce_id] = ce
                cos['conditional_elements'] = cos.get('conditional_elements', []) + [ce]
            return cos_id
    except KeyError as e:
        logging.error(f"Error creating COS: {e}")
        raise
    except Exception as e:
        logging.error(f"Error creating COS: {e}", exc_info=True)
        if USE_DATABASE:
            db.session.rollback()
        raise


def get_cos_by_id(cos_id):
    from app import USE_DATABASE
    if USE_DATABASE:
        return COS.query.get(cos_id)
    else:
        return cos_store.get(str(cos_id))

def analyze_cos(cos_content):
    prompt = (
        "Analyze the following condition of satisfaction (COS) and identify any conditional elements (CEs). "
        "Return a JSON object with the COS text and an array of CEs, each with its text and type."
        "\nCOS: '{}'"
        "\nExpected response format:"
        "{{"
        "  'COS': 'The full text of the COS',"
        "  'CEs': ["
        "    {{'text': 'A conditional element', 'type': 'The type of CE (must be one of the valid node types)'}}"
        "  ]"
        "}}"
    ).format(cos_content)

    messages = [
        {"role": "system", "content": "Return a JSON object with the analyzed COS and CEs. **The response should be valid JSON.**"},
        {"role": "user", "content": prompt},
    ]

    try:
        # Send messages to the AI and get the response
        response_text = generate_chat_response_with_node_types(messages, role='COS Analysis', task='Analyze COS')
        response_json = json.loads(response_text)

        # Extract the COS and CEs from the response
        cos_text = response_json.get("COS", cos_content)
        ces = response_json.get("CEs", [])

        valid_node_types = get_valid_node_types()

        # Validate and process the CEs
        valid_ces = []
        for ce in ces:
            if ce["type"] in valid_node_types:
                valid_ces.append({
                    'content': ce["text"],
                    'ce_type': ce["type"]
                })

        content_with_ce = replace_ce_tags_with_pills(cos_text, valid_ces)

        return {
            'content_with_ce': content_with_ce,
            'ces': valid_ces
        }

    except Exception as e:
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)
        return {
            'content_with_ce': cos_content,
            'ces': []
        }

def extract_conditional_elements(response_text, original_content):
    ces = []
    try:
        # Use regex to extract CEs from response_text
        matches = re.findall(r'<ce>(.*?)</ce>', response_text, re.IGNORECASE)
        content_with_ce = original_content

        for match in matches:
            ce_content = html.escape(match.strip())  # Escape HTML special characters
            ce_uuid = str(uuid.uuid4())
            # Replace only the first occurrence of the matched CE content
            content_with_ce = re.sub(rf'<ce>\s*{re.escape(match.strip())}\s*</ce>', f'<span class="ce-pill" data-ce-id="{ce_uuid}">{ce_content}</span>', content_with_ce, count=1)
            ces.append({'id': ce_uuid, 'content': ce_content, 'ce_type': 'Unknown'})

        return {'content_with_ce': content_with_ce, 'ces': ces}
    except Exception as e:
        # Handle any errors that occur during the extraction process
        logging.error(f"Error extracting conditional elements: {e}", exc_info=True)
        return {'content_with_ce': original_content, 'ces': []}


def update_cos_by_id(cos_id, updated_data):
    from app import db, USE_DATABASE
    try:
        # If using database, convert UUID to string for query
        cos_id_str = str(cos_id) if isinstance(cos_id, UUID) else cos_id

        # Update the COS entry with new data
        if USE_DATABASE:
            # Database operation
            cos = session.query(COS).filter_by(id=cos_id).first()
            if cos:
                for key, value in updated_data.items():
                    setattr(cos, key, value)
                session.commit()
                return {'success': True, 'cos': cos.to_dict()}  # Return the updated COS for client-side use
            else:
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}
        else:
            # In-memory operation
            cos = cos_store.get(cos_id_str)  # Attempt to retrieve the COS entry
            if not cos:
                # COS not found, log a warning
                current_app.logger.warning(f"COS with ID {cos_id_str} not found in the in-memory store.")
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}

            for key, value in updated_data.items():
                cos[key] = value
            cos_store[cos_id_str] = cos  # Store the updated COS back in the store

            # Log the successful update and return the updated COS
            current_app.logger.info(f"COS with ID {cos_id_str} successfully updated.")
            return {'success': True, 'cos': cos}  # Return the updated COS for client-side use

    except Exception as e:
        # Log the error and return an error message
        current_app.logger.error(f"Unexpected error during COS update: {e}", exc_info=True)
        return {'success': False, 'message': f"Unexpected error occurred: {e}"}


def delete_cos_by_id(cos_id, ssol_id=None):
    from app import USE_DATABASE
    if USE_DATABASE:
        # Database operation
        cos = session.query(COS).filter_by(id=cos_id).first()
        if cos and (ssol_id is None or cos.ssol_id == ssol_id):
            session.delete(cos)
            session.commit()
            return True  # COS was deleted successfully
        else:
            return False  # COS did not exist or did not match the provided SSOL_ID
    else:
        # In-memory operation
        cos = cos_store.get(cos_id)
        if cos and (ssol_id is None or cos['ssol_id'] == ssol_id):
            del cos_store[cos_id]
            return True  # COS was deleted successfully
        return False  # COS did not exist or did not match the provided SSOL_ID

# Function to analyze the COS content and extract the CE type(s)
def get_ce_type(ce_content):
    messages = [
        {"role": "system", "content": "You are responsible for identifying the appropriate card type for the given conditional element. **Respond with valid JSON.**"},
        {"role": "user", "content": ce_content},
    ]
    response_text = generate_chat_response(messages, role='Conditional Element (CE) Node Type Identification', task='Identify CE Type', temperature=0.8)

    try:
        response_data = json.loads(response_text)
        ce_type = response_data.get('type', '')  # Assuming the key for the CE type in the response is 'type'
        return ce_type
    except json.JSONDecodeError:
        logging.error(f"Error parsing JSON response: {response_text}")
        return ""

# CRUD operations for SSOL
def create_ssol(goal, summary):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = SSOL(goal=goal, summary=summary)
        db.session.add(ssol)
        db.session.commit()
        return ssol.id
    else:
        ssol_id = str(uuid.uuid4())
        ssol_store[ssol_id] = {'id': ssol_id, 'goal': goal, 'summary': summary}
        return ssol_id

def get_ssol_by_id(ssol_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        return SSOL.query.get(ssol_id)
    else:
        return ssol_store.get(ssol_id)

def update_ssol_by_id(ssol_id, updated_data):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()
        for key, value in updated_data.items():
            setattr(ssol, key, value)
        session.commit()
    else:
        ssol = ssol_store.get(ssol_id)
        if ssol:
            ssol.update(updated_data)

def delete_ssol_by_id(ssol_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()
        session.delete(ssol)
        session.commit()
    else:
        ssol = ssol_store.pop(ssol_id, None)
        return bool(ssol)  # Returns True if an SSOL was deleted, False otherwise

def get_ce_by_id(ce_id: UUID):
    try:
        if USE_DATABASE:
            ce = session.query(CE).get(ce_id)
            if not ce:
                current_app.logger.error(f"CE with ID {ce_id} not found in database.")
                raise ValueError(f"CE with ID {ce_id} not found in the database.")
        else:
            ce_id_str = str(ce_id)
            ce_dict = ce_store.get(ce_id_str)
            if not ce_dict:
                current_app.logger.error(f"CE with ID {ce_id_str} not found in in-memory store.")
                raise ValueError(f"CE with ID {ce_id_str} not found in the in-memory store.")

            ce_fields = {c.name for c in CE.__table__.columns}
            ce_dict_filtered = {key: value for key, value in ce_dict.items() if key in ce_fields}
            ce = CE(**ce_dict_filtered)

        return ce

    except ValueError as e:
        logging.error(f"Error retrieving CE by ID {ce_id}: {e}")
        raise e
    except SQLAlchemyError as e:
        logging.error(f"Database error retrieving CE by ID {ce_id}: {e}", exc_info=True)
        raise e
    except Exception as e:
        logging.error(f"Unexpected error retrieving CE by ID {ce_id}: {e}", exc_info=True)
        raise e


def create_ce(content, node_type, cos_id):
    ce_id = str(uuid.uuid4())
    ce_data = {
        'id': ce_id,
        'content': content,
        'node_type': node_type,
        'cos_id': cos_id
    }

    if USE_DATABASE:
        ce = CE(id=ce_id, content=content, node_type=node_type, cos_id=cos_id)
        db.session.add(ce)
        db.session.commit()
        current_app.logger.debug(f"Created CE in database: {ce}")
    else:
        ce_store[ce_id] = ce_data
        current_app.logger.debug(f"Created CE in in-memory store: {ce_store[ce_id]}")

    return ce_id

def update_ce_by_id(ce_id: UUID, ce_data):
    if USE_DATABASE:
        ce = CE.query.get(ce_id)
        if ce:
            for key, value in ce_data.items():
                setattr(ce, key, value)
            db.session.commit()
            return True
        else:
            current_app.logger.error(f"CE with ID {ce_id} not found in database.")
            return False
    else:
        ce_id_str = str(ce_id)
        if ce_id_str in ce_store:
            ce_store[ce_id_str].update(ce_data)
            return True
        else:
            current_app.logger.error(f"CE with ID {ce_id_str} not found in in-memory store.")
            return False

def delete_ce_by_id(ce_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ce = session.query(CE).filter_by(id=ce_id).first()
        session.delete(ce)
        session.commit()
    else:
        if ce_id in ce_store:
            del ce_store[ce_id]
            return True  # CE was deleted successfully
        return False  # CE did not exist in the store

def get_badge_class_from_status(status):
    return {
        'Proposed': 'bg-info',
        'In Progress': 'bg-warning text-dark',  # Added text-dark for better contrast
        'Completed': 'bg-success',
        'Rejected': 'bg-danger'
    }.get(status, 'bg-secondary')  # Default to 'bg-secondary' if status is not found


    # Ensure database or in-memory store is initialized based on USE_DATABASE flag
def initialize_data_store():
    from app import USE_DATABASE, Base, _engine
    Base.metadata.create_all(_engine) if USE_DATABASE else None


def check_data_store_contents(data_store_type='in_memory'):
    if data_store_type == 'in_memory':
        try:
            # Print contents of the in-memory store
            for cos_id_str, cos_data in cos_store.items():
                logging.info(f"COS ID: {cos_id_str}, Data: {cos_data}")
        except NameError:
            logging.warning("In-memory store 'cos_store' not found.")
    elif data_store_type == 'database' and USE_DATABASE:
        try:
            # Query all entries in the COS table and print them
            cos_entries = COS.query.all()
            for entry in cos_entries:
                logging.info(f"COS ID: {entry.id}, Data: {entry}")
        except Exception as e:
            logging.error(f"Database query failed with error: {e}")
    else:
        logging.error(f"Unknown data store type: {data_store_type}")

        if __name__ == '__main__':
            logging.info("Checking initial data store contents...")
            check_data_store_contents('database' if USE_DATABASE else 'in_memory')

def get_phase_index(cos):
    # Determine the phase index based on the COS content or other criteria
    phase_mapping = {
        'Discovery': 0,
        'Engagement': 1,
        'Action': 2,
        'Completion': 3,
        'Legacy': 4,
    }
    # Example logic to determine the phase index
    phase_name = cos.get('phase', 'SSPEC')  # Default to 'SSPEC Time Mapper' if phase not found
    return phase_mapping.get(phase_name, 0)  # Default to 0 if phase not found in mapping

def parse_ai_response_and_generate_html(response_json):
    structured_solution = {}
    expected_phases = ["Discovery", "Engagement", "Action", "Completion", "Legacy"]

    for phase in expected_phases:
        structured_solution[phase] = []
        for cos in response_json.get(phase, []):
            cos_id = str(uuid.uuid4())
            cos_html = cos['content']
            ces = []

            soup = BeautifulSoup(cos_html, 'html.parser')
            for ce_tag in soup.find_all('ce'):
                ce_uuid = str(uuid.uuid4())
                new_tag = soup.new_tag('span', attrs={
                    'class': 'badge rounded-pill bg-secondary ce-pill',
                    'data-ce-id': ce_uuid,
                    'data-ce-type': ce_tag['type']
                })
                new_tag.string = ce_tag.string
                ce_tag.replace_with(new_tag)

                ce_data = {
                    'id': ce_uuid,
                    'content': ce_tag.string,
                    'status': 'Proposed',
                    'type': ce_tag['type']
                }
                ces.append(ce_data)

                # Store the CEs
                if USE_DATABASE:
                    ce_instance = CE(id=ce_uuid, content=ce_tag.string, node_type=ce_tag['type'])
                    db.session.add(ce_instance)
                else:
                    ce_store[ce_uuid] = ce_data

            if USE_DATABASE:
                db.session.commit()

            structured_solution[phase].append({
                'id': cos_id,
                'content': str(soup),
                'status': 'Proposed',
                'ces': ces
            })

    return structured_solution


üü´ ce_table.js:
function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  const ceType = event.target.dataset.ceType || "Default";
  const cosContent = event.target.closest('tr').querySelector('.cos-content-cell').textContent.trim();
  const phaseElement = event.target.closest('.accordion-item');
  const phaseName = phaseElement.querySelector('.accordion-header button').innerText.trim();
  const phaseIndex = Array.from(phaseElement.parentElement.children).indexOf(phaseElement);

  const requestData = {
    ce_id: ceId,
    cos_content: cosContent,
    phase_name: phaseName,
    phase_index: phaseIndex,
    ssol_goal: document.querySelector('#ssol-goal').textContent.trim()
  };

  fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestData)
  })
  .then(response => response.json())
  .then(data => {
    if (data && data.modal_html) {
      displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, data.ai_context);
    } else {
      throw new Error('Modal HTML content not found or error in response');
    }
  })
  .catch(error => console.error('Error fetching modal content:', error));
}


// Function to display the CE modal
function showCEModal(ceData) {
  const modal = document.createElement('div');
  modal.classList.add('modal', 'fade');
  modal.id = 'ceModal';
  modal.setAttribute('tabindex', '-1');
  modal.setAttribute('aria-labelledby', 'ceModalLabel');
  modal.setAttribute('aria-hidden', 'true');

  const modalDialog = document.createElement('div');
  modalDialog.classList.add('modal-dialog', 'modal-dialog-centered');
  modalDialog.setAttribute('role', 'document');

  const modalContent = createCEModalContent(ceData);
  modalDialog.appendChild(modalContent);
  modal.appendChild(modalDialog);

  document.body.appendChild(modal);

  $(modal).modal('show');

  $(modal).on('hidden.bs.modal', function () {
    modal.remove();
  });
}

function handleSaveButtonClick(event, row) {
  const ceContentInput = row.querySelector('.ce-content-input');
  const newContent = ceContentInput.value.trim();
  const ceId = row.dataset.ceId;
  // Send the updated content to the server
  fetch(`/update_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId, content: newContent}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the update was successful
    if (data.success) {
      // Update the UI to show the new content
      const ceContentCell = row.querySelector('.ce-content-cell');
      ceContentCell.textContent = newContent;
      // Change the "Save" button back to an "Edit" button
      const editButton = row.querySelector('.edit-ce-button');
      editButton.classList.remove('d-none');
      event.target.classList.add('d-none');
    } else {
      console.error('Error updating CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleDeleteButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send a delete request to the server
  fetch(`/delete_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the delete was successful
    if (data.success) {
      // Remove the row from the table
      row.remove();
    } else {
      console.error('Error deleting CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleAnalyzeButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send the COS/CE content to the server for analysis
  fetch(`/analyze_cos/${ceId}`)
  .then(response => response.json())
  .then(data => {
    // Display the analysis results
    if (data.analyzed_cos) {
      // Update the UI with the analyzed data
      // This could be displaying a modal, updating a field, etc.
      console.log('Analyzed COS:', data.analyzed_cos);
    } else {
      console.error('Error analyzing COS:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}


üè≥Ô∏è‚Äçüåà ce_nodes.py:
NODES = {
    "Default": {
        "definition": "This node is a default research mode for undefined node types.",
        "icon": "fa-solid fa-icons",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "subject", "placeholder": "Subject"},
                {"type": "textarea", "name": "details", "placeholder": "Details"},
                {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}
            ],
            "explanation": "Default Resource Node.",
            "ai_context": "Provide general information and suggestions to help achieve the Condition of Satisfaction (COS)."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Subject", "field": "subject", "editor": "input"},
                {"title": "Details", "field": "details", "editor": "input"},
                {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}
            ]
        }
    },
    "Research": {
        "definition": "Aggregates and summarizes research materials and resources pertinent to the COS.",
        "icon": "fa-solid fa-flask",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "research_topic", "placeholder": "Research Topic"},
                {"type": "textarea", "name": "research_summary", "placeholder": "Research Summary"},
                {"type": "text", "name": "research_website", "placeholder": "Research Website"}
            ],
            "explanation": "Capture relevant research aspects of the node.",
            "ai_context": "Provide detailed research information, studies, and academic resources relevant to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Research Topic", "field": "research_topic", "editor": "input"},
                {"title": "Research Summary", "field": "research_summary", "editor": "textarea"},
                {"title": "Research Website", "field": "research_website", "editor": "input"}
            ]
        }
    },
    "Stakeholder": {
        "definition": "Captures details of stakeholders involved in the COS.",
        "icon": "fa-solid fa-user-friends",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "stakeholder_name", "placeholder": "Stakeholder Name"},
                {"type": "textarea", "name": "stakeholder_role", "placeholder": "Stakeholder Role"},
                {"type": "email", "name": "stakeholder_email", "placeholder": "Stakeholder Email"},
                {"type": "text", "name": "stakeholder_phone", "placeholder": "Stakeholder Phone"},
            ],
            "explanation": "Detail the roles and contact information of stakeholders related to the COS.",
            "ai_context": "Identify and provide details of stakeholders involved in the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Stakeholder Name", "field": "stakeholder_name", "editor": "input"},
                {"title": "Stakeholder Role", "field": "stakeholder_role", "editor": "textarea"},
                {"title": "Stakeholder Email", "field": "stakeholder_email", "editor": "input"},
                {"title": "Stakeholder Phone", "field": "stakeholder_phone", "editor": "input"},
            ]
        }
    },
    "Advocacy": {
    "definition": "Focuses on efforts to influence public policy and resource allocation decisions.",
    "icon": "fa-solid fa-bullhorn",
    "modal_config": {
        "fields": [
            {"type": "text", "name": "campaign_name", "placeholder": "Campaign Name"},
            {"type": "textarea", "name": "campaign_objective", "placeholder": "Campaign Objective"},
            {"type": "text", "name": "target_audience", "placeholder": "Target Audience"}
        ],
        "explanation": "Detail the advocacy campaign's objectives and target audience.",
        "ai_context": "Provide information on advocacy efforts and campaign strategies pertinent to the COS."
    },
    "tabulator_config": {
        "columns": [
            {"title": "Campaign Name", "field": "campaign_name", "editor": "input"},
            {"title": "Campaign Objective", "field": "campaign_objective", "editor": "textarea"},
            {"title": "Target Audience", "field": "target_audience", "editor": "input"}
        ]
    }
    },

    "Resource": {
        "definition": "Lists resources or assets essential for achieving the COS.",
        "icon": "fa-solid fa-tools",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "resource_name", "placeholder": "Resource Name"},
                {"type": "textarea", "name": "resource_details", "placeholder": "Resource Details"},
                {"type": "text", "name": "resource_type", "placeholder": "Resource Type"}
            ],
            "explanation": "Provide details about resources or assets required for the COS.",
            "ai_context": "List and detail resources or assets essential for achieving the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Resource Name", "field": "resource_name", "editor": "input"},
                {"title": "Resource Details", "field": "resource_details", "editor": "textarea"},
                {"title": "Resource Type", "field": "resource_type", "editor": "input"}
            ]
        }
    },
    "Praxis": {
        "definition": "Defines actions or tasks necessary to meet the COS.",
        "icon": "fa-solid fa-tasks",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "action_name", "placeholder": "Action Name"},
                {"type": "textarea", "name": "action_description", "placeholder": "Action Description"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ],
            "explanation": "Specify tasks or actions required to fulfill the COS.",
            "ai_context": "Detail actions or tasks necessary to meet the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Action Name", "field": "action_name", "editor": "input"},
                {"title": "Action Description", "field": "action_description", "editor": "textarea"},
                {"title": "Responsible Person", "field": "responsible_person", "editor": "input"}
            ]
        }
    },
    "Timeline": {
        "definition": "Specifies time frames or deadlines associated with the COS.",
        "icon": "fa-solid fa-clock",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "time_frame", "placeholder": "Time Frame"},
                {"type": "date", "name": "start_date", "placeholder": "Start Date"},
                {"type": "date", "name": "end_date", "placeholder": "End Date"}
            ],
            "explanation": "Provide time-related information such as deadlines and schedules for the COS.",
            "ai_context": "Detail time frames or deadlines associated with the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Time Frame", "field": "time_frame", "editor": "input"},
                {"title": "Start Date", "field": "start_date", "editor": "input"},
                {"title": "End Date", "field": "end_date", "editor": "input"}
            ]
        }
    },
    "Collaboration": {
        "definition": "Focuses on partnerships or collaboration efforts necessary for the COS.",
        "icon": "fa-solid fa-handshake",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "partner_name", "placeholder": "Partner Name"},
                {"type": "textarea", "name": "collaboration_details", "placeholder": "Collaboration Details"},
                {"type": "text", "name": "contact_person", "placeholder": "Contact Person"}
            ],
            "explanation": "Outline collaboration efforts and partnerships related to the COS.",
            "ai_context": "Detail partnerships or collaboration efforts necessary for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Partner Name", "field": "partner_name", "editor": "input"},
                {"title": "Collaboration Details", "field": "collaboration_details", "editor": "textarea"},
                {"title": "Contact Person", "field": "contact_person", "editor": "input"}
            ]
        }
    },
    "Policy": {
        "definition": "Addresses policy or regulatory aspects pertinent to the COS.",
        "icon": "fa-solid fa-gavel",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "policy_name", "placeholder": "Policy Name"},
                {"type": "textarea", "name": "policy_details", "placeholder": "Policy Details"},
                {"type": "text", "name": "regulatory_body", "placeholder": "Regulatory Body"}
            ],
            "explanation": "Detail policies or regulations impacting the COS.",
            "ai_context": "Provide information on policies or regulatory aspects pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Policy Name", "field": "policy_name", "editor": "input"},
                {"title": "Policy Details", "field": "policy_details", "editor": "textarea"},
                {"title": "Regulatory Body", "field": "regulatory_body", "editor": "input"}
            ]
        }
    },
    "Legislation": {
        "definition": "Covers legal considerations or requirements pertinent to the COS.",
        "icon": "fa-solid fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "legal_requirements", "placeholder": "Legal Requirements"},
                {"type": "text", "name": "relevant_legislation", "placeholder": "Relevant Legislation"},
                {"type": "text", "name": "compliance_officer", "placeholder": "Compliance Officer"}
            ],
            "explanation": "Detail legal considerations and requirements for the COS.",
            "ai_context": "Provide information on legal considerations or requirements pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Legal Requirements", "field": "legal_requirements", "editor": "textarea"},
                {"title": "Relevant Legislation", "field": "relevant_legislation", "editor": "input"},
                {"title": "Compliance Officer", "field": "compliance_officer", "editor": "input"}
            ]
        }
    },
    "Environment": {
        "definition": "Addresses environmental factors related to the COS.",
        "icon": "fa-solid fa-leaf",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "environmental_factor", "placeholder": "Environmental Factor"},
                {"type": "textarea", "name": "impact_assessment", "placeholder": "Impact Assessment"},
                {"type": "text", "name": "mitigation_strategy", "placeholder": "Mitigation Strategy"}
            ],
            "explanation": "Detail environmental factors and their impact on the COS.",
            "ai_context": "Provide information on environmental factors and impact assessments pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Environmental Factor", "field": "environmental_factor", "editor": "input"},
                {"title": "Impact Assessment", "field": "impact_assessment", "editor": "textarea"},
                {"title": "Mitigation Strategy", "field": "mitigation_strategy", "editor": "input"}
            ]
        }
    },
    "Risk": {
        "definition": "Identifies potential risks and mitigation strategies for the COS.",
        "icon": "fa-solid fa-exclamation-triangle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "risk_name", "placeholder": "Risk Name"},
                {"type": "textarea", "name": "risk_description", "placeholder": "Risk Description"},
                {"type": "text", "name": "mitigation_plan", "placeholder": "Mitigation Plan"}
            ],
            "explanation": "Detail potential risks and strategies to mitigate them for the COS.",
            "ai_context": "Identify potential risks and provide mitigation strategies for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Risk Name", "field": "risk_name", "editor": "input"},
                {"title": "Risk Description", "field": "risk_description", "editor": "textarea"},
                {"title": "Mitigation Plan", "field": "mitigation_plan", "editor": "input"}
            ]
        }
    },
    "Opportunity": {
        "definition": "Identifies opportunities that can enhance the COS.",
        "icon": "fa-solid fa-lightbulb",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "opportunity_name", "placeholder": "Opportunity Name"},
                {"type": "textarea", "name": "opportunity_description", "placeholder": "Opportunity Description"},
                {"type": "text", "name": "exploitation_plan", "placeholder": "Exploitation Plan"}
            ],
            "explanation": "Detail opportunities and strategies to capitalize on them for the COS.",
            "ai_context": "Identify opportunities and provide strategies to exploit them for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Opportunity Name", "field": "opportunity_name", "editor": "input"},
                {"title": "Opportunity Description", "field": "opportunity_description", "editor": "textarea"},
                {"title": "Exploitation Plan", "field": "exploitation_plan", "editor": "input"}
            ]
        }
    }
}

def get_valid_node_types():
    return list(NODES.keys())


üîµ ce_cards.js:
// ce_cards.js

import { showLoadingSpinner, hideLoadingSpinner } from './base_functions.js';
let hasUnsavedChanges = false;

// Initialize ce_store if not already defined
if (typeof ce_store === 'undefined') {
  var ce_store = {};
}

document.addEventListener('DOMContentLoaded', function () {
  setupEventListeners();
});

function setupEventListeners() {
  document.querySelectorAll('.ce-pill').forEach(pill => {
    pill.removeEventListener('click', handleCEPillClick); // Remove any existing event listeners
    pill.addEventListener('click', handleCEPillClick);
    pill.addEventListener('dblclick', handleCEPillDoubleClick); // Add double-click event listener
    pill.setAttribute('title', 'Double-tap to open Conditional Element'); // Add tooltip
  });
}

function handleCEPillClick(event) {
  event.preventDefault();
  event.stopPropagation();

  const existingModal = document.querySelector('.modal.fade.show');
  if (existingModal) {
    existingModal.remove();
  }

  const ceId = event.target.dataset.ceId;
  const ceType = event.target.dataset.ceType || "Default";
  const iconClass = NODES[ceType]?.icon || 'fa-spinner'; // Get the appropriate icon class or default to fa-spinner
  const cosContentCell = event.target.closest('tr').querySelector('.cos-content-cell');
  const cosContent = cosContentCell ? cosContentCell.innerHTML : ''; // Use innerHTML instead of textContent
  const phaseElement = event.target.closest('.accordion-item');
  const phaseName = phaseElement.querySelector('.accordion-header button').innerText.trim();
  const phaseIndex = Array.from(phaseElement.parentElement.children).indexOf(phaseElement);
  const ssolGoal = document.querySelector('#ssol-goal').textContent.trim();

  const requestData = {
    ce_id: ceId,
    cos_content: cosContent,
    phase_name: phaseName,
    phase_index: phaseIndex,
    ssol_goal: ssolGoal
  };

  showLoadingSpinner(`Loading ${ceType} data...`, iconClass); // Pass the icon class here
  fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestData)
  })
    .then(response => response.json())
    .then(data => {
      hideLoadingSpinner();
      if (data && data.modal_html) {
        const aiGeneratedData = data.ai_generated_data || { fields: {} };
        displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, aiGeneratedData, data.table_data, data.tabulator_columns, ssolGoal);
      } else {
        console.error(`CE type "${ceType}" not found in response`);
      }
    })
    .catch(error => {
      hideLoadingSpinner();
      console.error('Error fetching modal content:', error);
    });
}

function handleCEPillDoubleClick(event) {
  handleCEPillClick(event); // Reuse the click handler for double-click
}

const DEFAULT_FIELDS_CONFIG = [
  { type: 'text', name: 'subject', placeholder: 'Subject' },
  { type: 'textarea', name: 'details', placeholder: 'Details' },
  { type: 'text', name: 'stakeholders', placeholder: 'Stakeholders' }
];

const DEFAULT_TABULATOR_CONFIG = {
  columns: [
    { title: 'Subject', field: 'subject', editor: 'input' },
    { title: 'Details', field: 'details', editor: 'input' },
    { title: 'Stakeholders', field: 'stakeholders', editor: 'input' }
  ]
};

function displayCEModal(modalHtml, ceId, ceType, cosContent, phaseName, phaseIndex, aiGeneratedData = { fields: {} }, tableData, tabulatorColumns, ssolGoal) {
  const modalContainer = document.getElementById('dynamicModalContainer');
  if (!modalContainer) {
      console.error('Modal container element not found in the DOM');
      return;
  }

  const phaseColors = ["#e91e63", "#00bcd4", "#9c27b0", "#ffc107", "#66bd0e"];
  const phaseColor = phaseColors[phaseIndex % phaseColors.length];

  const fieldsConfig = NODES[ceType]?.modal_config.fields || DEFAULT_FIELDS_CONFIG;
  const tabulatorConfig = NODES[ceType]?.tabulator_config.columns || DEFAULT_TABULATOR_CONFIG.columns;
  const cosContentWithPills = replace_ce_tags_with_pills(cosContent, ce_store);

  const iconClass = NODES[ceType]?.icon || 'fa-solid fa-icons'; // Use default icon if not found

  const wrappedModalHtml = `
      <div class="modal fade" id="ceModal-${ceId}" tabindex="-1" aria-labelledby="ceModalLabel-${ceId}" aria-hidden="true">
          <div class="modal-dialog modal-lg" role="document">
              <div class="modal-content">
                  <div class="modal-header" style="background-color: ${phaseColor};">
                      <div class="filled-box"></div>
                      <h5 class="modal-title" id="ceModalLabel-${ceId}">
                          <span class="node-icon me-2" style="color: ${phaseColor};">
                              <i class="${iconClass}"></i>
                          </span>
                          <span class="modal-header-title">${ceType.replace('_', ' ').toUpperCase()} // ${phaseName.toUpperCase()}</span>
                      </h5>
                      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                      <p><span class="context-label">Source COS:</span>${cosContentWithPills}</p>
                      <p><span class="context-label">${ceType}:</span><span class="context-text">${aiGeneratedData.contextual_description || 'No contextual description available.'}</span></p>
                      <div id="dynamicTable-${ceId}" class="tabulator-table mb-3"></div>
                      <div class="row justify-content-start mb-3">
                          <div class="col-auto">
                              <button type="button" class="btn btn-sm btn-danger" id="deleteSelectedRowsButton-${ceId}">Delete</button>
                              <button type="button" class="btn btn-sm btn-secondary" id="duplicateSelectedRowsButton-${ceId}">Duplicate</button>
                          </div>
                      </div>
                      <form id="ceForm-${ceId}">
                          ${generateFormFields(fieldsConfig, aiGeneratedData.fields)}
                      </form>
                      <div class="row mt-2">
                          <div class="col">
                              <button type="button" class="btn btn-success w-100" id="addRowButton-${ceId}" style="padding-top: 10px;">Add ${ceType}</button>
                          </div>
                          <div class="col">
                              <button type="button" class="btn btn-primary w-100" id="generateRowButton-${ceId}" style="padding-top: 10px;">Generate ${ceType}</button>
                          </div>
                      </div>
                  </div>
                  <div class="modal-footer">
                      <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                      <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="${ceId}">Save changes</button>
                  </div>
              </div>
          </div>
      </div>
  `;

  modalContainer.innerHTML = wrappedModalHtml;

  const modalElement = modalContainer.querySelector(`#ceModal-${ceId}`);
  if (modalElement) {
      const modal = new bootstrap.Modal(modalElement);
      modal.show();

      modalElement.addEventListener('shown.bs.modal', function () {
          const tableElementId = `#dynamicTable-${ceId}`;
          const table = initializeTabulatorTable(tableElementId, tableData, tabulatorConfig, ceType);
          modalElement._tabulator = table;
      });

      modalElement.addEventListener('hidden.bs.modal', function () {
          if (hasUnsavedChanges && !confirm('You have unsaved changes. Do you really want to close?')) {
              const modal = new bootstrap.Modal(modalElement);
              modal.show();
          } else {
              setupEventListeners();
          }
      });

      setupModalEventListeners(modalElement, ceId, ceType, cosContent, phaseName, phaseIndex, ssolGoal);
  } else {
      console.error(`Modal element not found in the DOM for CE ID: ${ceId}`);
  }
}


function replace_ce_tags_with_pills(content, ce_store) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(content, 'text/html');
  const ceTags = doc.querySelectorAll('ce');

  ceTags.forEach(ceTag => {
    const ceId = ceTag.getAttribute('id');
    const ceType = ceTag.getAttribute('type');
    const ceText = ceTag.textContent;
    const ceData = ce_store[ceId] || {};

    const pill = document.createElement('span');
    pill.className = 'badge rounded-pill bg-secondary ce-pill position-relative';
    pill.dataset.ceId = ceId;
    pill.dataset.ceType = ceType;
    pill.textContent = ceText;
    pill.title = "Double-tap to open Conditional Element";

    if (ceData.is_new) {
      const greenDot = document.createElement('span');
      greenDot.className = 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle';
      const visuallyHiddenText = document.createElement('span');
      visuallyHiddenText.className = 'visually-hidden';
      visuallyHiddenText.textContent = 'New CE';
      greenDot.appendChild(visuallyHiddenText);
      pill.appendChild(greenDot);
    }

    const nonNullRows = ceData.table_data ? ceData.table_data.filter(row => Object.values(row).some(value => value !== null && value !== '')) : [];
    const resourceCount = nonNullRows.length;
    if (resourceCount > 0) {
      const tally = document.createElement('span');
      tally.className = 'badge rounded-pill bg-light text-dark ms-2 ce-pill counter';
      tally.textContent = resourceCount.toString();
      pill.appendChild(tally);
    }

    ceTag.replaceWith(pill);
  });

  return doc.body.innerHTML;
}

function generateFormFields(fieldsConfig, aiData) {
  console.log("generateFormFields called with fieldsConfig:", fieldsConfig);
  console.log("generateFormFields called with aiData:", aiData);

  if (!fieldsConfig) {
    console.error("No fieldsConfig provided.");
    return 'No form fields available.';
  }

  return fieldsConfig.map(field => {
    console.log("Generating field:", field);

    const fieldValue = aiData[field.name] || '';
    const placeholder = field.placeholder || '';

    if (field.type === 'textarea') {
      return `
        <div class="form-group">
          <label for="${field.name}">${placeholder}</label>
          <textarea class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}">${fieldValue}</textarea>
        </div>
      `;
    } else {
      return `
        <div class="form-group">
          <label for="${field.name}">${placeholder}</label>
          <input type="${field.type}" class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}" value="${fieldValue}">
        </div>
      `;
    }
  }).join('');
}

function initializeTabulatorTable(tableSelector, tableData, tabulatorColumns, ceType) {
  const tableElement = document.querySelector(tableSelector);
  if (!tableElement) {
      console.error('Table element not found:', tableSelector);
      return;
  }

  const initialData = tableData.length ? tableData : [];

  try {
    const table = new Tabulator(tableSelector, {
      data: initialData,
      layout: "fitColumns",
      movableColumns: true,
      resizableRows: true,
      selectable: true,
      reactiveData: true,
      placeholder: `Add or Generate ${ceType}`,
      rowHeight: 40,  // Ensure this is the correct option
      columns: [
          {
              title: "",
              width: 30,
              rowHandle: true,
              formatter: "handle",
              headerSort: false,
              resizable: false,
              hozAlign: "center"
          },
          {
              formatter: "rowSelection",
              titleFormatter: "rowSelection",
              hozAlign: "center",
              headerSort: false,
              width: 40,
              resizable: false,
              cellClick: function (e, cell) {
                  cell.getRow().toggleSelect();
              }
          },
          ...tabulatorColumns,
      ],
  });

      return table;
  } catch (error) {
      console.error('Error initializing Tabulator table:', error);
  }
}


function clearFormFields(formSelector) {
  const form = document.querySelector(formSelector);
  if (form) {
    form.querySelectorAll('input, textarea, select').forEach(field => {
      field.value = '';  // Clear the field value
      field.placeholder = field.getAttribute('data-placeholder') || field.placeholder;  // Reset the placeholder text
    });
  }
}

function populateFormFields(ceId, aiData) {
  const form = document.querySelector(`#ceForm-${ceId}`);
  if (form) {
    Object.keys(aiData).forEach(fieldName => {
      const input = form.querySelector(`[name="${fieldName}"]`);
      if (input) {
        input.value = aiData[fieldName];
      }
    });
  }
}

function generateFieldsFromAI(ceId, ceType, existingCEs) {
  const form = document.querySelector(`#ceForm-${ceId}`);
  const cosContent = document.querySelector('.cos-content-cell').textContent.trim();
  const ssolGoal = document.querySelector('#ssol-goal').textContent.trim();

  const requestData = {
    ce_id: ceId,
    ce_type: ceType,
    cos_content: cosContent,
    ssol_goal: ssolGoal,
    existing_ces: existingCEs  // Include existing CEs
  };

  console.log("Sending AI query request data:", requestData); // Add logging

  showLoadingSpinner(`Generating ${ceType}...`);
  fetch('/ai-query-endpoint', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestData)
  })
    .then(response => {
      console.log("AI query response status:", response.status); // Add logging
      return response.json();
    })
    .then(data => {
      hideLoadingSpinner();
      console.log("AI query response data:", data); // Add logging
      if (data && data.ai_response) {
        populateFormFields(ceId, data.ai_response.fields);
      } else {
        throw new Error('AI response not found or error in response');
      }
    })
    .catch(error => {
      hideLoadingSpinner();
      console.error('Error generating fields from AI:', error);
    });
}

function extractCosContentForEditing(cosContentCell) {
  const badgeElements = cosContentCell.querySelectorAll('.badge, .position-absolute');
  badgeElements.forEach((badge) => {
    const ceContent = badge.previousSibling.textContent;
    badge.previousSibling.textContent = ceContent;  // Restore original text without badge
    badge.remove();  // Remove the badge element
  });
  return cosContentCell.innerHTML;  // This now contains the editable content with original CE text
}

function setupModalEventListeners(modalElement, ceId, ceType, cosContent, phaseName, phaseIndex, ssolGoal) {
  // Define buttons and elements within the modal
  const addRowButton = modalElement.querySelector(`#addRowButton-${ceId}`);
  const generateRowButton = modalElement.querySelector(`#generateRowButton-${ceId}`);
  const saveChangesButton = modalElement.querySelector('.btn-save-changes');
  const deleteSelectedRowsButton = modalElement.querySelector(`#deleteSelectedRowsButton-${ceId}`);
  const duplicateSelectedRowsButton = modalElement.querySelector(`#duplicateSelectedRowsButton-${ceId}`);

  // Handle changes in the modal
  modalElement.addEventListener('change', () => {
      hasUnsavedChanges = true;
  });

  // Handle modal close event
  modalElement.addEventListener('hidden.bs.modal', function () {
      if (hasUnsavedChanges) {
          // Handle unsaved changes, e.g., prompt user
          if (confirm('You have unsaved changes. Do you really want to close?')) {
              hasUnsavedChanges = false; // Reset after handling
          } else {
              const modal = new bootstrap.Modal(modalElement);
              modal.show(); // Reopen the modal
          }
      }
  });

  // Add event listener to Add Row button
  if (addRowButton) {
      addRowButton.addEventListener('click', () => {
          const table = modalElement._tabulator;
          const form = modalElement.querySelector(`#ceForm-${ceId}`);
          const formData = new FormData(form);
          const rowData = {};
          let isAnyFieldFilled = false;

          formData.forEach((value, key) => {
              if (value.trim()) {
                  isAnyFieldFilled = true;
              }
              rowData[key] = value || '';
          });

          if (!isAnyFieldFilled) {
              alert('Please fill in at least one field before adding a row.');
              return;
          }

          const rows = table.getRows();
          let emptyRow = rows.find(row => Object.values(row.getData()).every(val => val === ''));

          if (emptyRow) {
              emptyRow.update(rowData);
          } else {
              table.addRow(rowData, true);
          }

          clearFormFields(`#ceForm-${ceId}`);
          hasUnsavedChanges = true;
      });
  }

  if (saveChangesButton) {
    saveChangesButton.addEventListener('click', () => {
      saveCEChanges(ceId);
      hasUnsavedChanges = false;
    });
  }

  if (deleteSelectedRowsButton) {
    deleteSelectedRowsButton.addEventListener('click', () => {
      const table = modalElement._tabulator;
      const selectedRows = table.getSelectedRows();
      selectedRows.forEach(row => row.delete());
      hasUnsavedChanges = true;
    });
  }

  if (duplicateSelectedRowsButton) {
    duplicateSelectedRowsButton.addEventListener('click', () => {
      const table = modalElement._tabulator;
      const selectedRows = table.getSelectedRows();
      selectedRows.forEach(row => {
        const rowData = row.getData();
        table.addRow(rowData, true);
      });
      hasUnsavedChanges = true;
    });
  }

  modalElement.addEventListener('hidden.bs.modal', function () {
    if (hasUnsavedChanges && !confirm('You have unsaved changes. Do you really want to close?')) {
      const modal = new bootstrap.Modal(modalElement);
      modal.show();
    } else {
      setupEventListeners(); // Reattach event listeners when modal is closed
    }
  });
}

function saveCEChanges(ceId) {
  const modalElement = document.querySelector(`#ceModal-${ceId}`);
  const table = modalElement._tabulator;
  const tableData = table ? table.getData() : [];

  // Filter out rows with all null or empty values
  const nonNullRows = tableData.filter(row =>
    Object.values(row).some(value => value !== null &&
      (typeof value === 'string' ? value.trim() !== '' : value !== ''))
  );

  const updatedData = {
    table_data: nonNullRows,
    form_data: getFormData(modalElement.querySelector(`#ceForm-${ceId}`))
  };

  fetch(`/update_ce/${encodeURIComponent(ceId)}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updatedData)
  })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        console.log(`CE ID ${ceId} updated successfully`);
        bootstrap.Modal.getInstance(modalElement).hide();
        updateCEPills(ceId, nonNullRows.length); // Update all CE pills with the same ID
        setupEventListeners(); // Reattach event listeners to CE pills
      } else {
        throw new Error(data.error || 'An error occurred while updating the CE.');
      }
    })
    .catch(error => {
      console.error('Error updating CE:', error);
      alert('An error occurred while updating the CE. Please try again.');
    });
}


function getFormData(form) {
  const formData = new FormData(form);
  const data = {};
  formData.forEach((value, key) => {
    data[key] = value || '';  // Ensure value is not null
  });
  return data;
}

function updateCEPills(ceId, resourceCount) {
  const cePills = document.querySelectorAll(`.ce-pill[data-ce-id="${ceId}"]`);
  cePills.forEach(cePill => {
    const ceText = cePill.textContent.replace(/\(\d+\)$/, '').trim();
    cePill.innerHTML = ''; // Clear existing content

    // Add the CE text
    const textNode = document.createTextNode(ceText);
    cePill.appendChild(textNode);

    if (resourceCount > 0) {
      const tally = document.createElement('span');
      tally.className = 'badge rounded-pill bg-light text-dark ms-2 counter';
      tally.textContent = resourceCount.toString();
      cePill.appendChild(tally);
    }

    // Add the green dot for new CEs
    const ceData = ce_store[ceId];
    if (ceData && ceData.is_new) {
      const greenDot = document.createElement('span');
      greenDot.className = 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle';
      const visuallyHiddenText = document.createElement('span');
      visuallyHiddenText.className = 'visually-hidden';
      visuallyHiddenText.textContent = 'New CE';
      greenDot.appendChild(visuallyHiddenText);
      cePill.appendChild(greenDot);
    }

    // Reattach click event listener
    cePill.addEventListener('click', (event) => handleCEPillClick(event));
  });
}

// Ensure this function is called after any changes to CE data
function refreshAllCEPills() {
  Object.entries(ce_store).forEach(([ceId, ceData]) => {
    const nonBlankRows = ceData.table_data ? ceData.table_data.filter(row => Object.values(row).some(value => value !== null && value.trim() !== '')) : [];
    updateCEPills(ceId, nonBlankRows.length);
  });
}

// Call this function after initializing the page and after any bulk updates to CE data
document.addEventListener('DOMContentLoaded', function () {
  setupEventListeners();
  refreshAllCEPills();
});



üìÜ models.py:
import os
import uuid
from dotenv import load_dotenv
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, Date
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker, relationship

load_dotenv()

db = SQLAlchemy()
Base = declarative_base()
_engine = create_engine(os.environ.get('SQLALCHEMY_DATABASE_URI'), echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
session = scoped_session(SessionLocal)

class SSOL(db.Model):
    __tablename__ = 'ssol'
    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    cos = relationship('COS', back_populates='ssol')

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'cos': [cos.to_dict() for cos in self.cos]
        }

class COS(db.Model):
    __tablename__ = 'cos'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(String, nullable=False)
    status = Column(String(50), nullable=False)
    accountable_party = Column(String(255), nullable=True)
    completion_date = Column(Date, nullable=True)
    ssol_id = Column(Integer, ForeignKey('ssol.id'), nullable=False)
    ssol = relationship('SSOL', back_populates='cos')
    conditional_elements = relationship('CE', back_populates='cos')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'status': self.status,
            'accountable_party': self.accountable_party,
            'completion_date': self.completion_date.isoformat() if self.completion_date else None,
            'ssol_id': self.ssol_id,
            'conditional_elements': [ce.to_dict() for ce in self.conditional_elements]
        }

class CE(db.Model):
    __tablename__ = 'ce'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(String, nullable=False)
    node_type = Column(String(50), nullable=True)
    details = Column(Text, nullable=True)
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), nullable=False)  # Add this line
    cos = relationship('COS', back_populates='conditional_elements')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'node_type': self.node_type,
            'details': self.details,
            'cos_id': str(self.cos_id)  # Include the cos_id in the dictionary
        }

class COS_CE_Link(db.Model):
    __tablename__ = 'cos_ce_link'
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), primary_key=True)
    ce_id = Column(UUID(as_uuid=True), ForeignKey('ce.id'), primary_key=True)

Base.metadata.create_all(_engine)



üì± app.py:
# app.py
import os
import logging
from flask import Flask
from flask_migrate import Migrate
from dotenv import load_dotenv
from models import db  # Import the db object from models.py

# Load environment variables
load_dotenv()

# Flag to toggle database usage
USE_DATABASE = os.environ.get('USE_DATABASE', 'False').lower() in ['true', '1', 't']

# Initialize Flask app
app = Flask(__name__)

# Set the secret key from the environment variables
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')

if USE_DATABASE:
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('SQLALCHEMY_DATABASE_URI')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['SQLALCHEMY_ECHO'] = True

    # Initialize SQLAlchemy
    db.init_app(app)

    # Initialize Flask-Migrate
    migrate = Migrate(app, db)

# Import the functions from speculate after db has been initialized to avoid circular imports
from speculate import get_badge_class_from_status

# Register the custom Jinja filter function
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

# Import the routes and register the Blueprint at the end of the file
from routes import routes_bp

print("Registering blueprint: routes_bp with name 'routes_blueprint'") # Modified print statement
# Explicitly name the blueprint during registration - refactored line
app.register_blueprint(routes_bp, name='routes_blueprint')

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)  # Set the logging level to DEBUG
    logging.info("Checking initial data store contents...")
    from speculate import check_data_store_contents
    check_data_store_contents('database' if USE_DATABASE else 'in_memory')
    app.run(debug=True)


üè™ store.py:
# store.py
ssol_store = {}
cos_store = {}
ce_store = {}


üß© ce_templates.py:
# ce_templates.py

import json
import logging
import uuid
from uuid import UUID
from store import ce_store
from bs4 import BeautifulSoup
from flask import render_template_string, current_app
from ce_nodes import NODES, get_valid_node_types
from ai_service import generate_chat_response

BASE_MODAL_TEMPLATE = """
<div class="modal fade" id="ceModal-${ceId}" tabindex="-1" aria-labelledby="ceModalLabel-${ceId}" aria-hidden="true">
  <div class="modal-dialog modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header" style="background-color: ${phaseColor};">
        <div class="filled-box"></div>
        <h5 class="modal-title" id="ceModalLabel-${ceId}">
          <span class="node-icon me-2" style="color: ${phaseColor};">
            <i class="${NODES[ceType]?.icon || 'fa-solid fa-icons'}"></i>
          </span>
          <span class="modal-header-title">${ceType.replace('_', ' ').toUpperCase()} // ${phaseName.toUpperCase()}</span>
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p><span class="context-label">Source COS:</span><span class="context-text">${cos_content_with_pills}</span></p>
        <p><span class="context-label">${ceType}:</span><span class="context-text">${ai_generated_data.contextual_description || 'No contextual description available.'}</span></p>
        <div id="dynamicTable-${ceId}" class="tabulator-table mb-3"></div>

        <div class="row justify-content-start mb-3">
          <div class="col-auto">
            <button type="button" class="btn btn-sm btn-danger" id="deleteSelectedRowsButton-${ceId}">Delete</button>
            <button type="button" class="btn btn-sm btn-secondary" id="duplicateSelectedRowsButton-${ceId}">Duplicate</button>
          </div>
        </div>

        <form id="ceForm-${ceId}">
          ${generate_form_fields(fields_config, ai_generated_data.fields)}
        </form>
        <div class="row mt-2">
          <div class="col">
            <button type="button" class="btn btn-success w-100" id="addRowButton-${ceId}" style="padding-top: 10px;">Add ${ceType}</button>
          </div>
          <div class="col">
            <button type="button" class="btn btn-primary w-100" id="generateRowButton-${ceId}" style="padding-top: 10px;">Generate ${ceType}</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="${ceId}">Save changes</button>
      </div>
    </div>
  </div>
</div>
"""

DEFAULT_FIELDS_CONFIG = [
    {"type": "text", "name": "subject", "placeholder": "Subject"},
    {"type": "textarea", "name": "details", "placeholder": "Details"},
    {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}
]

DEFAULT_TABULATOR_CONFIG = {
    "columns": [
        {"title": "Subject", "field": "subject", "editor": "input"},
        {"title": "Details", "field": "details", "editor": "input"},
        {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}
    ]
}

def generate_form_field(field_type, field_name, field_value='', placeholder='', options=None):
    current_app.logger.debug(f"Generating form field: type={field_type}, name={field_name}, value={field_value}, placeholder={placeholder}")
    field_templates = {
        'text': '<div class="form-group"><label for="{name}">{label}</label><input type="text" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'number': '<div class="form-group"><label for="{name}">{label}</label><input type="number" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'textarea': '<div class="form-group"><label for="{name}">{label}</label><textarea class="form-control" id="{name}" name="{name}" placeholder="{placeholder}" data-placeholder="{placeholder}" rows="4">{value}</textarea></div>',
        'email': '<div class="form-group"><label for="{name}">{label}</label><input type="email" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'password': '<div class="form-group"><label for="{name}">{label}</label><input type="password" class="form-control" id="{name}" name="{name}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'date': '<div class="form-group"><label for="{name}">{label}</label><input type="date" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'time': '<div class="form-group"><label for="{name}">{label}</label><input type="time" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'datetime-local': '<div class="form-group"><label for="{name}">{label}</label><input type="datetime-local" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'color': '<div class="form-group"><label for="{name}">{label}</label><input type="color" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'checkbox': '<div class="form-check"><input type="checkbox" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',
        'radio': '<div class="form-check"><input type="radio" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',
        'select': '<div class="form-group"><label for="{name}">{label}</label><select class="form-control" id="{name}" name="{name}">{options}</select></div>',
    }

    checked = 'checked' if field_value and field_type in ['checkbox', 'radio'] else ''
    label = field_name.replace('_', ' ').title()  # Generate a label from the field name

    if field_type in ['radio', 'select']:
        options_html = ''.join(f'<option value="{opt_value}" {"selected" if field_value and opt_value == field_value else ""}>{opt_label}</option>' for opt_value, opt_label in (options or {}).items())
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, options=options_html)
    else:
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, checked=checked)

def generate_form_fields(fields_config, ai_generated_data=None):
    if not fields_config:
        current_app.logger.error("No fields_config provided to generate form fields.")
        return "No form fields available."
    current_app.logger.debug(f"Generating form fields with config: {fields_config}")
    form_fields_html = ""
    for field in fields_config:
        current_app.logger.debug(f"Generating field: {field}")
        # Check if AI-generated data exists for the field
        field_value = ai_generated_data.get(field['name'], '') if ai_generated_data else ''
        field_html = generate_form_field(
            field_type=field['type'],
            field_name=field['name'],
            field_value=field_value,
            placeholder=field.get('placeholder', ''),
            options=field.get('options', None)
        )
        form_fields_html += field_html
    return form_fields_html


def generate_table_headers(fields_config):
    table_headers_html = ""
    for field in fields_config:
        header_label = field['name'].replace('_', ' ').title()
        table_headers_html += f"<th><strong>{header_label}</strong></th>"
    return table_headers_html

def generate_dynamic_modal(ce_type, ce_data=None, cos_content=None, ai_generated_data=None, phase_name=None, phase_index=None, ce_store=None):
    current_app.logger.debug(f"Generating modal for CE type: {ce_type}")
    current_app.logger.debug(f"CE data: {ce_data}")
    current_app.logger.debug(f"COS content: {cos_content}")
    current_app.logger.debug(f"AI generated data: {ai_generated_data}")
    current_app.logger.debug(f"Phase name: {phase_name}")
    current_app.logger.debug(f"Phase index: {phase_index}")

    node_info = NODES.get(ce_type, NODES['Default'])
    fields_config = node_info['modal_config']['fields']
    tabulator_config = node_info['tabulator_config']

    saved_form_data = ce_data.get('form_data', {}) if ce_data else {}
    form_fields = generate_form_fields(fields_config, saved_form_data or ai_generated_data.get('fields', {}))
    table_headers = generate_table_headers(fields_config)
    table_data = ce_data.get('table_data', []) if ce_data else []

    node_name = ce_type.replace('_', ' ').title()
    ai_context_description = ai_generated_data.get('contextual_description', 'No contextual description provided.')

    # Process the COS content to replace CE tags with CE pills
    ces = list(ce_store.values())  # Ensure that ce_store contains the correct structure
    for ce in ces:
        if 'ce_type' not in ce:
            ce['ce_type'] = 'Unknown'
            current_app.logger.warning(f"Added missing 'ce_type' to CE: {ce}")

    cos_content_with_pills = replace_ce_tags_with_pills(cos_content, ces)

    modal_content = render_template_string(
        BASE_MODAL_TEMPLATE,
        ce_type=ce_type,
        icon_class = NODES[ce_type].get('icon') if ce_type in NODES else get_node_type_icon_and_name(ce_type),
        node_info=node_info,
        form_fields=form_fields,
        table_headers=table_headers,
        table_data=table_data,
        tabulator_columns=[
            { 'formatter': 'rowSelection', 'titleFormatter': 'rowSelection', 'hozAlign': 'center', 'headerSort': False, 'cellClick': lambda e, cell: cell.getRow().toggleSelect() },
            *tabulator_config['columns'],
        ],
        ce_data=ce_data or {'id': 'unknown_ce_id'},
        cos_content_with_pills=cos_content_with_pills,  # Use processed COS content with CE pills
        ai_generated_data=ai_generated_data,
        phase_name=phase_name,
        phase_index=phase_index,
        node_name=node_name,
        ce_id=ce_data.get('id', 'unknown_ce_id') if ce_data else 'unknown_ce_id',
        ai_context_description=ai_generated_data.get('contextual_description', 'No contextual description provided.')
    )

    return modal_content

def get_node_type_icon_and_name(node_type):
    messages = [
        {"role": "system", "content": "You are an AI that suggests a FontAwesome 6 Solid (fas) class icon based on the node type. Output only the icon class in JSON format."},
        {"role": "user", "content": f"What is the best FontAwesome icon class for the node type '{node_type}'?"}
    ]
    response_content = generate_chat_response(messages, role='Node Type Icon', task='Fetch Node Type FontAwesome Icon', temperature=0.37)

    try:
        response_data = json.loads(response_content)
        icon_class = response_data.get("iconClass")
        if not icon_class:
            logging.error(f"Failed to retrieve icon class for node type '{node_type}'.")
            raise ValueError("Icon class not provided by AI.")
        return icon_class

    except json.JSONDecodeError as e:
        logging.error(f"JSON decoding error: {e}")
        raise
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        raise



def assign_ce_type(ce):
    if 'ce_type' not in ce or not ce['ce_type']:
        # Assign a default CE type if none is provided
        ce['ce_type'] = 'General'
        logging.info(f"Assigned default 'ce_type' to CE: {ce}")
    return ce

def extract_full_cos_text(cos_content):
    soup = BeautifulSoup(cos_content, 'html.parser')
    return ' '.join(soup.stripped_strings)

def generate_fa_icon_for_node_type(node_type):
    messages = [
        {"role": "system", "content": "You are an AI that suggests a FontAwesome 6 Solid (fas) class icon based on the node type name. Output only the icon class in JSON format."},
        {"role": "user", "content": f"What is the best FontAwesome icon class for the node type '{node_type}'?"}
    ]
    response_content = generate_chat_response(messages, role='Icon Generation', task='Fetch FontAwesome 6 Icon', temperature=0.37)

    try:
        # Log the raw response content for debugging
        current_app.logger.debug(f"Raw response content: {response_content}")

        # Parse the JSON string into a dictionary
        response_data = json.loads(response_content)
        # Make sure to match the keys exactly with the response content
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"

        if not icon_class:
            # Log a warning if expected keys are missing
            current_app.logger.warning("Missing 'iconClass' in AI response.")
            raise ValueError("Failed to generate icon. Please try again.")

        return icon_class

    except json.JSONDecodeError as e:
        # Log the JSON parsing error
        current_app.logger.error(f"JSON parsing error: {e}")
        raise ValueError("Failed to parse JSON response. Please try again.")

    except Exception as e:
        # Log any other exceptions
        current_app.logger.error(f"Unexpected error: {e}")
        raise

def replace_ce_tags_with_pills(content, ces):
    def assign_ce_type(ce):
        if 'ce_type' not in ce or not ce['ce_type']:
            # Assign a default CE type if none is provided
            ce['ce_type'] = 'General'
            logging.info(f"Assigned default 'ce_type' to CE: {ce}")
        return ce

    soup = BeautifulSoup(content, 'html.parser')

    for ce in ces:
        # Ensure each CE has a valid type
        ce = assign_ce_type(ce)

        ce_uuid = str(uuid.uuid4())
        new_tag = soup.new_tag('span', attrs={
            'class': 'badge rounded-pill bg-secondary ce-pill position-relative',
            'data-ce-id': ce_uuid,
            'data-ce-type': ce['ce_type']
        })
        new_tag.string = ce['content']

        # Add counter if applicable
        if ce.get('count', 0) > 0:
            counter_tag = soup.new_tag('span', attrs={
                'class': 'badge rounded-pill bg-light text-dark ms-2'
            })
            counter_tag.string = str(ce['count'])
            new_tag.append(counter_tag)

        # Add indicator for new CEs
        if ce.get('is_new'):
            green_dot = soup.new_tag('span', attrs={
                'class': 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle'
            })
            visually_hidden_text = soup.new_tag('span', attrs={'class': 'visually-hidden'})
            visually_hidden_text.string = 'New CE'
            green_dot.append(visually_hidden_text)
            new_tag.append(green_dot)

        soup.append(new_tag)

    return str(soup)

def get_ce_modal(ce_type):
    modal_html = generate_dynamic_modal(ce_type)
    return modal_html

def generate_ai_data(cos_text, ce_id, ce_type, ssol_goal, existing_ces=None):
    if existing_ces is None:
        existing_ces = []  # Default to an empty list if no existing CEs are provided

    node_info = NODES.get(ce_type, NODES['Default'])
    ai_context = node_info.get('modal_config', {}).get('ai_context', '')
    modal_config_fields = node_info.get('modal_config', {}).get('fields', [])

    if not ai_context:
        current_app.logger.debug(f"No AI context provided for CE type: {ce_type}")
        return {"summary": "No AI context provided.", "fields": {}}

    valid_node_types = ', '.join(get_valid_node_types())
    field_labels = [field['name'] for field in modal_config_fields]

    messages = [
        {
            "role": "system",
            "content": (
                "You are a helpful assistant. Generate contextually relevant data based on the Structured Solution (SSOL) goal, "
                "the parent Condition of Satisfaction (COS) text, and the specific Conditional Element Identifier (CE ID) and type provided. Use this information to generate "
                "detailed and specific insights or data that can fulfill on satisfying the COS and ultimately achieving the SSOL goal. "
                "Choose the most appropriate conditional element type from within the following list: {valid_node_types}."
            ).format(valid_node_types=valid_node_types)
        },
        {
            "role": "user",
            "content": (
                f"SSOL Goal: {ssol_goal}\n"
                f"COS Text: {cos_text}\n"
                f"CE ID: {ce_id}\n"
                f"CE Type: {ce_type}\n"
                f"Context: {ai_context}\n"
                f"Form Field Labels: {', '.join(field_labels)}\n"
                f"Existing Conditional Elements: {json.dumps(existing_ces)}\n"  # Include existing CEs
                f"Based on the SSOL goal and the context provided by the parent COS and other conditional elements, "
                f"generate a JSON response with the following structure:\n"
                f"{{\n"
                f"  \"summary\": \"Summary of the Conditional Element\",\n"
                f"  \"contextual_description\": \"Contextual description of the CE\",\n"
                f"  \"fields\": {{\n"
                f"    \"field_label_1\": \"Unique value for field_label_1\",\n"
                f"    \"field_label_2\": \"Unique value for field_label_2\",\n"
                f"    ...\n"
                f"  }}\n"
                f"}}\n"
                f"Ensure that the generated fields are unique and provide new information that complements the existing conditional elements."
            )
        }
    ]

    try:
        response = generate_chat_response(messages, role='AI Contextual Query', task=f'Generate Data for {ce_type}')
        current_app.logger.debug(f"AI Response: {response}")
        ai_data = json.loads(response)
        current_app.logger.debug(f"Parsed AI Data: {ai_data}")
        return ai_data
    except Exception as e:
        current_app.logger.error(f"Error generating AI data: {e}")
        return {"summary": "Error generating AI data.", "contextual_description": "Error generating context.", "fields": {}}



