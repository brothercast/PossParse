‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SSPEC PossPath Essential Files ‚ïë
‚ïë Date: 2024-05-30               ‚ïë
‚ïë Version: 0003                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
üåêStructured Speculation Possibility Pathfinder or "SSPEC PossPath" for short. Your task to develop the Flask Web App as an innovative tool for mass collaboration across divides. Essential app files:
üü• routes.py:
import os
import json
import uuid
import pdfkit
import openai
import requests
import logging
from bs4 import BeautifulSoup
from ce_nodes import NODES
from app import app, USE_DATABASE
from uuid import uuid4
from ce_templates import generate_dynamic_modal, generate_ai_data
from models import SSOL, COS, CE
from store import ce_store, cos_store, ssol_store
from flask import Blueprint, render_template, render_template_string, request, flash, redirect, url_for, jsonify, make_response, current_app, send_from_directory
from werkzeug.exceptions import BadRequest, NotFound
from utilities import generate_goal, get_domain_icon_and_name, generate_outcome_data
from speculate import get_badge_class_from_status, delete_cos_by_id, update_ce_by_id, update_cos_by_id, get_ce_by_id, analyze_cos, get_cos_by_id, get_phase_index
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
azure_openai_key = os.environ["AZURE_OPENAI_API_KEY"]
azure_openai_endpoint = os.environ["AZURE_OPENAI_ENDPOINT"]
deployment_name = os.environ["AZURE_DEPLOYMENT_NAME"]

# Initialize Azure OpenAI client
openai.api_key = azure_openai_key
openai.api_base = azure_openai_endpoint
openai.api_type = 'azure'
openai.api_version = '2023-12-01'

# Set the secret key and database URI from the environment variables
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('SQLALCHEMY_DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Configure logging
logging.basicConfig(level=logging.WARNING)

# Register the custom Jinja filter function
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

# Create the blueprint
routes_bp = Blueprint('routes_bp', __name__)

@routes_bp.route('/favicon.ico')
def favicon():
    return send_from_directory(os.path.join(current_app.root_path, 'static'),
                               'favicon.ico', mimetype='image/vnd.microsoft.icon')

@routes_bp.route('/')
def index():
    return render_template('input.html')

@routes_bp.route('/about')
def about():
    return render_template('about.html')

@routes_bp.route('/goal_selection', methods=['GET', 'POST'])
def goal_selection():
    if request.method == 'POST':
        user_input = request.form['user_text'].strip()
        try:
            goal_options = generate_goal(user_input)
            for goal in goal_options:
                goal['icon'], goal['domain'] = get_domain_icon_and_name(goal['title'])

            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify(goals=goal_options, user_input=user_input)

            return render_template('goal_selection.html', goals=goal_options, user_input=user_input)
        except ValueError as e:
            flash("An error occurred while processing your request. Please try again.", "error")
    return redirect(url_for('routes_bp.index'))

@routes_bp.route('/outcome', methods=['GET', 'POST'])
def outcome():
    if request.method == 'POST':
        logging.info(f"Form data received: {request.form}")
        selected_goal = request.form.get('selected_goal', '').strip()
        domain = request.form.get('domain', '').strip()
        domain_icon = request.form.get('domain_icon', '').strip()

        try:
            outcome_data = generate_outcome_data(request, 'POST', selected_goal, domain, domain_icon)
            logging.info(f"Type of outcome_data: {type(outcome_data)}")
            logging.info(f"Content of outcome_data: {outcome_data}")
            return render_template('outcome.html', ssol=outcome_data, ssol_id=outcome_data['ssol_id'], nodes=NODES)
        except Exception as e:
            app.logger.error(f"An error occurred while generating the outcome data: {e}")
            flash("An error occurred while generating the outcome data. Please try again.", "error")
            return redirect(url_for('routes_bp.index'))

    flash("Invalid request method.", "error")
    return redirect(url_for('routes_bp.index'))

@routes_bp.route('/save_as_pdf/<uuid:ssol_id>', methods=['POST'])
def save_as_pdf(ssol_id):
    try:
        data = request.get_json()
        html_content = data['htmlContent']
        if not html_content:
            raise ValueError("No HTML content provided.")

        css_file_path = os.path.join(current_app.root_path, current_app.static_folder, 'styles.css')
        html_content = html_content.replace('src="/static/', f'src="{url_for("static", filename="", _external=True)}')

        options = {
            "page-size": "Letter",
            "margin-top": "0.75in",
            "margin-right": "0.75in",
            "margin-bottom": "0.75in",
            "margin-left": "0.75in",
            "encoding": "UTF-8",
            "custom-header": [("Accept-Encoding", "gzip")],
            "no-outline": None,
            "enable-local-file-access": None,
        }

        pdf = pdfkit.from_string(html_content, False, options=options, css=css_file_path)

        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename="Structured Solution {ssol_id}.pdf"'

        return response
    except Exception as e:
        current_app.logger.error(f"Exception in save_as_pdf: {e}")
        return jsonify(success=False, error=str(e)), 500

@routes_bp.route('/update_cos/<uuid:cos_id>', methods=['PUT'])
def update_cos_route(cos_id):
    try:
        data = request.get_json()
        if not data:
            raise BadRequest('No JSON payload received')

        cos_id_str = str(cos_id)
        update_result = update_cos_by_id(cos_id_str, data)

        if update_result['success']:
            return jsonify(success=True, cos=update_result['cos']), 200
        else:
            return jsonify(success=False, error=update_result['message']), 404
    except BadRequest as e:
        return jsonify(error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Error updating COS with ID {cos_id}: {e}", exc_info=True)
        return jsonify(error="An unexpected error occurred while updating the COS."), 500

@routes_bp.route('/delete_cos/<uuid:cos_id>', methods=['DELETE'])
def delete_cos_route(cos_id):
    try:
        cos_id_str = str(cos_id)

        if delete_cos_by_id(cos_id_str):
            flash('COS has been successfully deleted.', 'success')
            return jsonify(success=True), 200
        else:
            raise NotFound('Condition of Satisfaction could not be found or deleted.')
    except NotFound as e:
        logging.warning(f"NotFound: {e}")
        return jsonify(success=False, error=str(e)), 404
    except Exception as e:
        logging.error(f"Unexpected error occurred: {e}", exc_info=True)
        return jsonify(success=False, error=str(e)), 500

@routes_bp.route('/get_ce_by_id/<string:ce_id>', methods=['GET'])
def get_ce_by_id_route(ce_id):
    try:
        ce = get_ce_by_id(ce_id)
        if ce:
            cos_id = ce.get('cos_id') if isinstance(ce, dict) else ce.cos_id
            cos_content = "Parent COS not found."
            phase_index = 0  # Default phase index
            if cos_id:
                cos = get_cos_by_id(cos_id)
                cos_content = cos['content'] if cos else cos_content
                # Determine the phase index based on the COS
                phase_index = get_phase_index(cos)  # Implement this function to return the correct phase index

            ce_data = ce.to_dict() if not isinstance(ce, dict) else ce
            ce_data['phase_index'] = phase_index  # Include the phase index
            return jsonify(ce=ce_data, cos_content=cos_content), 200
        else:
            return jsonify(error=f"CE with ID {ce_id} not found"), 404
    except Exception as e:
        current_app.logger.error(f"Error in get_ce_by_id_route: {e}", exc_info=True)
        return jsonify(error="Internal Server Error"), 500

@routes_bp.route('/analyze_cos/<string:cos_id>', methods=['GET'])
def analyze_cos_route(cos_id):
    logging.info(f"Analyzing COS with ID: {cos_id}")
    try:
        analysis_result = analyze_cos_by_id(cos_id)
        if analysis_result['success']:
            return jsonify(analysis_result['analysis_results']), 200
        else:
            return jsonify({'error': analysis_result['message']}), 404
    except ValueError:
        return jsonify({'error': "Invalid COS ID"}), 400
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def analyze_cos_by_id(cos_id_str):
    try:
        cos = COS.query.get(cos_id_str) if USE_DATABASE else cos_store.get(cos_id_str)
        if not cos:
            return {'success': False, 'message': "COS not found."}

        analysis_results = analyze_cos(cos.content if USE_DATABASE else cos['content'])
        return {'success': True, 'analysis_results': analysis_results}
    except Exception as e:
        return {'success': False, 'message': f"An unexpected error occurred: {str(e)}"}

@routes_bp.route('/update_ce/<uuid:ce_id>', methods=['POST'])
def update_ce(ce_id):
    ce_data = request.get_json()
    try:
        success = update_ce_by_id(ce_id, ce_data)
        if success:
            return jsonify(success=True), 200
        else:
            return jsonify(success=False, error="Conditional Element not found."), 404
    except Exception as e:
        return jsonify(success=False, error=str(e)), 500

@routes_bp.route('/ai-query-endpoint', methods=['POST'])
def ai_query_endpoint():
    try:
        data = request.get_json()
        if not data:
            raise BadRequest('No JSON payload received.')

        cos_text = data.get('cos_text')
        ce_id = data.get('ce_id')
        ce_type = data.get('ce_type')
        ssol_goal = data.get('ssol_goal')

        if not all([cos_text, ce_id, ce_type, ssol_goal]):
            raise BadRequest('Missing required fields in JSON payload.')

        ai_response = generate_ai_data()(cos_text, ce_id, ce_type, ssol_goal)
        return jsonify(ai_response=ai_response), 200
    except BadRequest as e:
        return jsonify(success=False, error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Exception in AI query endpoint: {e}")
        return jsonify(success=False, error=str(e)), 500

# Function to fetch actual CE data
def fetch_ce_data(ce_type):
    try:
        if USE_DATABASE:
            ce_data = CE.query.filter_by(node_type=ce_type).first()
            if ce_data:
                current_app.logger.debug(f"Fetched CE data from database for type '{ce_type}': {ce_data}")
            else:
                current_app.logger.warning(f"CE data for type '{ce_type}' not found in the database.")
        else:
            ce_data = next((ce for ce in ce_store.values() if ce.get('node_type') == ce_type), None)
            if ce_data:
                current_app.logger.debug(f"Fetched CE data from in-memory store for type '{ce_type}': {ce_data}")
            else:
                current_app.logger.warning(f"CE data for type '{ce_type}' not found in the in-memory store.")

        if not ce_data:
            current_app.logger.warning(f"CE data for type '{ce_type}' not found. Falling back to Default node type.")
            ce_data = NODES.get('Default')
            ce_data = {
                'id': 'default_id',
                'content': '',
                'node_type': 'Default',
                'details': ''
            }

        return ce_data
    except Exception as e:
        current_app.logger.error(f"Error fetching CE data for type '{ce_type}': {e}", exc_info=True)
        return None



# Debug routes for logging CE entries
@routes_bp.route('/debug/log_ce_entries', methods=['GET'])
def debug_log_ce_entries():
    log_ce_entries()
    return jsonify({"message": "Logged CE entries"}), 200

@routes_bp.route('/debug/log_in_memory_ce_entries', methods=['GET'])
def debug_log_in_memory_ce_entries():
    try:
        from store import ce_store
        for ce_id, ce in ce_store.items():
            current_app.logger.debug(f"CE ID: {ce_id}, Type: {ce.get('node_type')}, Content: {ce.get('content')}")
        return jsonify({"message": "Logged in-memory CE entries"}), 200
    except Exception as e:
        current_app.logger.error(f"Error logging in-memory CE entries: {e}", exc_info=True)
        return jsonify({"message": "Error logging in-memory CE entries", "error": str(e)}), 500

# Other utility functions
def log_ce_entries():
    ce_entries = CE.query.all()
    for ce in ce_entries:
        current_app.logger.debug(f"CE ID: {ce.id}, Type: {ce.node_type}, Content: {ce.content}")

def log_in_memory_ce_entries():
    for ce_id, ce in ce_store.items():
        current_app.logger.debug(f"CE ID: {ce_id}, Type: {ce.get('node_type')}, Content: {ce.get('content')}")



üü® utilities.py:
import io
import os
import re
import html
import json
import time
import uuid
import logging
from uuid import uuid4
import warnings
from PIL import Image
from bs4 import BeautifulSoup
from dotenv import load_dotenv
from openai import AzureOpenAI
from app import USE_DATABASE, db
from models import COS, CE, SSOL, COS_CE_Link
from store import ssol_store, cos_store, ce_store
from stability_sdk import client as stability_client
from flask import current_app, flash, render_template
import stability_sdk.interfaces.gooseai.generation.generation_pb2 as generation

# Load environment variables
load_dotenv()
azure_oai_key = os.getenv("AZURE_OPENAI_API_KEY")
azure_oai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
azure_oai_deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")
azure_oai_model = os.getenv("AZURE_MODEL_NAME")
stability_api_key = os.getenv("STABILITY_KEY")

# Initialize the AzureOpenAI client as a global variable
azure_openai_client = AzureOpenAI(
    azure_endpoint=azure_oai_endpoint,
    api_key=azure_oai_key,
    api_version="2024-03-01-preview"
)

class Logger:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    @staticmethod
    def log_message(message, level='info'):
        if level == 'info':
            formatted_message = f"{Logger.OKCYAN}{message}{Logger.ENDC}"
        elif level == 'warning':
            formatted_message = f"{Logger.WARNING}{message}{Logger.ENDC}"
        elif level == 'error':
            formatted_message = f"{Logger.FAIL}{message}{Logger.ENDC}"
        elif level == 'debug':
            formatted_message = f"{Logger.OKBLUE}{message}{Logger.ENDC}"
        else:
            formatted_message = message

        print(formatted_message)


def generate_chat_response(messages, role, task, temperature=0.75, retries=3, backoff_factor=2):
    last_exception = None
    for retry_attempt in range(retries):
        try:
            # Ensure the system message indicates JSON response format
            system_message = {
                "role": "system",
                "content": "You are a helpful assistant. Please respond with information in JSON format."
            }
            messages_with_json = [system_message] + messages

            # Send request to Azure OpenAI model using JSON mode
            response = azure_openai_client.chat.completions.create(
                model=azure_oai_model,
                response_format={"type": "json_object"},
                messages=messages_with_json,
                temperature=temperature,
                max_tokens=1800
            )
            response_content = response.choices[0].message.content
            Logger.log_message(f"SSPEC Response ({role} - {task}): {response_content}", 'debug')
            return response_content
        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                Logger.log_message(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.", 'error')
                time.sleep(sleep_time)
            else:
                Logger.log_message(f"Error in generate_chat_response: {e}. All retries exhausted.", 'error')

    # Raise the last exception if all retries fail
    raise last_exception

def parse_ai_response_and_generate_html(response_json):
    structured_solution = {}
    expected_phases = ["Discovery", "Engagement", "Action", "Completion", "Legacy"]

    for phase in expected_phases:
        structured_solution[phase] = []
        for cos in response_json.get(phase, []):
            cos_id = str(uuid.uuid4())
            cos_html = cos['content']
            ces = []

            soup = BeautifulSoup(cos_html, 'html.parser')
            for ce_tag in soup.find_all('ce'):
                ce_uuid = str(uuid.uuid4())
                new_tag = soup.new_tag('span', attrs={
                    'class': 'badge rounded-pill bg-secondary ce-pill',
                    'data-ce-id': ce_uuid,
                    'data-ce-type': ce_tag['type']
                })
                new_tag.string = ce_tag.string
                ce_tag.replace_with(new_tag)

                ce_data = {
                    'id': ce_uuid,
                    'content': ce_tag.string,
                    'status': 'Proposed',
                    'type': ce_tag['type']
                }
                ces.append(ce_data)

                # Store the CEs
                if USE_DATABASE:
                    ce_instance = CE(id=ce_uuid, content=ce_tag.string, node_type=ce_tag['type'])
                    db.session.add(ce_instance)
                else:
                    ce_store[ce_uuid] = ce_data

            if USE_DATABASE:
                db.session.commit()

            structured_solution[phase].append({
                'id': cos_id,
                'content': str(soup),
                'status': 'Proposed',
                'ces': ces
            })

    return structured_solution


def generate_outcome_data(request, method, selected_goal=None, domain=None, domain_icon=None):
    # Initialize outcome_data with default keys and values
    outcome_data = {
        'user_input': '',
        'selected_goal': selected_goal,
        'domain_icon': domain_icon,
        'domain': domain,
        'ssol_id': None,
        'ssol_summary': "An error occurred while processing the summary data.",
        'phases': {},
        'generated_image_path': 'images/sspec_default.png'
    }

    user_input = request.form.get('user_text', '').strip() if method == 'POST' else request.args.get('user_text', '').strip()
    outcome_data['user_input'] = user_input

    # Generate or retrieve an SSOL instance and get the id
    if USE_DATABASE:
        ssol_instance = SSOL.query.filter_by(title=selected_goal).first()
        if not ssol_instance:
            ssol_instance = SSOL(title=selected_goal, description='')
            db.session.add(ssol_instance)
            db.session.commit()
        ssol_id = ssol_instance.id
    else:
        ssol_instance = next((ssol for ssol in ssol_store.values() if ssol['title'] == selected_goal), None)
        if not ssol_instance:
            ssol_id = str(uuid4())
            ssol_instance = {'id': ssol_id, 'title': selected_goal, 'description': ''}
            ssol_store[ssol_id] = ssol_instance
        ssol_id = ssol_instance['id']

    outcome_data['ssol_id'] = ssol_id

    # Generate the high-level summary
    summary_messages = [
    {
        "role": "system",
        "content": (
            "Assume it is possible to fulfill any outcome, generate a high-level summary "
            "(key name: summary) of everything required for the goal working backwards from fulfilled by some point in the future, "
            "includle any existing or potential legal, scientific, logistic or other barriers which needed to be addressed for completion."
        )
    },
    {
        "role": "user",
        "content": (
            f"Generate a high-level, elegantly-formatted summary for the goal: '{selected_goal}'. "
            "Please format the summary using Bootstrap-safe HTML, including tags such as <br> for line breaks "
            "and ordered lists."
        )
    }
]

    try:
        summary_response = generate_chat_response(summary_messages, role='Outcome Generation', task='Generate High-Level Summary')
        summary_data = json.loads(summary_response)
        outcome_data['ssol_summary'] = summary_data.get('summary', "Summary not available.")
    except Exception as e:
        current_app.logger.error(f"Error in generate_outcome_data (summary): {e}", exc_info=True)

    # Generate the structured solution
    structured_solution_messages = [
    {
        "role": "system",
        "content": "You are a helpful assistant. Generate detailed Conditions of Satisfaction (COS) and multiple Conditional Elements (CE) for each COS of a project, including specific attributes for each CE."
    },
    {
        "role": "user",
        "content": (
            f"Generate a concise Structured Solution for the project '{selected_goal}'. "
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 targeted Conditions of Satisfaction (COS). "
            "For each COS, identify and list 2 to 4 specific and succinct Conditional Elements (CE) with unique IDs. "
            "Focus on essential contributors such as resources, legislation, research, stakeholders, and timelines. "
            "Select the most specific type from CE_nodes.py for each CE, denoted with <ce> tags. "
            "Account for interdependencies and their impacts across project phases. "
            "Format your response as a JSON object with each phase as a key and an array of COS objects as values. "
            "Each COS object should include brief COS text, a unique ID, a status (Proposed), and an array of CEs. "
            "Each CE should be a JSON object with 'id', 'content' (2-4 sentences), 'status', 'type', and additional details as needed. "

            "Here is an example for the Discovery phase: "
            "'Discovery': ["
            "    {"
            "      'id': 'COS-001',"
            "      'content': '<ce id=\"CE-001\" type=\"Research\">Market research</ce> to assess <ce id=\"CE-002\" type=\"Demand\">consumer interest</ce> in a <ce id=\"CE-003\" type=\"Product\">new product</ce>.' ,"
            "      'status': 'Proposed',"
            "      'ces': ["
            "        {'id': 'CE-001', 'content': 'Conduct market analysis', 'status': 'Proposed', 'type': 'Research'},"
            "        {'id': 'CE-002', 'content': 'Evaluate consumer demand', 'status': 'Proposed', 'type': 'Demand'},"
            "        {'id': 'CE-003', 'content': 'Define product concept', 'status': 'Proposed', 'type': 'Product'}"
            "      ]"
            "    }"
            "]"
  )}
  ]

    try:
        structured_solution_response = generate_chat_response(structured_solution_messages, role='Structured Solution Generation', task='Generate Structured Solution')
        structured_solution_json = json.loads(structured_solution_response)

        # Ensure the structured_solution_json is a dictionary before processing
        if isinstance(structured_solution_json, dict):
            outcome_data['phases'] = parse_ai_response_and_generate_html(structured_solution_json)
        else:
            logging.error("Expected a dictionary for the structured solution JSON response.")
            outcome_data['phases'] = {}
    except json.JSONDecodeError as e:
        logging.error(f"JSON decoding error: {e}")
        outcome_data['phases'] = {}
    except Exception as e:
        logging.error(f"Error in generate_outcome_data (structured solution): {e}", exc_info=True)
        outcome_data['phases'] = {}

    # Generate an image using Stability AI
    try:
        image_prompt = f"A colorful, visually stunning photograph of a retro-futuristic tableau depicting '{selected_goal}' as a fulfilled goal, Mary Blair, It's a Small World, 1962, photo-realistic, isometric, tiltshift "
        web_image_path = generate_image(image_prompt, selected_goal)
        outcome_data['generated_image_path'] = web_image_path
    except Exception as e:
        current_app.logger.error(f"Error generating image: {e}", exc_info=True)
        outcome_data['generated_image_path'] = 'images/sspec_default.png'

    # Return the outcome_data for rendering in the template
    return outcome_data


def analyze_user_input(text):
    messages = [
        {"role": "system", "content": "You are an AI that analyzes user inputs and extracts keywords."},
        {"role": "user", "content": text},
    ]

    response_text = generate_chat_response(messages, role='Keyword Extraction', task='Extract Keywords', temperature=0.75)
    keywords = response_text.split(', ')
    print(f"Keywords: {keywords}")
    return keywords

def generate_sentiment_analysis(text, temperature=0.7):
    messages = [
        {"role": "system", "content": "You are an AI trained to analyze sentiment and return POSITIVE, NEGATIVE, or NEUTRAL"},
        {"role": "user", "content": f"What sentiment is expressed in the following text: '{text}'?"},
    ]

    # Use the generate_chat_response function
    response_text = generate_chat_response(messages, role='Sentiment Analysis', task='Analyze Sentiment', temperature=temperature)

    # Parse the response to extract the sentiment
    sentiment = "NEUTRAL"  # Default to NEUTRAL if parsing fails or no clear sentiment is found
    if "positive" in response_text.lower():
        sentiment = "POSITIVE"
    elif "negative" in response_text.lower():
        sentiment = "NEGATIVE"
    elif "neutral" in response_text.lower():
        sentiment = "NEUTRAL"

    return sentiment

def generate_goal(user_input):
    goal_options = []
    temperatures = [0.6, 0.8, 1.0]

    while len(goal_options) < 3:
        for i, temp in enumerate(temperatures):
            messages = [
                {"role": "system", "content": "You are an AI that generates innovative and unique goal outcomes or intentions based on the user's input. Structure your response in JSON format with a 'goal' key."},
                {"role": "user", "content": user_input},
            ]

            try:
                response = generate_chat_response(messages, role='Goal Generation', task=f'Generate Goal (Variation {i + 1})', temperature=temp).strip()
                goal_option_data = json.loads(response)
                goal_option = goal_option_data['goal']  # Expecting the response to have a 'goal' key

                goal_compliant, non_compliance_reason = is_goal_compliant(goal_option)

                if goal_compliant and goal_option not in [g['title'] for g in goal_options]:
                    goal_options.append({'title': goal_option, 'compliant': goal_compliant, 'reason': non_compliance_reason})
                elif not goal_compliant:
                    goal_options.append({'title': goal_option, 'compliant': False, 'reason': non_compliance_reason})

                if len(goal_options) == 3:
                    break

            except json.JSONDecodeError as e:
                print(f"Error parsing JSON in generate_goal (Variation {i + 1}): {e}")
                raise e
            except Exception as e:
                print(f"Error in generate_goal (Variation {i + 1}): {e}")
                raise e

    if len(goal_options) < 3:
        raise ValueError("Failed to generate unique goals. Please try again.")

    return goal_options

def is_goal_compliant(selected_goal):
    sentiment_counts = {'POSITIVE': 0, 'NEGATIVE': 0, 'NEUTRAL': 0}

    for _ in range(5):
        try:
            sentiment_label = generate_sentiment_analysis(selected_goal)
            # Ensure the label is uppercase to match dictionary keys
            sentiment_counts[sentiment_label.upper()] += 1
        except ValueError as e:
            print(f"Error in sentiment analysis: {e}")
            continue

    # Determine compliance based on the sentiment counts
    if sentiment_counts['POSITIVE'] >= 3:
        return True, ''
    elif sentiment_counts['NEGATIVE'] >= 3:
        return False, 'The goal does not comply with the safety protocol.'
    else:
        return True, 'The goal has a neutral sentiment and is allowed.'

def get_domain_icon_and_name(goal_domain):
    messages = [
        {"role": "system", "content": "You are an AI that suggests a domain and FontAwesome 6 Solid (fas) class icon based on the goal domain. Output only the domain and icon class in JSON format."},
        {"role": "user", "content": f"What is the best domain and corresponding FontAwesome icon class for the goal related to '{goal_domain}'?"}
    ]
    response_content = generate_chat_response(messages, role='Domain and Icon', task='Fetch Domain and free FontAwesome 6 Icon', temperature=0.37)

    try:
        # Log the raw response content for debugging
        Logger.log_message(f"Raw response content: {response_content}", 'debug')

        # Parse the JSON string into a dictionary
        response_data = json.loads(response_content)
        # Make sure to match the keys exactly with the response content
        domain = response_data.get("domain")
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"

        if not domain or not icon_class:
            # Log a warning if expected keys are missing
            Logger.log_message("Missing 'domain' or 'iconClass' in AI response.", 'warning')
            raise ValueError("Failed to generate domain and icon. Please try again.")

        return icon_class, domain

    except json.JSONDecodeError as e:
        # Log the JSON parsing error
        Logger.log_message(f"JSON parsing error: {e}", 'error')
        raise ValueError("Failed to parse JSON response. Please try again.")

    except Exception as e:
        # Log any other exceptions
        Logger.log_message(f"Unexpected error: {e}", 'error')
        raise

def get_cos_by_guid(ssol, cos_guid):
    for phase in ssol['phases'].values():
        for cos in phase:
            if cos['id'] == cos_guid:
                return cos
    return None

def update_cos_content_by_guid(ssol, cos_guid, new_content):
    cos = get_cos_by_guid(ssol, cos_guid)
    if cos:
        cos['content'] = new_content
        return True
    return False

def sanitize_filename(filename):
    # Sanitize the filename by removing or replacing invalid characters.
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', filename)  # Remove invalid characters
    filename = re.sub(r'[\s]+', '_', filename)  # Replace spaces with underscores
    return filename[:255]  # Truncate long filenames

def generate_image(prompt, goal_title, seed=None, width=512, height=512):
    if not azure_oai_key or not stability_api_key:
        raise ValueError("API keys are not provided for Azure OpenAI or Stability SDK.")

    stability_api = stability_client.StabilityInference(
        key=stability_api_key,
        verbose=True,
        engine="stable-diffusion-xl-beta-v2-2-2",
    )

    # Generate a unique filename for the image
    unique_filename = f"generated_image_{uuid.uuid4().hex}.png"

    # Ensure the 'static/images' directory exists within your Flask app structure
    static_folder = current_app.static_folder
    image_folder = os.path.join(static_folder, 'images')
    os.makedirs(image_folder, exist_ok=True)  # Create the folder if it does not exist
    image_file_path = os.path.join(image_folder, unique_filename)  # Full path for saving the file

    try:
        answers = stability_api.generate(
            prompt=prompt,
            seed=seed,
            steps=30,
            cfg_scale=8.0,
            width=width,
            height=height,
            samples=1,
            sampler=generation.SAMPLER_K_DPMPP_2M,
        )

        for resp in answers:
            for artifact in resp.artifacts:
                if artifact.finish_reason == generation.FILTER:
                    warnings.warn("Your request activated the API's safety filters and could not be processed. Please modify the prompt and try again.")
                if artifact.type == generation.ARTIFACT_IMAGE:
                    img = Image.open(io.BytesIO(artifact.binary))
                    img.save(image_file_path)  # Save the image using the correct directory and filename
                    # Convert the path to URL-friendly format
                    web_path = os.path.join('images', unique_filename).replace("\\", "/")
                    return web_path
    except Exception as e:
        print(f"Error in generate_image: {e}")

    # If an error occurs or the image is not generated, use a placeholder image
    placeholder_image_path = os.path.join('images', 'sspec_default.png').replace("\\", "/")
    return placeholder_image_path

def generate_structured_solution(selected_goal):
    structured_solution = {}
    system_message = {
        "role": "system",
        "content": (
            "You are an AI that generates a structured solution for a project. "
            "For each phase of the project, generate Conditions of Satisfaction (COS) with embedded Conditional Elements (CEs). "
            "Use <ce> tags to denote CEs within the COS text and provide each CE with a unique identifier and type. "
            "Return a JSON object with phases as keys and lists of COS objects as values. "
            "Each COS object should include the COS text with embedded CEs, a unique ID, a status, and an array of CEs. "
            "Each CE should be represented within the COS text and also listed as a JSON object with 'id', 'content', and 'type' keys. "
            "The keys for COS text, status, and CEs should be 'cos_text', 'cos_status', and 'cos_ces' respectively."
        )
    }

    user_message = {
        "role": "user",
        "content": (
            f"Generate a Structured Solution for the project '{selected_goal}'. "
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 specific and succinct COS. "
            "Within each COS text, identify and label relevant keywords as CEs using <ce> tags. "
            "Assign each CE a unique ID and a type that best describes its role or category in the context of the COS. "
            "Provide a brief explanation for each COS's importance and how it contributes to the overall goal. "
            "Format your response as a JSON object with each phase as a key and an array of COS objects. "
            "Use the keys 'cos_text', 'cos_status', and 'cos_ces' for COS text, status, and CEs respectively."
        )
    }

    messages = [system_message, user_message]
    try:
        response_text = generate_chat_response(
            messages,
            role='Structured Solution Generation',
            task='Generate Structured Solution',
            temperature=0.75,
            retries=3,
            backoff_factor=2
        )

        # Check if the response is complete and valid JSON before parsing
        if response_text and response_text.strip().endswith('}'):
            response_json = json.loads(response_text)
        else:
            raise ValueError("Incomplete JSON response received from AI.")

        # Iterate over the phases and extract the COS and CEs directly from the list
        structured_solution['phases'] = {
    phase: [
        {
            'id': cos.get('id', str(uuid.uuid4())),
            'status': 'Proposed',
            'cos_text': cos['cos_text'],  # Corrected key
            'ces': cos.get('CEs', [])
        }
        for cos in response_json.get(phase, [])
    ]
    for phase in ['Discovery', 'Engagement', 'Action', 'Completion', 'Legacy']
}


        return structured_solution  # Return the correctly structured solution

    except json.JSONDecodeError as e:
        current_app.logger.error(f"Error parsing JSON response: {e}", exc_info=True)
        raise ValueError("Failed to parse JSON response.")
    except ValueError as e:
        current_app.logger.error(f"Error in generating structured solution: {e}", exc_info=True)
        raise
    except Exception as e:
        current_app.logger.error(f"Unexpected error in generating structured solution: {e}", exc_info=True)
        raise ValueError("Failed to generate structured solution.")




üü© goal_selection.html:
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
  <h1>What is your Commitment?</h1>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Your Input</th>
        <th class="text-end">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="user-input">{{ user_input }}</td>
        <td class="text-end">
          <button type="button" class="btn btn-primary btn-sm edit-user-input">Edit</button>
          <button type="button" class="btn btn-success btn-sm save-user-input d-none">Update</button>
          <button type="button" class="btn btn-danger btn-sm cancel-user-input d-none">Cancel</button>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    Based on your input, we have speculated three high-level outcomes.
    Please choose the one that is closest to your desired result, or click the "Speculate New Outcomes" button to generate a new set of possibilities.
  </p>
  <!-- Add the class 'card-container' to the div below -->
  <div class="row card-container">
    {% for goal in goals %}
      <div class="col-md-4 mb-4">
        <div class="card retro-futuristic-card text-center {% if not goal.compliant %}non-compliant{% endif %}">
          <div class="card-body card-content">
            <i class="{{ goal.icon }} fa-2x mb-3"></i>
            <p class="domain domain-text">{{ goal.domain | title }}</p>
            <h5 class="card-title" data-text="{{ goal.title }}">{{ goal.title | safe }}</h5>
            {% if goal.compliant %}
            <form action="/outcome" method="post" class="goal-selection-form">
              <input type="hidden" name="selected_goal" value="{{ goal.title }}">
              <input type="hidden" name="domain" value="{{ goal.domain }}">
              <input type="hidden" name="domain_icon" value="{{ goal.icon }}">
              <input type="hidden" name="user_text" value="{{ user_input }}">
              <input type="hidden" name="ai_response" value="The AI response data">
              <button type="submit" class="btn btn-primary">Select</button>
            </form>
            {% else %}
            <button type="button" class="btn btn-danger" onclick="window.location.href='/';">Start Over</button>
            {% endif %}
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
  <div class="text-center">
    <button type="button" class="btn btn-outline-primary" id="generate-new-goals">
      <span class="refresh-icon"><i class="fas fa-sync-alt"></i></span> Speculate New Outcomes</button>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module" src="{{ url_for('static', filename='js/goal_selection.js') }}"></script>
{% endblock %}



üü¶ outcome.html:
{% extends 'base.html' %}

{% block content %}
<div class="container">
  <div class="row outcome-header">
    <div class="col-md-4 text-center">
      {% if ssol.generated_image_path %}
      <img src="{{ url_for('static', filename=ssol.generated_image_path) }}" alt="Generated Image" class="rounded mb-3 generated-image" style="width: 100%; max-width: 300px;">
      {% endif %}
      <h2>Domain</h2>
      <i class="{{ ssol.domain_icon }} fa-3x mb-3"></i>
      <p class="domain domain-text text-center">{{ ssol.domain | title }}</p>
      <h2>Fulfilled Goal</h2>
      <p><strong>{{ ssol.selected_goal | safe }}</strong></p>
      <div class="text-center mt-4">
        <button id="save-as-pdf-button" data-ssol-id="{{ ssol_id }}" class="btn btn-info" title="Save as PDF">
          <i class="fas fa-download me-2"></i>PDF
        </button>
      </div>
  </div>
    <div class="col-md-8">
      <h1>Preliminary Structured Solution</h1>
      <p id="ssol-summary">{{ ssol.ssol_summary | safe }}</p>
    </div>
  </div>

  <div class="row">
    <h1>Phases & Conditions of Satisfaction</h1>
    <div class="col">
      <div class="accordion mt-4" id="phase-accordion">
        {% for phase_name, cos_list in ssol.phases.items() %}
        <div class="accordion-item">
          <h2 class="accordion-header phase-colors" id="heading-{{ phase_name | replace(' ', '_') }}">
            <button
              class="accordion-button"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapse-{{ phase_name | replace(' ', '_') }}"
              aria-expanded="true"
              aria-controls="collapse-{{ phase_name | replace(' ', '_') }}"
              style="background-color: var(--phase-{{ loop.index0 }});">
              {{ phase_name | title }} PHASE
            </button>
          </h2>
          <div
            id="collapse-{{ phase_name | replace(' ', '_') }}"
            class="accordion-collapse collapse show"
            aria-labelledby="heading-{{ phase_name | replace(' ', '_') }}"
            data-bs-parent="#phase-accordion">
            <div class="accordion-body" data-ssol-id="{{ ssol_id }}" style="border: 2px solid var(--phase-{{ loop.index0 }});">
              {% if cos_list %}
              <table class="table table-striped phase-table" id="{{ phase_name | replace(' ', '_') }}-table">
                <thead>
                  <tr>
                    <th scope="col">Status</th>
                    <th scope="col">Condition of Satisfaction</th>
                    <th scope="col">Accountable Party</th>
                    <th scope="col">Completion Date</th>
                    <th scope="col" class="text-end actions-header">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {% for cos in cos_list %}
                    <tr class="cos-row" data-cos-id="{{ cos.id }}" data-editing="false">
                      <td class="status-cell">
                        <span class="status-pill {{ cos.status | get_badge_class_from_status }} ">{{ cos.status | upper }}</span>
                      </td>
                      <td class="cos-content-cell">{{ cos.content | safe }}</td>
                      <td class="cos-accountable-party-cell">{{ cos.accountable_party }}</td>
                      <td class="cos-completion-date-cell">{{ cos.completion_date }}</td>
                      <td class="text-end actions-cell">
                        <div class="cos-actions">
                          <button class="btn btn-sm btn-primary edit-cos-button">Edit</button>
                          <button class="btn btn-sm btn-success update-cos-button d-none">Update</button>
                          <button class="btn btn-sm btn-secondary cancel-cos-button d-none">Cancel</button>
                          <button class="btn btn-sm btn-danger delete-cos-button">Delete</button>
                          <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="{{ cos.id }}">Analyze</button>
                        </div>
                      </td>
                    </tr>
                    {% endfor %}
                </tbody>
              </table>
              <button class="btn btn-success btn-sm add-cos" data-bs-toggle="modal" data-bs-target="#addCOSModal" data-phase="{{ phase_name | replace(' ', '_') }}">Add Condition of Satisfaction</button>
              {% else %}
              <p>No Conditions of Satisfaction found for this phase.</p>
              {% endif %}
            </div>
          </div>
        </div>
        {% endfor %}
      </div>
    </div>
  </div>
<!-- Error Modal -->
<div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="errorModalLabel">Error</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        {{ error_message }}
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Placeholder for dynamic modals -->
<div id="dynamicModalContainer"></div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/cos_table.js') }}"></script>
<script src="{{ url_for('static', filename='js/ce_table.js') }}"></script>
<script src="{{ url_for('static', filename='js/ce_cards.js') }}"></script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Initialize event listeners for COS table handling
    initializePhaseTableEventListeners();
    // Removed addEventListenersToCELabels call
  });
</script>
<script type="text/javascript">
  const NODES = {{ nodes|tojson }};
</script>

{% endblock %}




üü¶ cos_table.js:
function getBadgeClassFromStatus(status) {
  switch (status) {
    case 'Proposed': return 'bg-info';
    case 'In Progress': return 'bg-warning text-dark';
    case 'Completed': return 'bg-success';
    case 'Rejected': return 'bg-danger';
    default: return 'bg-secondary';
  }
}

// Function to add event listeners to the phase table
function initializePhaseTableEventListeners() {
  const phaseTables = document.querySelectorAll('.phase-table');
  phaseTables.forEach(table => {
      table.addEventListener('click', handlePhaseTableClick);
  });
}

// Handles clicks within the phase table
function handlePhaseTableClick(event) {
  const target = event.target;
  const row = target.closest('tr.cos-row');
  if (!row) return;

  const cosId = row.dataset.cosId;

  if (target.matches('.edit-cos-button')) {
      turnRowToEditMode(row);
  } else if (target.matches('.update-cos-button')) {
      handleUpdate(row, cosId);
  } else if (target.matches('.cancel-cos-button')) {
      cancelEditMode(row);
  } else if (target.matches('.delete-cos-button')) {
      deleteCOS(cosId, row);
  }
}

function toggleEditMode(row, editing) {
  const editButton = row.querySelector('.edit-cos-button');
  const updateButton = row.querySelector('.update-cos-button');
  const cancelButton = row.querySelector('.cancel-cos-button');

  if (editing) {
    editButton.classList.add('d-none');
    updateButton.classList.remove('d-none');
    cancelButton.classList.remove('d-none');
  } else {
    editButton.classList.remove('d-none');
    updateButton.classList.add('d-none');
    cancelButton.classList.add('d-none');
  }
}

function turnRowToEditMode(row) {
  storeOriginalValues(row);

  const statusCell = row.querySelector('.status-cell');
  const contentCell = row.querySelector('.cos-content-cell');
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');
  const completionDateCell = row.querySelector('.cos-completion-date-cell');

  const currentStatus = statusCell.textContent.trim();
  const currentContent = contentCell.textContent.trim();
  const currentAccountableParty = accountablePartyCell.textContent.trim();
  const currentCompletionDate = completionDateCell.textContent.trim();

  statusCell.innerHTML = createStatusDropdown(currentStatus);
  contentCell.innerHTML = `<textarea class="form-control form-control-sm" rows="3">${currentContent}</textarea>`;
  accountablePartyCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentAccountableParty}">`;
  completionDateCell.innerHTML = `<input type="date" class="form-control form-control-sm" value="${currentCompletionDate}">`;

  toggleEditMode(row, true);
}

function handleUpdate(row, cosId, ssolId) {
  const contentInput = row.querySelector('.cos-content-input');
  const newContent = contentInput ? contentInput.value : '';
  const statusSelect = row.querySelector('.status-cell select');
  const statusInput = statusSelect.options[statusSelect.selectedIndex].value;
  const accountablePartyInput = row.querySelector('.cos-accountable-party-cell input').value;
  const completionDateInput = row.querySelector('.cos-completion-date-cell input').value;

  const payload = {
    content: contentInput,
    status: statusInput,
    accountable_party: accountablePartyInput,
    completion_date: completionDateInput,
    ssol_id: ssolId
  };

  console.log(`Sending update for COS ID: ${cosId}`, payload); // Added log

  fetch(`/update_cos/${cosId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    body: JSON.stringify(payload)
  })
  .then(response => {
    if (!response.ok) {
      return response.json().then(errorData => {
        throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);
      });
    }
    return response.json();
  })
  .then(data => {
    console.log(`Received response for COS ID: ${cosId}`, data); // Added log
    if (data.success) {
      console.log(`Updating row with new values for COS ID: ${cosId}`); // Added log
      updateRowWithNewValues(row, data.cos);
      toggleEditMode(row, false);
    } else {
      throw new Error(data.error || 'An error occurred while updating the entry.');
    }
  })
  .catch(error => {
    console.error(`Error updating COS ID: ${cosId}:`, error); // Updated log
    alert(`An error occurred while updating the entry: ${error.message}`);
  });
}

function createStatusDropdown(selectedStatus) {
  const statuses = ['Proposed', 'In Progress', 'Completed', 'Rejected'];
  return `<select class="form-select form-select-sm">${statuses.map(status => `<option value="${status}"${status === selectedStatus ? ' selected' : ''}>${status}</option>`).join('')}</select>`;
}

function cancelEditMode(row) {
  revertToOriginalValues(row);
  toggleEditMode(row, false);
}

function deleteCOS(cosId, row) {
  // Get the COS content to display in the confirmation dialog
  const cosContent = row.querySelector('.cos-content-cell').textContent;

  // Display a confirmation dialog
  if (confirm(`Really delete Condition of Satisfaction "${cosContent}"?`)) {
    fetch(`/delete_cos/${cosId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        row.remove();
      } else {
        console.error('Error deleting COS:', data.error);
      }
    })
    .catch(error => {
      console.error('Error deleting COS:', error);
    });
  }
}

function storeOriginalValues(row) {
  const statusCell = row.querySelector('.status-cell');
  const contentCell = row.querySelector('.cos-content-cell');
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');
  const completionDateCell = row.querySelector('.cos-completion-date-cell');

  row.dataset.originalValues = JSON.stringify({
    status: statusCell.textContent.trim(),
    content: contentCell.textContent.trim(),
    accountableParty: accountablePartyCell.textContent.trim(),
    completionDate: completionDateCell.textContent.trim()
  });
}

function revertToOriginalValues(row) {
  const originalValues = JSON.parse(row.dataset.originalValues);
  row.querySelector('.status-cell').innerHTML = `<span class="badge badge-pill ${getBadgeClassFromStatus(originalValues.status)}">${originalValues.status}</span>`;
  row.querySelector('.cos-content-cell').textContent = originalValues.content;
  row.querySelector('.cos-accountable-party-cell').textContent = originalValues.accountableParty;
  row.querySelector('.cos-completion-date-cell').textContent = originalValues.completionDate;
}

function updateRowWithNewValues(row, cos) {
  // Check if the cos object and its properties are defined
  if (cos && cos.status && cos.content) {
    row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(cos.status)}">${cos.status}</span>`;
    row.querySelector('.cos-content-cell').textContent = cos.content;
    row.querySelector('.cos-accountable-party-cell').textContent = cos.accountable_party || '';
    row.querySelector('.cos-completion-date-cell').textContent = cos.completion_date || '';
  } else {
    // If cos or any required property is undefined, log an error or handle appropriately
    console.error('Error: COS data is undefined or missing required properties', cos);
    alert('An error occurred while updating the entry. Please try again.');
  }
}
// Function to add event listeners to the phase table
function initializePhaseTableEventListeners() {
  const phaseTables = document.querySelectorAll('.phase-table');
  phaseTables.forEach(table => {
      table.addEventListener('click', handlePhaseTableClick);
  });
}

// Handles clicks within the phase table
function handlePhaseTableClick(event) {
  const target = event.target;
  const row = target.closest('tr.cos-row');
  if (!row) return;

  const cosId = row.dataset.cosId;

  if (target.matches('.edit-cos-button')) {
      turnRowToEditMode(row);
  } else if (target.matches('.update-cos-button')) {
      handleUpdate(row, cosId);
  } else if (target.matches('.cancel-cos-button')) {
      cancelEditMode(row);
  } else if (target.matches('.delete-cos-button')) {
      deleteCOS(cosId, row);
  }
}

// Function to fetch and display analyzed COS for a given COS ID
function fetchAndDisplayAnalyzedCOS(cosId) {
  fetch(`/analyze_cos/${cosId}`)
      .then(handleResponse)
      .then(data => {
          updateCOSContent(data.content_with_ce);
      })
      .catch(error => {
          displayError(`Failed to analyze COS: ${error}`);
      });
}


// Event listener to fetch and display analyzed COS content after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  const analyzeButtons = document.querySelectorAll('.analyze-cos-button');
  analyzeButtons.forEach(button => {
    button.addEventListener('click', function () {
      const cosId = this.getAttribute('data-cos-id');
      fetchAndDisplayAnalyzedCOS(cosId);
    });
  });
});


// Function to add event listeners to CE pills
function initializeCEPillEventListeners() {
  const cePills = document.querySelectorAll('.ce-pill');
  cePills.forEach(pill => {
      pill.addEventListener('click', handleCEPillClick);
  });
}

function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  console.log(`CE Pill with ID ${ceId} clicked`);

  // Example logic to fetch CE details and display in a modal or another UI element
  fetch(`/get_ce_by_id/${ceId}`)
      .then(response => response.json())
      .then(data => {
          if (data && data.ce) {
              displayCEDetails(data.ce); // Function to display CE details
          } else {
              console.error('CE details not found or error in response:', data);
          }
      })
      .catch(error => {
          console.error('Error fetching CE details:', error);
      });
}



// Event listener to initialize phase table event listeners after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
      button.addEventListener('click', (event) => {
          const cosId = event.target.getAttribute('data-cos-id');
          if (cosId) {
              fetchAndDisplayAnalyzedCOS(cosId);
          }
      });
  });
});

// Function to add event listeners to CE pills
function initializeCEPillEventListeners() {
  const cePills = document.querySelectorAll('.ce-pill');
  cePills.forEach(pill => {
      pill.addEventListener('click', handleCEPillClick);
  });
}

// Event listener to initialize phase table event listeners after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      if (cosId) {
        fetchAndDisplayAnalyzedCOS(cosId);
      }
    });
  });

  // Add event listener to the Analyze button
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.analyze-cos-button').forEach(button => {
      button.addEventListener('click', (event) => {
        const cosId = event.target.getAttribute('data-cos-id');
        if (cosId) {
          fetchAndDisplayAnalyzedCOS(cosId);
        }
      });
    });
  });

  function extractCosContentForEditing(cosContentCell) {
    const badgeElements = cosContentCell.querySelectorAll('.badge');
    badgeElements.forEach((badge) => {
      const ceContent = badge.textContent;
      // Replace the badge HTML with a placeholder or markup that includes the CE content
      badge.outerHTML = `[CE]${ceContent}[/CE]`;
    });
    return cosContentCell.innerHTML; // This now contains the editable content with [CE][/CE] placeholders
  }


  document.addEventListener('DOMContentLoaded', () => {
    // Get all COS content cells
    const cosContentCells = document.querySelectorAll('.cos-content-cell');

    // Loop over each cell and replace CE tags with pills
    cosContentCells.forEach(cell => {
      const content = cell.textContent;
      const newContent = replaceCETagsWithPills(content); // This is your existing JS function
      cell.innerHTML = newContent;
    });

    // Now that the DOM has been updated, add event listeners to the new pill elements
    addEventListenersToCELabels();
  });
})

// Function to save the content as PDF
function saveAsPDF(ssolId) {
  const htmlContent = document.documentElement.outerHTML; // Get the entire HTML content of the page
  fetch(`/save_as_pdf/${ssolId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ htmlContent: htmlContent })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`Server responded with status ${response.status}`);
    }
    return response.blob();
  })
  .then(blob => {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = `${ssolId}.pdf`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  })
  .catch((error) => {
    console.error('Error saving PDF:', error);
  });
}

// Event listener to initialize after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', function () {
  const saveButton = document.getElementById('save-as-pdf-button');
  if (saveButton) {
    saveButton.addEventListener('click', function (event) {
      event.preventDefault(); // Prevent the default button click action
      const ssolId = saveButton.dataset.ssolId;
      saveAsPDF(ssolId);
    });
  }
});



üü® speculate.py:
import re
import os
import html
import json
import uuid
import logging
from uuid import UUID
from bs4 import BeautifulSoup
from app import USE_DATABASE, db
from ce_nodes import NODES
from models import session
from sqlalchemy.exc import SQLAlchemyError
from utilities import generate_chat_response, parse_ai_response_and_generate_html
from models import COS, CE, SSOL, COS_CE_Link
from store import ssol_store, cos_store, ce_store
from sqlalchemy.orm import relationship, sessionmaker
from flask import render_template, jsonify, current_app
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Date, ForeignKey, create_engine


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def create_cos(ssol_id, content, status, accountable_party=None, completion_date=None):
    try:
        # Analyze the COS content to identify conditional elements
        analyzed_content = analyze_cos(content)
        content_with_ce = analyzed_content['content_with_ce']

        if USE_DATABASE:
            # Create a new COS instance
            cos = COS(content=content_with_ce, status=status, accountable_party=accountable_party,
                      completion_date=completion_date, ssol_id=ssol_id)
            db.session.add(cos)

            # Create and link CEs to the COS
            for ce_data in analyzed_content['ces']:
                ce = CE(content=ce_data['content'], node_type=ce_data['ce_type'])
                db.session.add(ce)
                cos.conditional_elements.append(ce)

            # Commit the transaction to the database
            db.session.commit()
            logging.info(f"COS with ID {cos.id} created and committed to the database.")
            return cos.id

        else:
            # Generate a unique ID for the in-memory COS
            cos_id = str(uuid.uuid4())
            cos = {'id': cos_id, 'content': content_with_ce, 'status': status, 'ssol_id': ssol_id}
            cos_store[cos_id] = cos

            # Store each CE in the in-memory store
            for ce_data in analyzed_content['ces']:
                ce_id = str(uuid.uuid4())
                ce = {'id': ce_id, 'content': ce_data['content'], 'node_type': ce_data['ce_type']}
                ce_store[ce_id] = ce
                cos['conditional_elements'] = cos.get('conditional_elements', []) + [ce]

            logging.info(f"COS with ID {cos_id} created in the in-memory store.")
            return cos_id

    except Exception as e:
        logging.error(f"Error creating COS: {e}", exc_info=True)
        if USE_DATABASE:
            db.session.rollback()  # Rollback the session in case of an error when using the database
        raise  # Reraise the exception to allow the caller to handle it


def get_cos_by_id(cos_id):
    from app import USE_DATABASE
    if USE_DATABASE:
        return COS.query.get(cos_id)
    else:
        return cos_store.get(str(cos_id))

def analyze_cos(cos_content):
    # Define the prompt for the AI to identify conditional elements
    prompt = (
        "Analyze the following condition of satisfaction (COS) and identify any conditional elements (CEs). "
        "Return a JSON object with the COS text and an array of CEs, each with its text and type."
        "\nCOS: '{}'"
        "\nExpected response format:"
        "{{"
        "  'COS': 'The full text of the COS',"
        "  'CEs': ["
        "    {{'text': 'A conditional element', 'type': 'The type of CE'}},"
        "    {{'text': 'Another conditional element', 'type': 'Another type of CE'}}"
        "  ]"
        "}}"
    ).format(cos_content)

    messages = [
        {"role": "system", "content": "Return a JSON object with the analyzed COS and CEs."},
        {"role": "user", "content": prompt},
    ]

    try:
        # Send messages to the AI and get the response
        response_text = generate_chat_response(messages)
        response_json = json.loads(response_text)

        # Extract the COS and CEs from the response
        cos_text = response_json.get("COS", cos_content)
        ces = response_json.get("CEs", [])

        # Process the CEs, such as storing them in the database
        stored_ces = []
        for ce in ces:
            new_ce = CE(content=ce["text"], node_type=ce["type"])
            db.session.add(new_ce)
            stored_ces.append(new_ce)
        db.session.commit()

        return {'COS': cos_text, 'CEs': [ce.to_dict() for ce in stored_ces]}

    except Exception as e:
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)
        db.session.rollback()
        return {'COS': cos_content, 'CEs': []}


def extract_conditional_elements(response_text, original_content):
    ces = []
    try:
        # Use regex to extract CEs from response_text
        matches = re.findall(r'<ce>(.*?)</ce>', response_text, re.IGNORECASE)
        content_with_ce = original_content

        for match in matches:
            ce_content = html.escape(match.strip())  # Escape HTML special characters
            ce_uuid = str(uuid.uuid4())
            # Replace only the first occurrence of the matched CE content
            content_with_ce = re.sub(rf'<ce>\s*{re.escape(match.strip())}\s*</ce>', f'<span class="ce-pill" data-ce-id="{ce_uuid}">{ce_content}</span>', content_with_ce, count=1)
            ces.append({'id': ce_uuid, 'content': ce_content, 'ce_type': 'Unknown'})

        return {'content_with_ce': content_with_ce, 'ces': ces}
    except Exception as e:
        # Handle any errors that occur during the extraction process
        logging.error(f"Error extracting conditional elements: {e}", exc_info=True)
        return {'content_with_ce': original_content, 'ces': []}


def update_cos_by_id(cos_id, updated_data):
    from app import db, USE_DATABASE
    try:
        # If using database, convert UUID to string for query
        cos_id_str = str(cos_id) if isinstance(cos_id, UUID) else cos_id

        # Update the COS entry with new data
        if USE_DATABASE:
            # Database operation
            cos = session.query(COS).filter_by(id=cos_id).first()
            if cos:
                for key, value in updated_data.items():
                    setattr(cos, key, value)
                session.commit()
                return {'success': True, 'cos': cos.to_dict()}  # Return the updated COS for client-side use
            else:
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}
        else:
            # In-memory operation
            cos = cos_store.get(cos_id_str)  # Attempt to retrieve the COS entry
            if not cos:
                # COS not found, log a warning
                current_app.logger.warning(f"COS with ID {cos_id_str} not found in the in-memory store.")
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}

            for key, value in updated_data.items():
                cos[key] = value
            cos_store[cos_id_str] = cos  # Store the updated COS back in the store

            # Log the successful update and return the updated COS
            current_app.logger.info(f"COS with ID {cos_id_str} successfully updated.")
            return {'success': True, 'cos': cos}  # Return the updated COS for client-side use

    except Exception as e:
        # Log the error and return an error message
        current_app.logger.error(f"Unexpected error during COS update: {e}", exc_info=True)
        return {'success': False, 'message': f"Unexpected error occurred: {e}"}

def delete_cos_by_id(cos_id, ssol_id=None):
    from app import USE_DATABASE
    if USE_DATABASE:
        # Database operation
        cos = session.query(COS).filter_by(id=cos_id).first()
        if cos and (ssol_id is None or cos.ssol_id == ssol_id):
            session.delete(cos)
            session.commit()
            return True  # COS was deleted successfully
        else:
            return False  # COS did not exist or did not match the provided SSOL_ID
    else:
        # In-memory operation
        cos = cos_store.get(cos_id)
        if cos and (ssol_id is None or cos['ssol_id'] == ssol_id):
            del cos_store[cos_id]
            return True  # COS was deleted successfully
        return False  # COS did not exist or did not match the provided SSOL_ID


# Function to analyze the COS content and extract the CE type(s)
def analyze_ce_type(request):
    try:
        ce_content = request.get_json()['ce_content']
        ce_type = None

        # Iterate through the ce_types in ce_nodes.py and check if it appears in the ce_content
        for ce_type, values in NODES.items():
            if ce_type in ce_content:
                break

        return jsonify(ce_type=ce_type)
    except Exception as e:
        return jsonify(error=str(e))

def get_ce_type(ce_content):
    messages = [
        {"role": "system", "content": "You are responsible for identifying the appropriate card type for the given conditional element."},
        {"role": "user", "content": ce_content},
    ]
    response_text = generate_chat_response(messages, role='Conditional Element (CE) Node Type Identification', task='Identify CE Type', temperature=0.6)

    try:
        response_data = json.loads(response_text)
        ce_type = response_data.get('type', '')  # Assuming the key for the CE type in the response is 'type'
        return ce_type
    except json.JSONDecodeError:
        logging.error(f"Error parsing JSON response: {response_text}")
        return ""

# CRUD operations for SSOL
def create_ssol(goal, summary):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = SSOL(goal=goal, summary=summary)
        db.session.add(ssol)
        db.session.commit()
        return ssol.id
    else:
        ssol_id = str(uuid.uuid4())
        ssol_store[ssol_id] = {'id': ssol_id, 'goal': goal, 'summary': summary}
        return ssol_id

def get_ssol_by_id(ssol_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        return SSOL.query.get(ssol_id)
    else:
        return ssol_store.get(ssol_id)

def update_ssol_by_id(ssol_id, updated_data):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()
        for key, value in updated_data.items():
            setattr(ssol, key, value)
        session.commit()
    else:
        ssol = ssol_store.get(ssol_id)
        if ssol:
            ssol.update(updated_data)

def delete_ssol_by_id(ssol_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()
        session.delete(ssol)
        session.commit()
    else:
        ssol = ssol_store.pop(ssol_id, None)
        return bool(ssol)  # Returns True if an SSOL was deleted, False otherwise


def create_ce(content, node_type):
    ce_id = str(uuid.uuid4())
    ce_data = {
        'id': ce_id,
        'content': content,
        'node_type': node_type
    }

    if USE_DATABASE:
        ce = CE(id=ce_id, content=content, node_type=node_type)
        db.session.add(ce)
        db.session.commit()
        current_app.logger.debug(f"Created CE in database: {ce}")
    else:
        ce_store[ce_id] = ce_data
        current_app.logger.debug(f"Created CE in in-memory store: {ce_store[ce_id]}")

    return ce_id



def get_ce_by_id(ce_id):
    from app import USE_DATABASE, db
    try:
        if USE_DATABASE:
            ce = CE.query.get(ce_id)
            if not ce:
                raise ValueError(f"CE with ID {ce_id} not found in the database.")
        else:
            ce = ce_store.get(str(ce_id))
            if not ce:
                raise ValueError(f"CE with ID {ce_id} not found in the in-memory store.")

        return ce

    except ValueError as e:
        logging.error(f"Error retrieving CE by ID {ce_id}: {e}")
        raise e
    except Exception as e:
        logging.error(f"Unexpected error retrieving CE by ID {ce_id}: {e}", exc_info=True)
        raise e


# Function to update CE by ID
def update_ce_by_id(ce_id, ce_data):
    if USE_DATABASE:
        ce = CE.query.get(ce_id)
        if ce:
            for key, value in ce_data.items():
                setattr(ce, key, value)
            db.session.commit()
            return True
        else:
            return False
    else:
        if ce_id in ce_store:
            ce_store[ce_id].update(ce_data)
            return True
        else:
            return False


def delete_ce_by_id(ce_id):
    from app import db, USE_DATABASE
    if USE_DATABASE:
        ce = session.query(CE).filter_by(id=ce_id).first()
        session.delete(ce)
        session.commit()
    else:
        if ce_id in ce_store:
            del ce_store[ce_id]
            return True  # CE was deleted successfully
        return False  # CE did not exist in the store

# Function to generate the appropriate card based on the CE type
def generate_card(ce_type, ce_id):
    from app import db, USE_DATABASE
    if ce_type in NODES:
        node = NODES[ce_type]
        # If using a database, render a template with data fetched from the database
        if USE_DATABASE:
            template = render_template(
                node["flask_template"], ce_id=ce_id
            )
        else:
            # If using the in-memory store, pass the CE data directly to the template
            ce_data = ce_store.get(ce_id)
            template = render_template(
                node["flask_template"], ce=ce_data
            )
        return template
    else:
        return ""


def analyze_cos(cos_content):
    try:
        # Assume cos_content is the JSON response from the AI
        # Let's parse the JSON into a Python dictionary
        cos_json = json.loads(cos_content)

        # Use the parse_ai_response_and_generate_html function
        # to convert the AI response into HTML
        structured_solution_html = parse_ai_response_and_generate_html(cos_json)

        # Return the structured HTML content
        return structured_solution_html

    except json.JSONDecodeError as e:
        # If there's an error parsing the JSON, log it
        logging.error(f"JSON decode error during COS analysis: {e}", exc_info=True)
        return None

    except Exception as e:
        # If there's a different error, log it
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)
        return None


def get_badge_class_from_status(status):
    return {
        'Proposed': 'bg-info',
        'In Progress': 'bg-warning text-dark',  # Added text-dark for better contrast
        'Completed': 'bg-success',
        'Rejected': 'bg-danger'
    }.get(status, 'bg-secondary')  # Default to 'bg-secondary' if status is not found

    # Ensure database or in-memory store is initialized based on USE_DATABASE flag
def initialize_data_store():
    from app import USE_DATABASE, Base, _engine
    Base.metadata.create_all(_engine) if USE_DATABASE else None

def check_data_store_contents(data_store_type='in_memory'):
    if data_store_type == 'in_memory':
        try:
            # Print contents of the in-memory store
            for cos_id_str, cos_data in cos_store.items():
                logging.info(f"COS ID: {cos_id_str}, Data: {cos_data}")
        except NameError:
            logging.warning("In-memory store 'cos_store' not found.")
    elif data_store_type == 'database' and USE_DATABASE:
        try:
            # Query all entries in the COS table and print them
            cos_entries = COS.query.all()
            for entry in cos_entries:
                logging.info(f"COS ID: {entry.id}, Data: {entry}")
        except Exception as e:
            logging.error(f"Database query failed with error: {e}")
    else:
        logging.error(f"Unknown data store type: {data_store_type}")

        if __name__ == '__main__':
            logging.info("Checking initial data store contents...")
            check_data_store_contents('database' if USE_DATABASE else 'in_memory')

def get_phase_index(cos):
    # Determine the phase index based on the COS content or other criteria
    phase_mapping = {
        'Discovery': 0,
        'Engagement': 1,
        'Action': 2,
        'Completion': 3,
        'Legacy': 4,
    }
    # Example logic to determine the phase index
    phase_name = cos.get('phase', 'SSPEC')  # Default to 'SSPEC Time Mapper' if phase not found
    return phase_mapping.get(phase_name, 0)  # Default to 0 if phase not found in mapping



üü™ ce_table.js:
function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  fetch(`/get_ce_by_id/${encodeURIComponent(ceId)}`)
    .then(response => response.json())
    .then(data => {
      if (data && data.ce) {
        showCEModal(data.ce, data.cos_content); // Pass the parent COS content to the modal
      } else {
        throw new Error('CE data not found or error in response');
      }
    })
    .catch(error => {
      console.error('Error fetching CE data:', error);
    });
}



// Function to analyze the CE and get the CE type
function analyzeCE(ceId, ceData) {
  fetch('/analyze_ce_type', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ cos_content: ceData.content }),
  })
    .then((response) => response.json())
    .then((data) => {
      updateCEwithAnalyzedCE(ceId, ceData, data.ce_type);
    })
    .catch((error) => {
      console.log('Error:', error);
    });
}

// Function to update the CE with the analyzed CE type
function updateCEwithAnalyzedCE(ceId, ceData, ceType) {
  fetch(`/update_ce_type?ce_id=${ceId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ ce_type: ceType }),
  })
    .then((response) => response.json())
    .then((data) => {
      if (data.ce && data.ce.ce_type) {
        showCEModal(data.ce);
      } else {
        showCEModal(ceData);
      }
    })
    .catch((error) => {
      console.log('Error:', error);
    });
}

// Function to create the CE modal content
function createCEModalContent(ceData, cosContent) {
  const modalContent = document.createElement('div');
  modalContent.classList.add('modal-content');

  const modalHeader = document.createElement('div');
  modalHeader.classList.add('modal-header');
  modalHeader.innerHTML = `
    <h5 class="modal-title" id="ceModalLabel">Conditional Element Details</h5>
    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
      <span aria-hidden="true">&times;</span>
    </button>
  `;

  const modalBody = document.createElement('div');
  modalBody.classList.add('modal-body');

  if (ceData && ceData.content && cosContent) {
    const cosContentElement = document.createElement('p');
    cosContentElement.innerHTML = `<strong>Parent COS:</strong> ${cosContent}`;

    const ceContentElement = document.createElement('h2');
    ceContentElement.textContent = ceData.content;

    const ceTypeElement = document.createElement('p');
    ceTypeElement.textContent = `CE Type: ${ceData.ce_type}`;

    modalBody.appendChild(cosContentElement);
    modalBody.appendChild(ceContentElement);
    modalBody.appendChild(ceTypeElement);
  } else {
    modalBody.innerHTML = '<p>Error: Unable to load CE details.</p>';
  }

  modalContent.appendChild(modalHeader);
  modalContent.appendChild(modalBody);

  return modalContent;
}


// Function to display the CE modal
function showCEModal(ceData) {
  const modal = document.createElement('div');
  modal.classList.add('modal', 'fade');
  modal.id = 'ceModal';
  modal.setAttribute('tabindex', '-1');
  modal.setAttribute('aria-labelledby', 'ceModalLabel');
  modal.setAttribute('aria-hidden', 'true');

  const modalDialog = document.createElement('div');
  modalDialog.classList.add('modal-dialog', 'modal-dialog-centered');
  modalDialog.setAttribute('role', 'document');

  const modalContent = createCEModalContent(ceData);
  modalDialog.appendChild(modalContent);
  modal.appendChild(modalDialog);

  document.body.appendChild(modal);

  $(modal).modal('show');

  $(modal).on('hidden.bs.modal', function () {
    modal.remove();
  });
}

// Function to handle the edit button click for CE
function handleCEEditButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentCell = row.querySelector('.ce-content-cell');
  const currentContent = ceContentCell.textContent.trim();

  // Replace the content cells with editable fields
  ceContentCell.innerHTML = `<input type="text" class="form-control form-control-sm ce-content-input" value="${currentContent}">`;

  // Show the update and cancel buttons, hide the edit and delete buttons
  row.querySelector('.edit-ce-button').classList.add('d-none');
  row.querySelector('.delete-ce-button').classList.add('d-none');
  row.querySelector('.update-ce-button').classList.remove('d-none');
  row.querySelector('.cancel-ce-button').classList.remove('d-none');
}

// Function to handle the update button click for CE
function handleCEUpdateButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentInput = row.querySelector('.ce-content-input');

  // If there is a valid input field, update the CE content
  if (ceContentInput) {
    const newContent = ceContentInput.value.trim();
    row.querySelector('.ce-content-cell').textContent = newContent;
  }

  // Hide the update and cancel buttons and show the edit button
  row.querySelector('.edit-ce-button').classList.remove('d-none');
  row.querySelector('.update-ce-button').classList.add('d-none');
  row.querySelector('.cancel-ce-button').classList.add('d-none');
}

// Function to handle the cancel button click for CE
function handleCECancelButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentCell = row.querySelector('.ce-content-cell');
  const originalContent = ceContentCell.dataset.originalContent;

  // Revert the content cell to its original value
  ceContentCell.textContent = originalContent;

  // Hide the update and cancel buttons and show the edit button
  row.querySelector('.edit-ce-button').classList.remove('d-none');
  row.querySelector('.update-ce-button').classList.add('d-none');
  row.querySelector('.cancel-ce-button').classList.add('d-none');
}

// Add event listeners to CE pills and buttons within the CE table
document.addEventListener('DOMContentLoaded', () => {
  const cosTable = document.querySelector('#cos-table');

  if (cosTable) {
    cosTable.addEventListener('click', (event) => {
      if (event.target.matches('.edit-ce-button')) {
        handleEditButtonClick(event);
      } else if (event.target.matches('.delete-ce-button')) {
        handleDeleteButtonClick(event);
      } else if (event.target.matches('.analyze-ce-button')) {
        handleAnalyzeButtonClick(event);
      }
    });
  }
});

function handleEditButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentCell = row.querySelector('.ce-content-cell');
  const currentContent = ceContentCell.textContent.trim();

  // Replace the content cell with an input field
  ceContentCell.innerHTML = `<input type="text" class="form-control form-control-sm ce-content-input" value="${currentContent}">`;

  // Change the "Edit" button to a "Save" button
  event.target.classList.add('d-none');
  const saveButton = row.querySelector('.save-ce-button');
  if (saveButton) {
    saveButton.classList.remove('d-none');
  }

  // Add click event for the save button
  saveButton.addEventListener('click', (e) => handleSaveButtonClick(e, row));
}

function handleSaveButtonClick(event, row) {
  const ceContentInput = row.querySelector('.ce-content-input');
  const newContent = ceContentInput.value.trim();
  const ceId = row.dataset.ceId;
  // Send the updated content to the server
  fetch(`/update_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId, content: newContent}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the update was successful
    if (data.success) {
      // Update the UI to show the new content
      const ceContentCell = row.querySelector('.ce-content-cell');
      ceContentCell.textContent = newContent;
      // Change the "Save" button back to an "Edit" button
      const editButton = row.querySelector('.edit-ce-button');
      editButton.classList.remove('d-none');
      event.target.classList.add('d-none');
    } else {
      console.error('Error updating CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleDeleteButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send a delete request to the server
  fetch(`/delete_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the delete was successful
    if (data.success) {
      // Remove the row from the table
      row.remove();
    } else {
      console.error('Error deleting CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleAnalyzeButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send the COS/CE content to the server for analysis
  fetch(`/analyze_cos/${ceId}`)
  .then(response => response.json())
  .then(data => {
    // Display the analysis results
    if (data.analyzed_cos) {
      // Update the UI with the analyzed data
      // This could be displaying a modal, updating a field, etc.
      console.log('Analyzed COS:', data.analyzed_cos);
    } else {
      console.error('Error analyzing COS:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}


üè≥Ô∏è‚Äçüåà ce_nodes.py:
NODES = {
    "Default": {
        "definition": "This node is a default research mode for undefined node types.",
        "icon": "fas fa-question-circle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "detail", "placeholder": "Detail"},
                {"type": "file", "name": "supporting_files", "placeholder": "Supporting Files"},
                {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}
            ],
            "explanation": "Provide a detailed description of the node.",
            "ai_context": "Generate data relevant to the parent COS and provide suggestions."
        }
    },
    "Research": {
        "definition": "This node aggregates resources and research related to the Conditional Element.",
        "icon": "fas fa-flask",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "research_title", "placeholder": "Research Title"},
                {"type": "textarea", "name": "research_summary", "placeholder": "Research Summary"},
                {"type": "text", "name": "researcher_name", "placeholder": "Researcher Name"}
            ],
            "explanation": "Capture relevant research aspects of the node.",
            "ai_context": "Retrieve data on preferred toasting levels from various sources."
        }
    },
    "Location": {
        "definition": "This node allows the user to specify a geographic region relevant to the Conditional Element.",
        "icon": "fas fa-map-marker-alt",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "region_name", "placeholder": "Region Name"},
                {"type": "textarea", "name": "region_details", "placeholder": "Region Details"},
                {"type": "text", "name": "coordinates", "placeholder": "Coordinates"}
            ]
        }
    },
    "Resource": {
        "definition": "This node provides a list of resources or assets related to the Conditional Element.",
        "icon": "fas fa-tools",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "resource_name", "placeholder": "Resource Name"},
                {"type": "textarea", "name": "resource_details", "placeholder": "Resource Details"},
                {"type": "text", "name": "resource_type", "placeholder": "Resource Type"}
            ]
        }
    },
    "Action": {
        "definition": "This node represents an action or task to be taken to fulfill the Conditional Element.",
        "icon": "fas fa-tasks",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "action_name", "placeholder": "Action Name"},
                {"type": "textarea", "name": "action_description", "placeholder": "Action Description"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ]
        }
    },
    "Time": {
        "definition": "This node specifies a time frame or deadline associated with the Conditional Element.",
        "icon": "fas fa-clock",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "time_frame", "placeholder": "Time Frame"},
                {"type": "date", "name": "start_date", "placeholder": "Start Date"},
                {"type": "date", "name": "end_date", "placeholder": "End Date"}
            ]
        }
    },
    "Stakeholder": {
        "definition": "This node captures the stakeholders involved in the Conditional Element.",
        "icon": "fas fa-user-friends",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "stakeholder_name", "placeholder": "Stakeholder Name"},
                {"type": "textarea", "name": "stakeholder_role", "placeholder": "Stakeholder Role"},
                {"type": "text", "name": "contact_info", "placeholder": "Contact Info"}
            ]
        }
    },
    "Collaboration": {
        "definition": "This node focuses on collaboration efforts or partnerships needed for the Conditional Element.",
        "icon": "fas fa-handshake",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "partner_name", "placeholder": "Partner Name"},
                {"type": "textarea", "name": "collaboration_details", "placeholder": "Collaboration Details"},
                {"type": "text", "name": "contact_person", "placeholder": "Contact Person"}
            ]
        }
    },
    "Policy": {
        "definition": "This node addresses policy or regulatory aspects related to the Conditional Element.",
        "icon": "fas fa-gavel",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "policy_name", "placeholder": "Policy Name"},
                {"type": "textarea", "name": "policy_details", "placeholder": "Policy Details"},
                {"type": "text", "name": "regulatory_body", "placeholder": "Regulatory Body"}
            ]
        }
    },
    "Data": {
        "definition": "This node highlights data requirements or analytics related to the Conditional Element.",
        "icon": "fas fa-database",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "data_type", "placeholder": "Data Type"},
                {"type": "textarea", "name": "data_requirements", "placeholder": "Data Requirements"},
                {"type": "text", "name": "data_source", "placeholder": "Data Source"}
            ]
        }
    },
    "Technology": {
        "definition": "This node explores the use of technology or tools for the Conditional Element.",
        "icon": "fas fa-cogs",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "technology_name", "placeholder": "Technology Name"},
                {"type": "textarea", "name": "technology_description", "placeholder": "Technology Description"},
                {"type": "text", "name": "integration_method", "placeholder": "Integration Method"}
            ]
        }
    },
    "Communication": {
        "definition": "This node focuses on communication strategies or channels related to the Conditional Element.",
        "icon": "fas fa-comments",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "communication_channel", "placeholder": "Communication Channel"},
                {"type": "textarea", "name": "communication_plan", "placeholder": "Communication Plan"},
                {"type": "text", "name": "target_audience", "placeholder": "Target Audience"}
            ]
        }
    },
    "Skill": {
        "definition": "This node identifies specific skills or expertise required for the Conditional Element.",
        "icon": "fas fa-brain",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "skill_name", "placeholder": "Skill Name"},
                {"type": "text", "name": "proficiency_level", "placeholder": "Proficiency Level"},
                {"type": "textarea", "name": "skill_description", "placeholder": "Skill Description"}
            ]
        }
    },
    "Education": {
        "definition": "This node addresses educational requirements or training related to the Conditional Element.",
        "icon": "fas fa-graduation-cap",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "course_name", "placeholder": "Course Name"},
                {"type": "textarea", "name": "course_description", "placeholder": "Course Description"},
                {"type": "text", "name": "institution", "placeholder": "Institution"}
            ]
        }
    },
    "Evaluation": {
        "definition": "This node tracks evaluation methods or metrics for assessing the Conditional Element.",
        "icon": "fas fa-star-half-alt",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "evaluation_method", "placeholder": "Evaluation Method"},
                {"type": "textarea", "name": "evaluation_criteria", "placeholder": "Evaluation Criteria"},
                {"type": "text", "name": "evaluator", "placeholder": "Evaluator"}
            ]
        }
    },
    "Impact": {
        "definition": "This node explores the potential impact or outcomes of the Conditional Element.",
        "icon": "fas fa-chart-bar",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "impact_statement", "placeholder": "Impact Statement"},
                {"type": "text", "name": "impact_metric", "placeholder": "Impact Metric"},
                {"type": "textarea", "name": "long_term_effects", "placeholder": "Long-term Effects"}
            ]
        }
    },
    "Legal": {
        "definition": "This node covers legal considerations or requirements related to the Conditional Element.",
        "icon": "fas fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "legal_requirements", "placeholder": "Legal Requirements"},
                {"type": "text", "name": "legislation", "placeholder": "Relevant Legislation"},
                {"type": "text", "name": "compliance_officer", "placeholder": "Compliance Officer"}
            ]
        }
    },
    "Environmental": {
        "definition": "This node focuses on environmental factors or considerations for the Conditional Element.",
        "icon": "fas fa-leaf",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "environmental_impact", "placeholder": "Environmental Impact"},
                {"type": "textarea", "name": "sustainability_goals", "placeholder": "Sustainability Goals"},
                {"type": "text", "name": "regulatory_agency", "placeholder": "Regulatory Agency"}
            ]
        }
    },
    "Compliance": {
        "definition": "This node focuses on compliance requirements or regulations for the Conditional Element.",
        "icon": "fas fa-file-alt",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "compliance_checklist", "placeholder": "Compliance Checklist"},
                {"type": "textarea", "name": "audit_history", "placeholder": "Audit History"},
                {"type": "text", "name": "compliance_analyst", "placeholder": "Compliance Analyst"}
            ]
        }
    },
    "Performance": {
        "definition": "This node tracks performance indicators or benchmarks for the Conditional Element.",
        "icon": "fas fa-chart-line",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "performance_metric", "placeholder": "Performance Metric"},
                {"type": "text", "name": "benchmark", "placeholder": "Benchmark"},
                {"type": "text", "name": "measurement_tool", "placeholder": "Measurement Tool"}
            ]
        }
    },
    "Logistic": {
        "definition": "This node addresses logistical considerations or requirements for the Conditional Element.",
        "icon": "fas fa-truck",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "logistics_plan", "placeholder": "Logistics Plan"},
                {"type": "text", "name": "supplier", "placeholder": "Supplier"},
                {"type": "text", "name": "delivery_schedule", "placeholder": "Delivery Schedule"}
            ]
        }
    },
    "Infrastructure": {
        "definition": "This node covers infrastructure needs or considerations for the Conditional Element.",
        "icon": "fas fa-building",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "infrastructure_type", "placeholder": "Infrastructure Type"},
                {"type": "textarea", "name": "infrastructure_details", "placeholder": "Infrastructure Details"},
                {"type": "text", "name": "maintenance_schedule", "placeholder": "Maintenance Schedule"}
            ]
        }
    },
    "Health and Safety": {
        "definition": "This node focuses on health and safety considerations for the Conditional Element.",
        "icon": "fas fa-heartbeat",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "safety_guidelines", "placeholder": "Safety Guidelines"},
                {"type": "text", "name": "health_risks", "placeholder": "Health Risks"},
                {"type": "text", "name": "safety_officer", "placeholder": "Safety Officer"}
            ]
        }
    },
    "Scalability": {
        "definition": "This node addresses the scalability potential of the Conditional Element.",
        "icon": "fas fa-expand-arrows-alt",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "scalability_plan", "placeholder": "Scalability Plan"},
                {"type": "text", "name": "scaling_strategy", "placeholder": "Scaling Strategy"},
                {"type": "text", "name": "growth_metrics", "placeholder": "Growth Metrics"}
            ]
        }
    },
    "Ethical": {
        "definition": "This node explores ethical considerations or implications of the Conditional Element.",
        "icon": "fas fa-balance-scale-left",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "ethical_considerations", "placeholder": "Ethical Considerations"},
                {"type": "text", "name": "ethics_committee", "placeholder": "Ethics Committee"},
                {"type": "text", "name": "ethical_guidelines", "placeholder": "Ethical Guidelines"}
            ]
        }
    },
    "Cultural": {
        "definition": "This node addresses cultural factors or considerations for the Conditional Element.",
        "icon": "fas fa-globe",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "cultural_impact", "placeholder": "Cultural Impact"},
                {"type": "text", "name": "cultural_consultant", "placeholder": "Cultural Consultant"},
                {"type": "text", "name": "cultural_practices", "placeholder": "Cultural Practices"}
            ]
        }
    },
    "Innovation": {
        "definition": "This node focuses on innovative approaches or technologies for the Conditional Element.",
        "icon": "fas fa-lightbulb-on",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "innovation_name", "placeholder": "Innovation Name"},
                {"type": "textarea", "name": "innovation_details", "placeholder": "Innovation Details"},
                {"type": "text", "name": "innovation_leader", "placeholder": "Innovation Leader"}
            ]
        }
    },
    "Public Relations": {
        "definition": "This node covers public relations strategies or activities related to the Conditional Element.",
        "icon": "fas fa-megaphone",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "pr_strategy", "placeholder": "PR Strategy"},
                {"type": "textarea", "name": "media_contacts", "placeholder": "Media Contacts"},
                {"type": "text", "name": "spokesperson", "placeholder": "Spokesperson"}
            ]
        }
    },
    "Governance": {
        "definition": "This node addresses governance structures or requirements for the Conditional Element.",
        "icon": "fas fa-users-cog",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "governance_model", "placeholder": "Governance Model"},
                {"type": "textarea", "name": "governance_details", "placeholder": "Governance Details"},
                {"type": "text", "name": "board_members", "placeholder": "Board Members"}
            ]
        }
    },
    "Monitoring": {
        "definition": "This node focuses on monitoring and tracking progress or performance related to the Conditional Element.",
        "icon": "fas fa-heartbeat",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "monitoring_tool", "placeholder": "Monitoring Tool"},
                {"type": "textarea", "name": "monitoring_plan", "placeholder": "Monitoring Plan"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ]
        }
    },
    "Quality Assurance": {
        "definition": "This node ensures quality control and assurance processes and standards for the Conditional Element.",
        "icon": "fas fa-check-circle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "qa_process", "placeholder": "QA Process"},
                {"type": "textarea", "name": "quality_standards", "placeholder": "Quality Standards"},
                {"type": "text", "name": "qa_lead", "placeholder": "QA Lead"}
            ]
        }
    },
    "Ethical AI": {
        "definition": "This node explores ethical considerations and guidelines related to the use of AI in the Conditional Element.",
        "icon": "fas fa-brain",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "ethical_ai_guidelines", "placeholder": "Ethical AI Guidelines"},
                {"type": "text", "name": "ai_ethics_board", "placeholder": "AI Ethics Board"},
                {"type": "text", "name": "ethical_issues", "placeholder": "Identified Ethical Issues"}
            ]
        }
    },
    "Privacy and Data Security": {
        "definition": "This node addresses privacy and data security measures and guidelines for the Conditional Element.",
        "icon": "fas fa-lock",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "data_security_plan", "placeholder": "Data Security Plan"},
                {"type": "text", "name": "data_protection_officer", "placeholder": "Data Protection Officer"},
                {"type": "text", "name": "compliance_standard", "placeholder": "Compliance Standard"}
            ]
        }
    },
    "Regulatory Compliance": {
        "definition": "This node focuses specifically on regulatory compliance requirements for the Conditional Element.",
        "icon": "fas fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "regulatory_requirements", "placeholder": "Regulatory Requirements"},
                {"type": "text", "name": "regulatory_agency", "placeholder": "Regulatory Agency"},
                {"type": "text", "name": "compliance_manager", "placeholder": "Compliance Manager"}
            ]
        }
    },
    "Cost and Budgeting": {
        "definition": "This node addresses cost estimation, budgeting, and financial considerations for the Conditional Element.",
        "icon": "fas fa-dollar-sign",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "budget_item", "placeholder": "Budget Item"},
                {"type": "number", "name": "cost_estimate", "placeholder": "Cost Estimate"},
                {"type": "text", "name": "financial_officer", "placeholder": "Financial Officer"}
            ]
        }
    },
    "Accessibility": {
        "definition": "This node emphasizes accessibility requirements and inclusive design principles for the Conditional Element.",
        "icon": "fas fa-wheelchair",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "accessibility_standards", "placeholder": "Accessibility Standards"},
                {"type": "text", "name": "accessibility_consultant", "placeholder": "Accessibility Consultant"},
                {"type": "text", "name": "compliance_check", "placeholder": "Compliance Check"}
            ]
        }
    },
    "User Experience": {
        "definition": "This node addresses user experience design and considerations for the Conditional Element.",
        "icon": "fas fa-user-circle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "ux_strategy", "placeholder": "UX Strategy"},
                {"type": "textarea", "name": "user_feedback", "placeholder": "User Feedback"},
                {"type": "text", "name": "ux_lead", "placeholder": "UX Lead"}
            ]
        }
    }
}



üîµ ce_cards.js:
document.addEventListener('DOMContentLoaded', function () {
  initializeCETable();
  setupEventListeners();
});

function initializeCETable() {
  const cosContentCells = document.querySelectorAll('.cos-content-cell');
  cosContentCells.forEach(cell => {
    cell.innerHTML = replaceCETagsWithPills(cell.innerHTML);
  });
}

function replaceCETagsWithPills(content) {
  const ceTagPattern = /<ce id="(.*?)" type="(.*?)">(.*?)<\/ce>/gi;
  return content.replace(ceTagPattern, (match, ceId, ceType, ceContent) => {
    return `<span class="badge rounded-pill bg-secondary ce-pill" data-ce-id="${ceId}" data-ce-type="${ceType}" contenteditable="false">${ceContent}</span>`;
  });
}

function setupEventListeners() {
  document.addEventListener('click', event => {
    if (event.target.matches('.ce-pill')) {
      handleCEPillClick(event);
    } else if (event.target.matches('.btn-save-changes')) {
      handleSaveChanges(event);
    }
  });
}

function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  const ceType = event.target.dataset.ceType || "Default";
  fetchCEDataAndDisplayModal(ceId, ceType);
}

function fetchCEDataAndDisplayModal(ceId, ceType) {
  fetch(`/get_ce_by_id/${encodeURIComponent(ceId)}`)
    .then(response => response.json())
    .then(data => {
      if (data && data.ce) {
        const ceData = data.ce;
        fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`)
          .then(response => response.json())
          .then(modalData => {
            if (modalData && modalData.modal_html) {
              displayCEModal(modalData.modal_html, ceData, data.cos_content);
            } else {
              throw new Error('Modal HTML content not found or error in response');
            }
          })
          .catch(error => console.error('Error fetching modal content:', error));
      } else {
        throw new Error('CE data not found or error in response');
      }
    })
    .catch(error => console.error('Error fetching CE details:', error));
}

function displayCEModal(modalHtml, ceData, cosContent) {
  const modalContainer = document.getElementById('dynamicModalContainer');
  if (!modalContainer) {
    console.error('Modal container element not found in the DOM');
    return;
  }

  modalContainer.innerHTML = modalHtml;

  const modalElement = modalContainer.querySelector('.modal');
  if (modalElement) {
    modalElement.id = `ceModal-${ceData.id}`;
  }

  // Update the modal with the CE data and COS content
  const modalTitle = modalContainer.querySelector('.modal-title');
  if (modalTitle) {
    modalTitle.innerHTML = `<i class="${ceData.icon}"></i> ${ceData.definition}`;
  }

  const cosContentElement = modalContainer.querySelector('.ai-generated-data');
  if (cosContentElement) {
    cosContentElement.innerHTML = `<h6>Parent COS: ${cosContent}</h6><p>${ceData.ai_data}</p>`;
  }

  setTimeout(() => {
    const modalElement = modalContainer.querySelector(`#ceModal-${ceData.id}`);
    if (modalElement) {
      $(`#${modalElement.id}`).modal('show');
    } else {
      console.error(`Modal element not found in the DOM for CE ID: ${ceData.id}`);
    }
  }, 100);
}

function handleSaveChanges(event) {
  const ceId = event.target.dataset.ceId;
  const form = document.querySelector(`form[data-ce-id="${ceId}"]`);
  if (form) {
    const formData = collectFormData(form);
    saveCEData(ceId, formData);
  } else {
    console.error('Form not found');
  }
}

function collectFormData(form) {
  const formData = new FormData(form);
  const data = {};
  formData.forEach((value, key) => data[key] = value);
  return data;
}

function saveCEData(ceId, formData) {
  fetch(`/update_ce/${encodeURIComponent(ceId)}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(formData)
  })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        updateCERow(ceId, formData);
        $(`#ceModal-${ceId}`).modal('hide');
        displayFeedback("CE updated successfully", "success");
      } else {
        displayFeedback(data.error || 'An error occurred while updating the CE.', "error");
      }
    })
    .catch(error => {
      displayFeedback(`Error: ${error.message}`, "error");
    });
}

function updateCERow(ceId, formData) {
  const cePill = document.querySelector(`.ce-pill[data-ce-id="${ceId}"]`);
  if (cePill) {
    cePill.textContent = formData['ceContent'];
    cePill.dataset.ceType = formData['ceType'];
  }
}

function displayFeedback(message, type) {
  const feedbackElement = document.querySelector('#feedback');
  if (feedbackElement) {
    feedbackElement.textContent = message;
    feedbackElement.className = `feedback ${type}`;
    feedbackElement.style.display = 'block';
    setTimeout(() => {
      feedbackElement.style.display = 'none';
    }, 5000);
  }
}



function handleSpeculate(event) {
  const button = event.target;
  speculate(button);
}

function speculate(button) {
  const ceType = button.closest('.modal').id.replace('ceModal-', '');
  const cosText = ''; // Retrieve the COS text relevant for speculation
  const ssolGoal = ''; // Retrieve the SSOL goal relevant for speculation
  const ceId = ''; // Retrieve the CE ID relevant for speculation

  try {
    const aiMessage = generate_ai_query(cosText, ceId, ceType, ssolGoal);
    fetchAIResponse(aiMessage)
      .then(aiResponse => {
        const tableContainer = document.querySelector(`#tableContainer${ceType}`);
        const newRow = document.createElement('tr');
        newRow.innerHTML = `<td>${aiResponse}</td>`;
        const table = tableContainer.querySelector('table tbody');
        table.appendChild(newRow);
      })
      .catch(error => {
        console.error('Error speculating AI response:', error);
      });
  } catch (error) {
    console.error('Error speculating AI response:', error);
  }
}

async function fetchAIResponse(aiMessage) {
  const aiEndpoint = '/ai-query-endpoint';
  const response = await fetch(aiEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ message: aiMessage })
  });

  if (!response.ok) {
    throw new Error(`AI service responded with status ${response.status}`);
  }

  const responseData = await response.json();
  return responseData;
}



üìÜ models.py:
import os
import uuid
from dotenv import load_dotenv
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, Date
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker, relationship

load_dotenv()

db = SQLAlchemy()
Base = declarative_base()
_engine = create_engine(os.environ.get('SQLALCHEMY_DATABASE_URI'), echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
session = scoped_session(SessionLocal)

class SSOL(db.Model):
    __tablename__ = 'ssol'
    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    cos = relationship('COS', back_populates='ssol')

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'cos': [cos.to_dict() for cos in self.cos]
        }

class COS(db.Model):
    __tablename__ = 'cos'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(String, nullable=False)
    status = Column(String(50), nullable=False)
    accountable_party = Column(String(255), nullable=True)
    completion_date = Column(Date, nullable=True)
    ssol_id = Column(Integer, ForeignKey('ssol.id'), nullable=False)
    ssol = relationship('SSOL', back_populates='cos')
    conditional_elements = relationship('CE', secondary='cos_ce_link', backref='cos')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'status': self.status,
            'accountable_party': self.accountable_party,
            'completion_date': self.completion_date.isoformat() if self.completion_date else None,
            'ssol_id': self.ssol_id,
            'conditional_elements': [ce.to_dict() for ce in self.conditional_elements]
        }

class CE(db.Model):
    __tablename__ = 'ce'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(String, nullable=False)
    node_type = Column(String(50), nullable=True)
    details = Column(Text, nullable=True)
    cos = relationship('COS', secondary='cos_ce_link', back_populates='conditional_elements')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'node_type': self.node_type,
            'details': self.details
        }



class COS_CE_Link(db.Model):
    __tablename__ = 'cos_ce_link'
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), primary_key=True)
    ce_id = Column(UUID(as_uuid=True), ForeignKey('ce.id'), primary_key=True)

Base.metadata.create_all(_engine)



üì± app.py:
import os
import logging
from flask import Flask
from flask_migrate import Migrate
from dotenv import load_dotenv
from models import db  # Import the db object from models.py


# Load environment variables
load_dotenv()

# Flag to toggle database usage
USE_DATABASE = os.environ.get('USE_DATABASE', 'False').lower() in ['true', '1', 't']

# Initialize Flask app
app = Flask(__name__)

# Set the secret key from the environment variables
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')

if USE_DATABASE:
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('SQLALCHEMY_DATABASE_URI')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['SQLALCHEMY_ECHO'] = True

    # Initialize SQLAlchemy
    db.init_app(app)

    # Initialize Flask-Migrate
    migrate = Migrate(app, db)

# Import the functions from speculate after db has been initialized to avoid circular imports
from speculate import get_badge_class_from_status

# Register the custom Jinja filter function
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

# Import the routes and register the Blueprint at the end of the file
from routes import routes_bp
app.register_blueprint(routes_bp)

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)  # Set the logging level to DEBUG
    logging.info("Checking initial data store contents...")
    from speculate import check_data_store_contents
    check_data_store_contents('database' if USE_DATABASE else 'in_memory')
    app.run(debug=True)


üè™ store.py:
# store.py
ssol_store = {}
cos_store = {}
ce_store = {}


üß© ce_templates.py:
import logging
from flask import render_template_string
from utilities import generate_chat_response
from ce_nodes import NODES

# Define a base template for the modal dialogs that will be populated dynamically
BASE_MODAL_TEMPLATE = """
<div class="modal fade" id="ceModal{{ ce_data.id }}" tabindex="-1" aria-labelledby="ceModalLabel{{ ce_data.id }}" aria-hidden="true">
  <div class="modal-dialog modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header" style="background-color: var(--phase-{{ ce_data.phase_index }}); position: relative;">
        <div class="node-icon" style="position: absolute; top: -20px; left: 20px;">
          <i class="{{ node_info['icon'] }} fa-2x" style="background-color: white; border-radius: 5px; padding: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);"></i>
        </div>
        <h5 class="modal-title" id="ceModalLabel{{ ce_data.id }}" style="margin-left: 60px;">
          {{ node_info['definition'] }}
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" style="box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);">
        <h6>Parent COS: {{ cos_content }}</h6>
        <p>{{ node_info['explanation'] }}</p>
        <div class="ai-generated-data">
          <h6>AI-Generated Data:</h6>
          <p>{{ ai_data }}</p>
        </div>
        <form id="ceForm{{ ce_data.id }}" data-ce-id="{{ ce_data.id }}">
          {{ form_fields | safe }}
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="{{ ce_data.id }}">Save changes</button>
      </div>
    </div>
  </div>
</div>
"""


def generate_form_field(field):
    field_templates = {
        'text': '<input type="text" class="form-control" name="{name}" value="{value}" placeholder="{placeholder}"/>',
        'number': '<input type="number" class="form-control" name="{name}" value="{value}" placeholder="{placeholder}"/>',
        'textarea': '<textarea class="form-control" name="{name}" placeholder="{placeholder}">{value}</textarea>',
        'email': '<input type="email" class="form-control" name="{name}" value="{value}" placeholder="{placeholder}"/>',
        'password': '<input type="password" class="form-control" name="{name}" placeholder="{placeholder}"/>',
        'date': '<input type="date" class="form-control" name="{name}" value="{value}"/>',
        'time': '<input type="time" class="form-control" name="{name}" value="{value}"/>',
        'datetime-local': '<input type="datetime-local" class="form-control" name="{name}" value="{value}"/>',
        'color': '<input type="color" class="form-control" name="{name}" value="{value}"/>',
        'checkbox': '<div class="form-check"><input type="checkbox" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',
        'radio': lambda field: ''.join(f'<div class="form-check"><input type="radio" class="form-check-input" id="{opt_value}" name="{field["name"]}" value="{opt_value}" '
                                       f'{"checked" if "value" in field and opt_value == field["value"] else ""}/><label class="form-check-label" for="{opt_value}">{opt_label}</label></div>'
                                       for opt_value, opt_label in (field.get('options', {})).items()),
        'select': lambda field: '<select class="form-control" name="{name}">' + ''.join(f'<option value="{opt_value}" '
                    f'{"selected" if "value" in field and opt_value == field["value"] else ""}>{opt_label}</option>'
                    for opt_value, opt_label in (field.get('options', {})).items()) + '</select>',
    }

    checked = 'checked' if field.get('value', False) and (field['type'] in ['checkbox', 'radio']) else ''

    if field['type'] in ['radio', 'select']:
        return field_templates[field['type']](field)
    else:
        return field_templates[field['type']].format(name=field['name'], value=field.get('value', ''), placeholder=field.get('placeholder', ''), checked=checked)

def generate_form_fields(fields_config):
    return ''.join(generate_form_field(field) for field in fields_config)

def generate_dynamic_modal(ce_type, ce_data=None, cos_content=None):
    node_info = NODES.get(ce_type, NODES['Default'])
    fields_config = node_info.get('modal_config', {}).get('fields', [])
    form_fields = generate_form_fields(fields_config)

    # Ensure ce_data and cos_content are provided
    if not ce_data:
        ce_data = {'id': 'unknown_ce_id'}
    ce_id = ce_data.get('id', 'unknown_ce_id')
    ssol_goal = "SSOL Goal Example"  # Replace with actual SSOL goal if available

    # Generate AI data with COS analysis
    ai_data = generate_ai_data(cos_content, ce_id, ce_type, ssol_goal)

    modal_content = render_template_string(
        BASE_MODAL_TEMPLATE,
        ce_type=ce_type,
        node_info=node_info,
        form_fields=form_fields,
        ce_data=ce_data,
        cos_content=cos_content,
        ai_data=ai_data
    )
    return modal_content


def generate_ai_data(cos_text, ce_id, ce_type, ssol_goal):
    node_info = NODES.get(ce_type, NODES['Default'])
    ai_context = node_info.get('ai_context', '')

    if not ai_context:
        return "No AI context provided."

    messages = [
        {
            "role": "system",
            "content": (
                "You are a helpful assistant. Generate contextually relevant data based on the Structured Solution (SSOL) goal, "
                "the parent Condition of Satisfaction (COS) text, and the specific Conditional Element Identifier (CE ID) and type provided. Use this information to generate "
                "detailed and specific insights or data that can fulfill on satisfying the COS and ultimately achieving the SSOL goal."
            )
        },
        {
            "role": "user",
            "content": (
                f"SSOL Goal: {ssol_goal}\n"
                f"COS Text: {cos_text}\n"
                f"CE ID: {ce_id}\n"
                f"CE Type: {ce_type}\n"
                f"Context: {ai_context}\n"
                f"Based on the SSOL goal and the context provided by the parent COS, "
                f"generate detailed and relevant data for the CE type '{ce_type}' that contributes towards meeting the COS and achieving the SSOL."
            )
        }
    ]

    try:
        response = generate_chat_response(messages, role='AI Contextual Query', task=f'Generate Data for {ce_type}')
        return response
    except Exception as e:
        logging.error(f"Error generating AI data: {e}")
        return "Error generating AI data."



