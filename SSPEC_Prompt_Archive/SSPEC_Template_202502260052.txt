‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SSPEC PossPath Essential Files ‚ïë
‚ïë Date: 2025-05-22               ‚ïë
‚ïë Version: 202502260052          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïùüåê Structured Speculation Possibility Pathfinder ("SSPEC PossPath") for short.
Your task is to develop the Flask Web App as an innovative tool for mass collaboration.
Essential app files:
üü• routes.py:
# routes.py (Refactored Version with create_cos route)
from flask import Blueprint, render_template, request, flash, redirect, url_for, jsonify, make_response, current_app, send_from_directory
import os
import json
import uuid
import pdfkit
import logging
import asyncio
from bs4 import BeautifulSoup
from app import app, USE_DATABASE # app is needed for app_context
from uuid import UUID
from utilities import generate_goal, analyze_user_input, generate_sentiment_analysis, generate_ssol_id
from utilities import generate_outcome_data, generate_ssol_image as util_generate_ssol_image
from dotenv import load_dotenv
from ce_nodes import NODES
from werkzeug.exceptions import BadRequest, NotFound
from ce_templates import generate_dynamic_modal, generate_ai_data
from speculate import get_ce_by_id as speculate_get_ce_by_id, \
                      update_ce_by_id as speculate_update_ce_by_id, \
                      create_cos as speculate_create_cos, \
                      get_cos_by_id as speculate_get_cos_by_id, \
                      update_cos_by_id as speculate_update_cos_by_id, \
                      delete_cos_by_id as speculate_delete_cos_by_id, \
                      analyze_cos as speculate_analyze_cos # Added analyze_cos alias
from models import get_engine_and_session, SSOL, COS # Import COS for type checking if needed
from urllib.parse import urlparse

load_dotenv()

routes_bp = Blueprint('routes_bp', __name__)

# --- Utility Route ---
@routes_bp.route('/favicon.ico')
def favicon():
    return send_from_directory(os.path.join(current_app.root_path, 'static'), 'favicon.ico', mimetype='image/vnd.microsoft.icon')


# --- Basic Pages ---
@routes_bp.route('/')
def index():
    return render_template('input.html')


@routes_bp.route('/about')
def about():
    return render_template('about.html')


# --- Goal Selection ---
@routes_bp.route('/goal_selection', methods=['POST'])
async def goal_selection():
    if request.method == 'POST':
        user_input = request.form['user_text'].strip()
        if not user_input:
            flash("Please enter your possibility or goal.", "error")
            return render_template('input.html')
        try:
            logging.info(f"User Input: '{user_input}'. Calling generate_goal...")
            goal_options = await generate_goal(user_input)
            logging.debug(f"generate_goal returned: {goal_options}")
            if not goal_options:
                flash("Could not generate goal options. Please try again.", "warning")
                return render_template('input.html')

            # Image generation can start here, but ensure it doesn't block response
            # For DB mode, we need an ssol_id. For non-DB, we might use goal title.
            # This part needs to align with how ssol_id is established later.
            # For now, let's assume image generation is tied to outcome creation more directly.

            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify(goals=goal_options, user_input=user_input)

            return render_template('goal_selection.html', goals=goal_options, user_input=user_input)
        except ValueError as e:
            flash(str(e), "error")
            logging.error(f"ValueError in goal_selection: {e}", exc_info=True)
            return render_template('input.html', user_text=user_input, error_message=str(e))
        except Exception as e:
            flash("An unexpected error occurred. Please try again.", "error")
            logging.error(f"Unexpected error in goal_selection: {e}", exc_info=True)
            return render_template('input.html', user_text=user_input, error_message=str(e))
    return redirect(url_for('routes_bp.index'))


# --- Outcome Generation ---
@routes_bp.route('/outcome', methods=['POST'])
async def outcome():
    if request.method == 'POST':
        logging.info(f"Outcome route - Form data received: {request.form}")
        selected_goal_text = request.form.get('selected_goal', '').strip()
        domain = request.form.get('domain', '').strip()
        selected_goal_title = request.form.get('selected_goal_title', '').strip()
        domain_icon = request.form.get('domain_icon', '').strip()

        if not selected_goal_text:
            flash("No goal selected. Please select a goal.", "error")
            return redirect(url_for('routes_bp.index'))
        try:
            # generate_outcome_data creates the SSOL and returns its ID and other data
            outcome_data = await generate_outcome_data(USE_DATABASE, request, 'POST', selected_goal_text, domain, domain_icon, selected_goal_title)
            ssol_id_str = outcome_data['ssol_id'] # This is the definitive ssol_id (string)
            
            current_app.logger.info(f"SSOL created/retrieved with ID: {ssol_id_str}. Triggering image generation.")

            image_prompt_context = selected_goal_title if selected_goal_title else selected_goal_text
            image_prompt = (
                f"A colorful, charming, and visually stunning diorama in the style of 'It's a Small World', "
                f"depicting '{image_prompt_context}' as a fulfilled goal in the domain of '{domain}'. "
                f"The scene should include diverse people, use an isometric perspective, and have a 1:1 square aspect ratio. "
                f"The artwork should evoke a mid-century modern aesthetic, reminiscent of 1960s illustration. "
                f"Do not include any text or labels."
            )
            # Pass the ssol_id_str to the background task for correct naming
            asyncio.create_task(util_generate_ssol_image(image_prompt, ssol_id=ssol_id_str)) 

            return render_template('outcome.html', ssol=outcome_data, nodes=NODES, ssol_id=ssol_id_str, selected_goal_title=selected_goal_title)
        except Exception as e:
            current_app.logger.error(f"Error generating outcome data: {e}", exc_info=True)
            flash("Error generating outcome data. Please try again.", "error")
            return redirect(url_for('routes_bp.index'))
    return redirect(url_for('routes_bp.index'))


# --- Input Analysis ---
@routes_bp.route('/analyze_input', methods=['POST'])
async def analyze_input_route():
    if request.method == 'POST':
        user_text = request.form.get('user_text')
        if not user_text:
            return jsonify({'error': 'No text provided'}), 400
        try:
            keywords = await analyze_user_input(user_text)
            sentiment = await generate_sentiment_analysis(user_text)
            return jsonify({'keywords': keywords, 'sentiment': sentiment})
        except Exception as e:
            logging.error(f"Error analyzing user input: {e}", exc_info=True)
            return jsonify({'error': 'Error analyzing input'}), 500
    return jsonify({'error': 'Invalid request method'}), 405


# --- PDF Export ---
@routes_bp.route('/save_as_pdf/<uuid:ssol_id>', methods=['POST'])
def save_as_pdf(ssol_id):
    try:
        data = request.get_json()
        if not data or 'htmlContent' not in data:
            raise ValueError("Invalid request: No HTML content provided.")
        html_content = data['htmlContent']

        # Path to your CSS file
        css_file_path = os.path.join(current_app.root_path, 'static', 'styles.css')
        if not os.path.exists(css_file_path):
             current_app.logger.error(f"CSS file not found at: {css_file_path}") # Log error
             # Fallback or error, but for now let's proceed without it if not found, pdfkit might still work
             css_param = None
        else:
            css_param = css_file_path

        # Ensure local file access for images, etc.
        # Replace relative static paths with absolute local file paths or external URLs
        # This example assumes static files are served from the root. Adjust if using a prefix.
        # For local file access, it's often better to point to the file system path.
        # However, for images served via Flask, _external=True should generate correct URLs.
        html_content = html_content.replace('src="/static/', f'src="{url_for("static", filename="", _external=True)}')
        # For local file system paths (requires enable-local-file-access):
        # html_content = html_content.replace('src="/static/', 'src="' + os.path.join(current_app.static_folder,''))


        options = {
            "page-size": "Letter",
            "margin-top": "0.75in",
            "margin-right": "0.75in",
            "margin-bottom": "0.75in",
            "margin-left": "0.75in",
            "encoding": "UTF-8",
            "no-outline": None,
            "enable-local-file-access": None, # Crucial for local images/CSS if not inlined
        }

        pdf = pdfkit.from_string(html_content, False, options=options, css=css_param)

        response = make_response(pdf)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename="SSPEC_Solution_{ssol_id}.pdf"'
        return response

    except Exception as e:
        current_app.logger.error(f"Exception in save_as_pdf for SSOL {ssol_id}: {e}", exc_info=True)
        return jsonify(success=False, error=str(e)), 500

# --- COS CRUD Routes ---

@routes_bp.route('/create_cos', methods=['POST'])
async def create_cos_route():
    try:
        data = request.get_json()
        if not data:
            raise BadRequest('No JSON payload received.')

        content = data.get('content')
        status = data.get('status', 'Proposed') # Default status
        ssol_id_str = data.get('ssol_id')
        accountable_party = data.get('accountable_party')
        completion_date = data.get('completion_date') # Should be ISO format string or None

        if not content or not ssol_id_str:
            raise BadRequest('Missing required fields: content and ssol_id are required.')

        try:
            ssol_id_uuid = UUID(ssol_id_str)
        except ValueError:
            raise BadRequest(f"Invalid ssol_id format: '{ssol_id_str}'. Must be a valid UUID.")

        # speculate_create_cos already handles USE_DATABASE context internally
        # and performs analysis to embed CE pills.
        # It returns the new cos_id (string).
        new_cos_id_str = await speculate_create_cos(
            USE_DATABASE,
            ssol_id=ssol_id_uuid, # Pass UUID object
            content=content,
            status=status,
            accountable_party=accountable_party,
            completion_date=completion_date
        )

        if not new_cos_id_str:
            raise Exception("Failed to create COS record.")

        # Fetch the newly created COS to get its full data, including processed content
        if USE_DATABASE:
            with app.app_context(): # Ensure app context for DB operations
                engine, session = get_engine_and_session()
                # speculate_get_cos_by_id expects a UUID object if db, string if not
                created_cos = speculate_get_cos_by_id(USE_DATABASE, UUID(new_cos_id_str))
                if created_cos:
                    cos_dict = created_cos.to_dict()
                else:
                    cos_dict = None
                session.close()
        else:
            created_cos = speculate_get_cos_by_id(USE_DATABASE, new_cos_id_str)
            cos_dict = created_cos # In-memory store returns a dict

        if not cos_dict:
             current_app.logger.error(f"Failed to retrieve newly created COS with ID: {new_cos_id_str}")
             return jsonify(success=False, error="COS created but could not be retrieved."), 500

        return jsonify(success=True, cos=cos_dict), 201 # 201 Created

    except BadRequest as e:
        current_app.logger.warning(f"BadRequest in create_cos_route: {e}")
        return jsonify(success=False, error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Error creating COS: {e}", exc_info=True)
        return jsonify(success=False, error="An unexpected error occurred while creating the COS."), 500


@routes_bp.route('/update_cos/<uuid:cos_id>', methods=['PUT'])
async def update_cos_route(cos_id): # Changed to async to allow await on speculate_update_cos_by_id if it becomes async
    try:
        data = request.get_json()
        if not data:
            raise BadRequest('No JSON payload received')
        cos_id_str = str(cos_id) # Ensure it's a string for in-memory store key if not using UUID object

        # speculate_update_cos_by_id handles USE_DATABASE context internally
        # It might become async if it involves AI re-analysis for CE pills.
        # For now, assuming it's synchronous but can be awaited if needed.
        update_result = await speculate_update_cos_by_id(USE_DATABASE, cos_id, data) # Pass UUID obj

        if update_result['success']:
            return jsonify(success=True, cos=update_result['cos']), 200
        return jsonify(success=False, error=update_result['message']), update_result.get('status_code', 404)
    except BadRequest as e:
        return jsonify(success=False, error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Error updating COS {cos_id}: {e}", exc_info=True)
        return jsonify(success=False, error="An unexpected error occurred."), 500


@routes_bp.route('/delete_cos/<uuid:cos_id>', methods=['DELETE'])
def delete_cos_route(cos_id):
    # speculate_delete_cos_by_id handles USE_DATABASE context internally
    try:
        success = speculate_delete_cos_by_id(USE_DATABASE, cos_id) # Pass UUID obj

        if success:
            return jsonify(success=True), 200
        return jsonify(success=False, error="COS not found or could not be deleted."), 404
    except Exception as e:
        current_app.logger.error(f"Error deleting COS {cos_id}: {e}", exc_info=True)
        return jsonify(success=False, error="An unexpected error occurred."), 500


# --- SSOL Image ---
@routes_bp.route('/get_ssol_image/<uuid:ssol_id>') # Keep uuid converter for type safety
async def get_ssol_image_route(ssol_id): # Renamed parameter to avoid clash with module
    ssol_id_str = str(ssol_id)
    image_filename = f"ssol_image_{ssol_id_str}.png" # Standard naming convention
    image_web_path_relative = os.path.join('images', image_filename).replace("\\", "/")
    image_fs_path = os.path.join(current_app.static_folder, 'images', image_filename)

    current_app.logger.info(f"GET_SSOL_IMAGE: Checking for {image_fs_path}")

    if os.path.exists(image_fs_path):
        current_app.logger.info(f"GET_SSOL_IMAGE: Found image {image_filename} for SSOL {ssol_id_str}.")
        return jsonify({'image_path': url_for('static', filename=image_web_path_relative), 'status': 'found'})
    else:
        current_app.logger.warning(f"GET_SSOL_IMAGE: Image {image_filename} for SSOL {ssol_id_str} not found at {image_fs_path}. It might still be generating.")
        # Return a specific status so client can retry or use default
        return jsonify({
            'image_path': url_for('static', filename='images/sspec_default.png'), # Provide default
            'status': 'pending_or_not_found', 
            'message': 'Image is processing or was not found. Displaying default.'
        }), 200 # Return 200 but with a status indicator

# --- CE Routes ---
@routes_bp.route('/get_ce_by_id', methods=['GET'])
def get_ce_by_id_route():
    ce_id_str = request.args.get('ce_id')
    if not ce_id_str:
        return jsonify(error="Missing 'ce_id' parameter"), 400
    try:
        ce_id = UUID(ce_id_str) # Convert to UUID
        # speculate_get_ce_by_id handles USE_DATABASE context
        ce = speculate_get_ce_by_id(USE_DATABASE, ce_id)

        if ce:
            return jsonify(ce=ce.to_dict() if USE_DATABASE else ce) # to_dict if model, else it's already dict
        return jsonify(error="CE not found"), 404

    except ValueError:
        return jsonify(error=f"Invalid CE ID format: {ce_id_str}"), 400
    except Exception as e:
        current_app.logger.error(f"Error getting CE {ce_id_str}: {e}", exc_info=True)
        return jsonify(error="An unexpected error occurred."), 500


@routes_bp.route('/analyze_cos/<uuid:cos_id>', methods=['GET']) # Changed to expect UUID
async def analyze_cos_by_id_route(cos_id): # Renamed from analyze_cos_by_id
    # speculate_analyze_cos handles USE_DATABASE context
    try:
        # First, get the COS content
        if USE_DATABASE:
            with app.app_context():
                engine, session = get_engine_and_session()
                cos_instance = session.query(COS).get(cos_id)
                session.close()
                if not cos_instance:
                    return jsonify({'success': False, 'message': 'COS not found'}), 404
                cos_content_to_analyze = cos_instance.content
        else:
            from store import cos_store
            cos_data = cos_store.get(str(cos_id))
            if not cos_data:
                return jsonify({'success': False, 'message': 'COS not found'}), 404
            cos_content_to_analyze = cos_data['content']
        
        # Now analyze its content
        # Pass cos_id (as string) for potential use within analyze_cos if it needs to link CEs back
        analysis_results = await speculate_analyze_cos(cos_content_to_analyze, str(cos_id))
        
        # If the analysis also updated the COS content in the database (e.g. added pills)
        # we might want to return the fresh COS object or its content.
        # For now, just returning analysis_results as per previous structure.
        return jsonify({'success': True, 'analysis_results': analysis_results}), 200

    except Exception as e:
        current_app.logger.error(f"Error analyzing COS {cos_id}: {e}", exc_info=True)
        return jsonify({'success': False, 'message': 'An unexpected error occurred during analysis.'}), 500


@routes_bp.route('/get_ce_modal/<string:ce_type>', methods=['POST'])
async def get_ce_modal_route(ce_type):
    try:
        data = request.get_json()
        current_app.logger.debug(f"get_ce_modal_route - request.get_json() data: {data}")

        ce_id_str = data.get('ce_id')
        ce_id_obj = UUID(ce_id_str) if ce_id_str else None


        # speculate_get_ce_by_id handles USE_DATABASE context
        ce_instance_or_dict = speculate_get_ce_by_id(USE_DATABASE, ce_id_obj) if ce_id_obj else None
        
        ce_data_for_modal = {}
        if ce_instance_or_dict:
            if USE_DATABASE and hasattr(ce_instance_or_dict, 'to_dict'):
                ce_data_for_modal = ce_instance_or_dict.to_dict()
            elif not USE_DATABASE and isinstance(ce_instance_or_dict, dict):
                 ce_data_for_modal = ce_instance_or_dict
            # Ensure 'id' is a string for template, even if it was UUID object
            if 'id' in ce_data_for_modal and isinstance(ce_data_for_modal['id'], UUID):
                ce_data_for_modal['id'] = str(ce_data_for_modal['id'])


        cos_content = data.get('cos_content', '')
        phase_name = data.get('phase_name', '')
        phase_index = data.get('phase_index', 0)
        ssol_goal = data.get('ssol_goal','')
        existing_ces = data.get('existing_ces', []) # For providing context to AI

        current_app.logger.debug(f"get_ce_modal_route - BEFORE generate_dynamic_modal - phase_name: '{phase_name}', phase_index: {phase_index}, ce_data_for_modal: {ce_data_for_modal}")

        ai_generated_data_for_modal = {} # Initialize
        if ce_type: # Only generate if ce_type is meaningful
             # Pass ce_id_str for logging/identification if needed by generate_ai_data
             ai_generated_data_for_modal = await generate_ai_data(cos_content, ce_id_str, ce_type, ssol_goal, existing_ces)

        from store import ce_store as in_memory_ce_store # Pass in-memory store for non-DB mode
        modal_html = await generate_dynamic_modal(
            ce_type,
            ce_data=ce_data_for_modal, # Pass the prepared dict
            cos_content=cos_content,
            ai_generated_data=ai_generated_data_for_modal,
            phase_name=phase_name,
            phase_index=phase_index,
            ce_store=in_memory_ce_store # ce_templates.py expects this
        )

        return jsonify(modal_html=modal_html, ai_generated_data=ai_generated_data_for_modal)

    except ValueError as ve: # For UUID conversion errors
        current_app.logger.error(f"ValueError in get_ce_modal: {ve}", exc_info=True)
        return jsonify(error=f"Invalid data format: {str(ve)}"), 400
    except Exception as e:
        current_app.logger.error(f"Error generating CE modal for type {ce_type}: {e}", exc_info=True)
        return jsonify(error=f"An error occurred: {str(e)}"), 500


@routes_bp.route('/ai-query-endpoint', methods=['POST'])
async def ai_query_route():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No JSON payload received'}), 400

        ce_type = data.get('ce_type')
        cos_content = data.get('cos_content')
        ce_id = data.get('ce_id') # This could be string or None
        ssol_goal = data.get('ssol_goal')
        existing_ces = data.get('existing_ces', [])

        if not ce_type or not cos_content or not ssol_goal:
            return jsonify({'error': 'Missing required parameters: ce_type, cos_content, ssol_goal'}), 400

        ai_response = await generate_ai_data(cos_content, ce_id, ce_type, ssol_goal, existing_ces)

        return jsonify({'success': True, 'ai_response': ai_response})

    except Exception as e:
        current_app.logger.error(f"Error in ai_query_route: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@routes_bp.route('/update_ce/<uuid:ce_id>', methods=['PUT'])
def update_ce_route(ce_id): # ce_id is already a UUID object from Flask's converter
    try:
        data = request.get_json()
        if not data:
            raise BadRequest('No JSON payload received')

        # speculate_update_ce_by_id handles USE_DATABASE context
        success = speculate_update_ce_by_id(USE_DATABASE, ce_id, data) # Pass UUID object

        if success:
            # Optionally, fetch and return the updated CE data
            updated_ce_obj = speculate_get_ce_by_id(USE_DATABASE, ce_id)
            if updated_ce_obj:
                ce_data = updated_ce_obj.to_dict() if USE_DATABASE else updated_ce_obj
                return jsonify(success=True, ce=ce_data), 200
            return jsonify(success=True, message="CE updated but could not be retrieved."), 200
        return jsonify(success=False, error="CE not found or could not be updated"), 404
    except BadRequest as e:
        return jsonify(success=False, error=str(e)), 400
    except Exception as e:
        current_app.logger.error(f"Error updating CE {ce_id}: {e}", exc_info=True)
        return jsonify(success=False, error="An unexpected error occurred."), 500


üüß ai_service.py:
# ai_service.py (Refactored for Gemini Image Generation)
import os
import json
import uuid
import logging
import asyncio
from google import genai
from google.genai import types
from PIL import Image
from io import BytesIO
from dotenv import load_dotenv
from flask import current_app
from ce_nodes import get_valid_node_types
from openai import AzureOpenAI
import re  # Import the regular expression module
import aiohttp #Import
# from utilities import sanitize_filename

# Load environment variables
load_dotenv()
google_gemini_api_key = os.environ["GOOGLE_GEMINI_API"]
gemini_model_name = os.getenv("GEMINI_MODEL_NAME", "gemini-1.5-pro-002")  # STABLE model for text
gemini_image_model_name = os.getenv("GEMINI_IMAGE_MODEL_NAME", "models/gemini-2.0-flash-exp") # Model for image generation - defaults to flash-exp

# Initialize Gemini client for text and image (using same API key)
gemini_client = genai.Client(api_key=google_gemini_api_key)


async def send_request_to_gemini(messages, generation_config=None, logger=None):
    """
    Asynchronously sends a request to the Google Gemini API and returns the response.
    """
    if logger is None:
        logger = current_app.logger
    try:
        logger.debug(f"Sending request to Gemini with messages: {messages}")

        contents = []
        for message in messages:
            if isinstance(message, dict) and 'role' in message and 'content' in message:
                role = message['role']
                if role not in ("user", "model"):
                    raise ValueError(f"Invalid role: {role}. Role must be 'user' or 'model'.")
                contents.append(
                    types.Content(
                        role=role,
                        parts=[types.Part(text=message['content'])]
                    )
                )
            else:
                logger.warning(f"Invalid message format: {message}. Skipping this message.")

        if generation_config is None:
            generation_config = types.GenerateContentConfig(safety_settings=[])
        elif isinstance(generation_config, dict):
            generation_config.setdefault('safety_settings', [])
            generation_config = types.GenerateContentConfig(**generation_config)

        response = await gemini_client.aio.models.generate_content( # Use gemini_client here
            model=gemini_model_name, # Use gemini_model_name for TEXT model
            contents=contents,
            config=generation_config
        )
        logger.debug(f"Gemini API response: {response.text}")  # LOG THE raw RESPONSE
        return response.text

    except Exception as e:
        logger.error(f"Error sending request to Gemini API: {e}", exc_info=True)
        raise

async def generate_chat_response(messages, role, task, model=None, temperature=0.75, retries=3, backoff_factor=2, logger=None, generation_config=None, system_instruction=None):
    if logger is None:
        logger = current_app.logger

    if generation_config is None:
        generation_config = types.GenerateContentConfig(
            temperature=temperature,
            top_p=0.95,
            top_k=40,
            max_output_tokens=2048,
            safety_settings=[]
        )
    elif isinstance(generation_config, dict):
        generation_config.setdefault('safety_settings', [])
        generation_config = types.GenerateContentConfig(**generation_config)

    last_exception = None
    for retry_attempt in range(retries):
        try:
            logger.debug(f"Sending request to Gemini (attempt {retry_attempt + 1})")
            raw_response = await send_request_to_gemini(messages, generation_config, logger)

            # Extract JSON from the raw response (Robust extraction)
            match = re.search(r"```json\n(.*?)```", raw_response, re.DOTALL)
            if match:
                response_content = match.group(1).strip()
            else:
                response_content = raw_response  # Use raw response if no JSON found
                logger.warning(f"No JSON found in Gemini response.  Using raw response.  Response: {response_content}")
            logger.debug(f"Gemini API response (extracted): {response_content}")
            return response_content  # Return the *extracted* JSON string


        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                logger.warning(f"Error in generate_chat_response: {e}.  Retrying in {sleep_time} seconds.")
                await asyncio.sleep(sleep_time)
            else:
                logger.error(f"Error in generate_chat_response: {e}. All retries exhausted.")
    if last_exception:
        raise last_exception

async def generate_chat_response_with_node_types(messages, role, task, temperature=0.75, retries=3, backoff_factor=2, logger=None):
    if logger is None:
        logger = current_app.logger

    last_exception = None
    for retry_attempt in range(retries):
        try:
            node_types = get_valid_node_types()
            node_types_str = ', '.join(node_types)

            # Modify messages to include system instruction as a user message
            system_message = {
                "role": "user",
                "content": "You are a helpful assistant. Please respond with information in JSON format. Valid Node Types: " + node_types_str + " **The response should be valid JSON.**"
            }
            messages_with_system = [system_message] + messages  # Prepend system message


            generation_config = types.GenerateContentConfig(
                temperature=temperature,
                top_p=0.95,
                top_k=40,
                max_output_tokens=2048,
                safety_settings=[],
            )
            # NOTE: generate_chat_response already extracts the JSON
            response_content = await generate_chat_response(messages_with_system, role, task, temperature=temperature, retries=retries, backoff_factor=backoff_factor, logger=logger, generation_config=generation_config)
            return response_content  # Return the extracted JSON string
        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                logger.warning(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.")
                await asyncio.sleep(sleep_time)
            else:
                logger.error(f"Error in generate_chat_response: {e}. All retries exhausted.")
    if last_exception:
        raise last_exception

async def get_grounded_data(query, ce_type):
    """
    Retrieves grounded data from Google Search for a given query and CE type.
    """
    try: # <-- Line 169 is likely here (start of try block)
        # client is already initialized at the top as gemini_client
        model = "gemini-2.0-pro-exp-02-05"  # Or your preferred model for grounding

        contents = [
            types.Content(
                role="user",
                parts=[types.Part.from_text(text=query)],
            ),
            types.Content(
                role="model", #Must have a model response.
                parts = [types.Part.from_text(text="Okay, I will search for that.")]
            ),
              types.Content(
                role="user",
                parts = [types.Part.from_text(text=(
                    "You are a helpful assistant that extracts information from Google Search results. "
                    f"You are assisting with a Conditional Element of type: {ce_type}.  "
                    "Return a JSON object with the following structure: \n"
                    "{\n"
                    " 'results': [\n"
                    " {\n"
                    " 'title': 'Title of the search result',\n"
                    " 'url': 'URL of the search result',\n"
                    " 'snippet': 'Snippet from the search result',\n"
                    " 'extracted_data': { ... }  // Data mapped to CE fields\n"
                    " }\n"
                    " ],\n"
                    " 'summary': 'A brief summary of the findings',\n"
                     " 'attribution': 'Data retrieved via Google Search using Gemini API.'\n"
                    "}\n"
                    "The 'extracted_data' field should map relevant information from the snippet to the "
                    f"fields defined for the CE type '{ce_type}'.  If a field cannot be filled from the snippet, "
                    "leave it as null or an empty string.  **The response should be valid JSON.**"

                ))]
            )
        ]

        tools = [types.Tool(google_search=types.GoogleSearch())]

        generation_config = types.GenerateContentConfig(
            temperature=0.4,  # Lower temperature for more factual results
            top_p=0.95,
            top_k=40, #Added top k back in.
            max_output_tokens=2048,  # Adjust as needed
            tools=tools,
        )
        response = await gemini_client.aio.models.generate_content( # Use gemini_client here
          model=model,
          contents=contents,
          config=generation_config,
        )

        if response and response.text: # Check if response and response.text are valid
            # Extract JSON (Robust Extraction)
            match = re.search(r"```(?:json)?\n([\s\S]*?)```", response.text, re.IGNORECASE) # More lenient regex
            if match:
                response_content = match.group(1).strip()
                current_app.logger.debug(f"Gemini API response (extracted): {response_content}")
            else:
                response_content = response.text # Use full text if no JSON block found
                current_app.logger.warning(f"No JSON block found in Gemini response. Using raw response text. Raw Response: {response.text}")
        else:
            response_content = None # Set it to None
            current_app.logger.warning(f"Gemini API response or response text is None. Full response object: {response}") # Log full response for debugging

        if response_content: # only if we got a valid result
          try:
            grounded_data = json.loads(response_content)
          except json.JSONDecodeError as e:
            current_app.logger.error(f"JSONDecode Error: {e}")
            return None
        else: # no result
            return None

        return grounded_data

    except Exception as e: # <-- **MISSING or INCORRECT 'except' clause - ADD THIS LINE**
        current_app.logger.error(f"Error in get_grounded_data: {e}", exc_info=True)
        return None

async def generate_image(prompt): # Renamed from generate_dalle_image
    from utilities import sanitize_filename
    from flask import current_app # Ensure current_app is imported

    try:
        # gemini_client is already initialized at the top
        # gemini_image_model_name is loaded from env vars at the top

        contents = prompt # Just the prompt string

        generate_content_config = types.GenerateContentConfig(  # Add GenerateContentConfig
            temperature=1.0, # Match Playground's temperature (or use 0.9 or 0.75 if 1.0 is too creative)
            top_p=0.95,
            top_k=40,
            max_output_tokens=8192, # Match Playground's max_output_tokens (or adjust if needed)
            response_modalities=["image", "text"], # Use lowercase "image" and include "text"
            response_mime_type="text/plain" # Add response_mime_type
        )

        # Log the image prompt here BEFORE making the API call
        current_app.logger.debug(f"generate_image (Gemini) - Sending prompt to API: '{prompt}'") # Log at DEBUG level

        response = await gemini_client.aio.models.generate_content( # Still using non-streaming for now
            model=gemini_image_model_name, # Model from env var
            contents=contents,
            config=generate_content_config # Use the configured config
        )

        image_part = None
        for part in response.candidates[0].content.parts:
            if part.inline_data is not None:
                image_part = part
                break # Assuming only one image part

        if not image_part:
            raise ValueError("No image data found in Gemini response")

        image_bytes = image_part.inline_data.data
        image = Image.open(BytesIO(image_bytes))


        unique_filename = f"generated_image_gemini_{uuid.uuid4().hex}.png" # Gemini specific filename
        unique_filename = sanitize_filename(unique_filename)
        static_folder = current_app.static_folder
        image_folder = os.path.join(static_folder, 'images')
        os.makedirs(image_folder, exist_ok=True)
        image_file_path = os.path.join(image_folder, unique_filename)
        image.save(image_file_path) # Save using Pillow

        web_path = os.path.join('images', unique_filename).replace("\\", "/")
        return web_path

    except Exception as e:
        current_app.logger.error(f"Error in generate_image (Gemini - Refactored Config): {e}", exc_info=True) # Updated log message
        raise

üü® utilities.py:
# utilities.py (Complete, Refactored - Version for SSPEC PossPath)
import io
import os
import re
import html
import json
import time # Keep if any time-related utilities are planned
import uuid
import logging
import warnings # Keep if warnings module is used explicitly
from uuid import uuid4, UUID # Ensure UUID is imported
from PIL import Image # Keep for image processing if any (not directly used here now)
from bs4 import BeautifulSoup
from dotenv import load_dotenv
from ce_nodes import get_valid_node_types # NODES definition is in ce_nodes.py
from flask import current_app, flash, render_template, url_for # Added url_for
import asyncio
import aiohttp # Keep if direct aiohttp calls are made (not in current scope)
# requests import was likely for old DALL-E, can be removed if not used elsewhere
# from google.generativeai import types # Used in ai_service.py, not directly here
from ai_service import generate_image # Import for Gemini image generation

load_dotenv()

# --- COS Analysis (Utility version - consider centralizing with speculate.analyze_cos) ---
async def analyze_cos(cos_content: str, cos_id: str = None) -> dict:
    """
    Analyzes COS content using AI to identify CEs.
    This version is kept in utilities.py as it might be called by routes.py.
    Returns: {'content_with_ce': <html_string_with_pills>, 'ces': [<ce_data_dict>, ...]}
    """
    from ai_service import generate_chat_response_with_node_types # Local import
    from ce_templates import replace_ce_tags_with_pills # Local import

    current_app.logger.debug(f"utilities.analyze_cos called for cos_id: {cos_id} with content: '{cos_content[:100]}...'")

    # AI Prompt to get text with <ce> tags AND a list of identified CEs
    prompt = (
        f"Analyze the following Condition of Satisfaction (COS) text: '{cos_content}'. "
        "Identify all Conditional Elements (CEs) within this text. "
        "A CE is a specific part of the COS that requires further detail or action. "
        f"For each CE found, determine its most appropriate 'NodeType' from this list ONLY: {', '.join(get_valid_node_types())}. "
        "Your response MUST be a valid JSON object with two keys: "
        "'analyzed_cos_text': This should be the original COS text but with each identified CE " # AI embeds tags
        "wrapped in <ce type='NodeType'>Your CE Text Here</ce> tags. "
        "And 'identified_ces': an array of objects, where each object represents a CE and has 'text' and 'type' keys. "
        "Example JSON: "
        '{'
        '  "analyzed_cos_text": "The <ce type=\'Research\'>literature review</ce> must be completed and <ce type=\'Stakeholder\'>key experts</ce> identified.",'
        '  "identified_ces": ['
        '    {"text": "literature review", "type": "Research"},'
        '    {"text": "key experts", "type": "Stakeholder"}'
        '  ]'
        '}'
    )

    messages = [
        {"role": "system", "content": "You are an expert in analyzing text to identify conditional elements and structure them in JSON. Ensure NodeTypes are from the provided list. The 'analyzed_cos_text' MUST include the <ce> tags."},
        {"role": "user", "content": prompt},
    ]
    response_text = ""
    try:
        response_text = await generate_chat_response_with_node_types(messages, role='COS Analysis', task='Analyze COS for CEs in Utilities')
        response_json = json.loads(response_text)

        ai_analyzed_text_with_tags = response_json.get("analyzed_cos_text", cos_content)
        # This list is for reference or if replace_ce_tags_with_pills needs it for metadata.
        # The pills themselves are generated from the tags in ai_analyzed_text_with_tags.
        ai_identified_ces_list = response_json.get("identified_ces", [])

        # `replace_ce_tags_with_pills` converts <ce> tags in `ai_analyzed_text_with_tags` to HTML pills
        # and generates unique data-ce-id for each.
        # The second argument (list of CEs) can be used for metadata like counts.
        ces_metadata_for_pills = []
        for item in ai_identified_ces_list:
            if item.get("type") in get_valid_node_types():
                ces_metadata_for_pills.append({
                    'content': item.get("text", ""),
                    'node_type': item.get("type")
                    # 'id' will be generated by replace_ce_tags_with_pills
                })
        
        content_with_pills_html = replace_ce_tags_with_pills(ai_analyzed_text_with_tags, ces_metadata_for_pills)
        
        # Extract structured CE data from the generated pills for the return value
        # This is what `routes.py`'s `/analyze_cos/<uuid:cos_id>` expects.
        final_ces_structure = []
        soup = BeautifulSoup(content_with_pills_html, 'html.parser')
        for pill_tag in soup.find_all('span', class_='ce-pill'):
            final_ces_structure.append({
                'id': pill_tag.get('data-ce-id'),
                'content': pill_tag.string.strip() if pill_tag.string else "",
                'node_type': pill_tag.get('data-ce-type'),
                'cos_id': cos_id # Link back if cos_id was provided
            })
            
        return {'content_with_ce': content_with_pills_html, 'ces': final_ces_structure}

    except json.JSONDecodeError as e:
        current_app.logger.error(f"JSONDecodeError in utilities.analyze_cos for cos_id {cos_id}. AI Response: '{response_text}'", exc_info=True)
        return {'content_with_ce': html.escape(cos_content), 'ces': []} # Fallback
    except Exception as e:
        current_app.logger.error(f"Exception in utilities.analyze_cos for cos_id {cos_id}: {e}", exc_info=True)
        return {'content_with_ce': html.escape(cos_content), 'ces': []}


# --- Outcome Data Generation ---
async def generate_outcome_data(USE_DATABASE: bool, request, method: str, selected_goal: str = None, domain: str = None, domain_icon: str = None, selected_goal_title: str = None):
    from ai_service import generate_chat_response # Local import
    from models import get_engine_and_session, SSOL # Local import
    from store import ssol_store # Local import
    from speculate import parse_ai_response_and_generate_html, create_ssol # Local import

    outcome_data = {
        'user_input': '',
        'selected_goal': selected_goal, # Detailed goal text
        'domain_icon': domain_icon,
        'domain': domain,
        'ssol_id': None, # Will be populated
        'ssol_summary': "Summary generation is pending or encountered an issue.",
        'ssol_title': selected_goal_title, # Catchy title
        'phases': {},
        'generated_image_path': url_for('static', filename='images/SSPEC_Logo_Motion.gif') # Default placeholder
    }

    user_input_from_form = request.form.get('user_text', '').strip() if method == 'POST' else request.args.get('user_text', '').strip()
    outcome_data['user_input'] = html.escape(user_input_from_form)

    # 1. Create SSOL Record and get its ID
    # `create_ssol` (from speculate.py) is synchronous and returns the string ID of the new SSOL.
    # It handles DB/in-memory logic.
    # Pass selected_goal_title as title and selected_goal (detailed text) as initial description.
    try:
        new_ssol_id_str = create_ssol(USE_DATABASE, title=selected_goal_title, description=selected_goal)
        outcome_data['ssol_id'] = new_ssol_id_str
        ssol_id_uuid_for_cos = UUID(new_ssol_id_str) # Convert to UUID for internal use
    except Exception as e:
        current_app.logger.error(f"Failed to create SSOL for title '{selected_goal_title}': {e}", exc_info=True)
        # This is a critical failure, can't proceed without SSOL.
        # Flash message and redirect or raise to be caught by route.
        raise ValueError(f"SSOL creation failed: {str(e)}") from e

    current_app.logger.info(f"SSOL created with ID: {new_ssol_id_str}. Generating outcome data for goal: '{selected_goal_title}'")

    # Sanitize display inputs (already done for user_input_from_form)
    selected_goal_display = html.escape(selected_goal) if selected_goal else ""
    domain_display = html.escape(domain) if domain else ""

    # 2. Generate Summary for the SSOL
    summary_prompt = (
        f"Generate a **detailed but concise summary** for the Structured Solution project: '{selected_goal_title}' (Full goal: '{selected_goal_display}'). "
        f"Consider the domain: {domain_display}. "
        f"This summary MUST provide a **comprehensive overview of the entire Structured Solution**, and **use basic HTML markup for formatting** to enhance readability. Include:\n"
        f"- **A high-level description of the project's overall goal and purpose**, formatted as a paragraph (`<p>`).\n"
        f"- **A brief overview of each of the five phases** of the Structured Solution highlighting the primary focus of each phase. **Format these phase overviews as an ordered list** (`<ol>`), with each phase description as a list item (`<li>`).\n"
        f"- **The anticipated overall outcome or impact** of successfully implementing the Structured Solution, formatted as a paragraph (`<p>`).\n"
        f"Imagine you are writing an **executive summary or abstract** for a project proposal or report that will be displayed on a webpage. "
        f"Aim for a summary that is approximately **1-2 paragraphs and an ordered list of 5 items (one for each phase)** to thoroughly introduce the SSPEC PossPath output and its key components to someone unfamiliar with the project. "
        f"**Allowed HTML tags are:** `<p>`, `<ol>`, `<li>`, `<b>`, `<strong>`, `<i>`, `<em>`. **Use these tags to structure and emphasize key parts of the summary.**\n"
        f"Return a JSON object with a SINGLE KEY 'summary', containing the summary text **with HTML markup**. "
    )
    summary_messages = [{"role": "user", "content": summary_prompt}]
    summary_response_text = ""
    try:
        current_app.logger.info(f"Generating summary for SSOL ID: {new_ssol_id_str}...")
        summary_response_text = await generate_chat_response(summary_messages, role='Outcome Summary', task='Generate SSOL Summary')
        summary_data = json.loads(summary_response_text)
        generated_summary_html = summary_data.get('summary', "Summary not available.")
        outcome_data['ssol_summary'] = generated_summary_html
        current_app.logger.info(f"Summary generation successful for SSOL ID: {new_ssol_id_str}.")

        # Update the SSOL record with the generated summary
        if USE_DATABASE:
            with current_app.app_context(): # Use current_app.app_context() for Flask context
                engine, SessionLocal = get_engine_and_session()
                session = SessionLocal()
                try:
                    ssol_to_update = session.query(SSOL).get(ssol_id_uuid_for_cos)
                    if ssol_to_update:
                        ssol_to_update.description = generated_summary_html # Assuming summary goes into description
                        session.commit()
                    else:
                        current_app.logger.warning(f"SSOL with ID {ssol_id_uuid_for_cos} not found in DB for summary update.")
                except Exception as db_exc:
                    session.rollback()
                    current_app.logger.error(f"DB error updating SSOL summary: {db_exc}", exc_info=True)
                finally:
                    session.close()
        else: # In-memory
            if new_ssol_id_str in ssol_store:
                ssol_store[new_ssol_id_str]['description'] = generated_summary_html
                ssol_store[new_ssol_id_str]['summary'] = generated_summary_html # Also store as summary for consistency
            else:
                current_app.logger.warning(f"SSOL with ID {new_ssol_id_str} not found in in-memory store for summary update.")

    except json.JSONDecodeError as e:
        current_app.logger.error(f"JSON decoding error for summary (SSOL {new_ssol_id_str}). AI Response: {summary_response_text}", exc_info=True)
        outcome_data['ssol_summary'] = f"Summary generation failed (JSON error). Raw output: {html.escape(summary_response_text)}"
    except Exception as e:
        current_app.logger.error(f"Error generating/updating summary (SSOL {new_ssol_id_str}): {e}", exc_info=True)
        outcome_data['ssol_summary'] = "Summary generation failed (unexpected error)."


    # 3. Generate Structured Solution (Phases, COS, and initial CEs)
    structured_solution_prompt = (
        f"You are an expert in structured problem-solving (SSPEC PossPath). Generate a concise Structured Solution for: '{selected_goal_title}' (Full goal: '{selected_goal_display}').\n"
        f"Organize into phases: Discovery, Engagement, Action, Completion, Legacy.\n"
        f"For EACH phase, generate 1-3 Conditions of Satisfaction (COS).\n"
        f"Within each COS sentence, embed 'Conditional Elements' (CEs) by wrapping them in `<ce type='NodeType'>CE Text</ce>` tags. "
        f"Valid 'NodeType' values: {', '.join(get_valid_node_types())}. Choose the most contextually appropriate NodeType.\n"
        f"Output a JSON object. Keys are phase names (e.g., \"Discovery\"). Values are arrays of COS objects.\n"
        f"Each COS object MUST have ONE key: 'content', with the full COS text including `<ce>` tags.\n"
        f"Example: {{ \"Discovery\": [{{\"content\": \"Identify <ce type='Stakeholder'>key groups</ce>.\"}}] }}\n"
        f"Ensure valid JSON. Do NOT include 'id' or 'status' for COS objects in this JSON output."
    )
    structured_solution_messages = [{"role": "user", "content": structured_solution_prompt}]
    structured_solution_response_text = ""
    try:
        current_app.logger.info(f"Generating structured solution (COS/CEs) for SSOL ID: {new_ssol_id_str}...")
        structured_solution_response_text = await generate_chat_response(structured_solution_messages, role='Structured Solution', task='Generate Phases and COS with CEs')
        structured_solution_json_from_ai = json.loads(structured_solution_response_text)

        if isinstance(structured_solution_json_from_ai, dict):
            # `parse_ai_response_and_generate_html` (from speculate.py) now handles:
            # - Taking AI's JSON of phases & COS (with <ce> tags in content)
            # - For each COS:
            #   - Generating a unique COS ID.
            #   - Calling `replace_ce_tags_with_pills` to convert <ce> tags to HTML pills (generating CE UUIDs).
            #   - Extracting CE data from these pills.
            #   - Saving the COS and its CEs to DB or in-memory store.
            # - Returns a dict like {'Discovery': [{'id': 'cos_uuid', 'content': 'html_with_pills', ...}, ...]}
            #   which is suitable for rendering outcome.html.
            outcome_data['phases'] = parse_ai_response_and_generate_html(
                USE_DATABASE,
                structured_solution_json_from_ai, # JSON from AI
                ssol_id_uuid_for_cos              # Parent SSOL's UUID
            )
            current_app.logger.info(f"Structured solution (COS/CEs) generated and saved for SSOL ID: {new_ssol_id_str}.")
        else:
            current_app.logger.error(f"Expected dict for structured solution, got {type(structured_solution_json_from_ai)}. AI Response: {structured_solution_response_text}")
            outcome_data['phases'] = {} # Fallback
    except json.JSONDecodeError as e:
        current_app.logger.error(f"JSON decoding error for structured solution (SSOL {new_ssol_id_str}). AI Response: {structured_solution_response_text}", exc_info=True)
        outcome_data['phases'] = {}
    except Exception as e:
        current_app.logger.error(f"Error generating/saving structured solution (SSOL {new_ssol_id_str}): {e}", exc_info=True)
        outcome_data['phases'] = {}

    current_app.logger.info(f"Outcome data generation process complete for SSOL ID: {new_ssol_id_str}.")
    return outcome_data


# --- User Input Analysis ---
async def analyze_user_input(text: str) -> list:
    from ai_service import generate_chat_response # Local import
    messages = [
        {"role": "system", "content": "You are an AI that analyzes user inputs and extracts relevant keywords. Respond with a JSON array of strings. Example: [\"keyword1\", \"keyword2\"]"},
        {"role": "user", "content": f"Extract keywords from: '{text}'"},
    ]
    response_text = ""
    try:
        response_text = await generate_chat_response(messages, role='Keyword Extraction', task='Extract Keywords', temperature=0.5)
        keywords = json.loads(response_text)
        if not isinstance(keywords, list):
            keywords = [str(kw).strip() for kw in response_text.split(',') if kw.strip()] # Fallback
            current_app.logger.warning(f"Keyword extraction AI response was not a list, used fallback. Response: {response_text}")
        current_app.logger.debug(f"Keywords for '{text}': {keywords}")
        return keywords
    except json.JSONDecodeError:
        current_app.logger.warning(f"JSONDecodeError extracting keywords. Response: {response_text}. Using split fallback.")
        return [kw.strip() for kw in response_text.split(',') if kw.strip()]
    except Exception as e:
        current_app.logger.error(f"Error in analyze_user_input: {e}", exc_info=True)
        return [text] # Fallback to returning the original text as a single "keyword"


async def generate_sentiment_analysis(text: str, temperature: float = 0.7) -> str:
    from ai_service import generate_chat_response # Local import
    messages = [
        {"role": "user", "content": f"What is the primary sentiment expressed in the following text: '{text}'? Respond with a single word: POSITIVE, NEGATIVE, or NEUTRAL, in a JSON object like {{ \"sentiment\": \"SENTIMENT_WORD\" }}."},
    ]
    response_text = ""
    sentiment = "NEUTRAL" # Default
    try:
        response_text = await generate_chat_response(messages, role='Sentiment Analysis', task='Analyze Sentiment', temperature=temperature)
        response_json = json.loads(response_text)
        sentiment_from_ai = response_json.get("sentiment", "NEUTRAL").upper()
        if sentiment_from_ai in ["POSITIVE", "NEGATIVE", "NEUTRAL"]:
            sentiment = sentiment_from_ai
        else:
            current_app.logger.warning(f"Sentiment analysis AI returned invalid sentiment '{sentiment_from_ai}'. Defaulting to NEUTRAL. Response: {response_text}")
            sentiment = "NEUTRAL"
    except json.JSONDecodeError:
        current_app.logger.warning(f"JSONDecodeError in sentiment analysis. Response: {response_text}. Attempting inference.")
        # Basic inference from raw text if it's simple
        if "POSITIVE" in response_text.upper(): sentiment = "POSITIVE"
        elif "NEGATIVE" in response_text.upper(): sentiment = "NEGATIVE"
        else: sentiment = "NEUTRAL"
    except Exception as e:
        current_app.logger.error(f"Error in generate_sentiment_analysis: {e}. Response: {response_text}", exc_info=True)
        sentiment = "NEUTRAL" # Fallback
    return sentiment


# --- Goal Generation ---
async def generate_goal(user_input: str) -> list:
    from ai_service import generate_chat_response # Local import

    system_message_content = (
        "You are an AI that generates three innovative and *distinct* goal outcomes based on user input. "
        "For EACH goal, you MUST provide: "
        "1. 'title': A short, enlivening title (3-7 words), catchy and enrolling. "
        "2. 'goal': A more detailed goal description (1-3 sentences). "
        "3. 'domain': A relevant general category (e.g., 'Technology', 'Health', 'Art', NOT a URL). "
        "4. 'icon': A corresponding FontAwesome 6 Solid (fas) icon class (e.g., 'fas fa-rocket'). "
        "Return a valid JSON array of exactly three objects. Each object MUST have 'title', 'goal', 'domain', and 'icon' keys. "
    )

    async def generate_single_set(temp: float):
        messages = [
            {"role": "user", "content": system_message_content + f"\n\nUser input for goal generation: '{user_input}'"},
        ]
        response_text = ""
        try:
            response_text = await generate_chat_response(messages, role='Goal Generation', task='Generate Goal Options', temperature=temp)
            goal_options = json.loads(response_text)
            if isinstance(goal_options, list) and \
               all(isinstance(g, dict) and all(k in g for k in ['title', 'goal', 'domain', 'icon']) for g in goal_options) and \
               len(goal_options) > 0: # Ensure at least one goal
                return goal_options[:3] # Return up to 3
            else:
                logging.warning(f"Invalid goal format/count from AI (temp {temp}). Response: {response_text}")
                return []
        except json.JSONDecodeError:
            logging.error(f"JSONDecodeError in generate_single_set (temp {temp}). Response: {response_text}")
            return []
        except Exception as e:
            logging.error(f"Error in generate_single_set (temp {temp}): {e}", exc_info=True)
            return []

    all_goals = await generate_single_set(temp=0.75)
    if not all_goals or len(all_goals) < 3: # Try another temp if first fails or gives too few
        logging.info("Retrying goal generation with different temperature.")
        more_goals = await generate_single_set(temp=0.6)
        # Simple merge and unique by title (preferring earlier results)
        seen_titles = {g['title'] for g in all_goals}
        for g in more_goals:
            if g['title'] not in seen_titles:
                all_goals.append(g)
                seen_titles.add(g['title'])
                if len(all_goals) >= 3: break
    
    if not all_goals:
        logging.error("AI goal generation failed after multiple attempts. Creating a basic fallback.")
        return [{
            'title': f"Define: {user_input[:30].strip()}",
            'goal': f"Clearly define and scope the possibility related to '{user_input}'.",
            'domain': "General",
            'icon': "fas fa-lightbulb"
        }]
    return all_goals[:3]


# --- Filename Sanitization ---
def sanitize_filename(filename: str) -> str:
    if not filename: return ""
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', filename)
    filename = re.sub(r'[\s]+', '_', filename)
    return filename[:100] # Keep filename length reasonable


# --- SSOL Image Generation & Naming ---
async def generate_ssol_image(prompt: str, ssol_id=None): # ssol_id can be string or UUID
    """
    Generates an image using ai_service.generate_image and attempts to rename it
    based on ssol_id for better organization.
    Returns the web path to the image.
    """
    try:
        # `generate_image` from `ai_service` returns a web path like 'images/unique_name.png'
        # or a default path if generation fails.
        temp_web_path = await generate_image(prompt)

        if temp_web_path == url_for('static', filename='images/sspec_default.png') or \
           temp_web_path == url_for('static', filename='images/SSPEC_Logo_Motion.gif'):
            current_app.logger.info(f"SSOL Image generation resulted in default image for prompt: {prompt[:50]}...")
            return temp_web_path # Return default path if AI generation failed or returned placeholder

        # If a unique image was generated and ssol_id is provided, try to rename
        if ssol_id:
            original_filename = os.path.basename(temp_web_path)
            original_fs_path = os.path.join(current_app.static_folder, 'images', original_filename)

            safe_ssol_id_part = sanitize_filename(str(ssol_id))
            _, extension = os.path.splitext(original_filename)
            if not extension: extension = '.png' # Default extension

            new_image_filename = f"ssol_image_{safe_ssol_id_part}{extension}"
            new_fs_path = os.path.join(current_app.static_folder, 'images', new_image_filename)
            
            try:
                if os.path.exists(original_fs_path):
                    # Ensure the target directory exists
                    os.makedirs(os.path.dirname(new_fs_path), exist_ok=True)
                    # If new_fs_path exists, remove it to avoid error on rename (Windows)
                    if os.path.exists(new_fs_path) and original_fs_path != new_fs_path:
                        os.remove(new_fs_path)
                    os.rename(original_fs_path, new_fs_path)
                    final_web_path = url_for('static', filename=f'images/{new_image_filename}')
                    current_app.logger.info(f"SSOL Image renamed to: {new_image_filename}")
                    return final_web_path
                else:
                    current_app.logger.warning(f"Original generated image {original_fs_path} not found for renaming based on SSOL ID {ssol_id}.")
                    return temp_web_path # Return the original uniquely named path
            except OSError as e:
                current_app.logger.error(f"Error renaming SSOL image for {ssol_id} from {original_filename} to {new_image_filename}: {e}", exc_info=True)
                return temp_web_path # Return original path on rename error
        else: # No ssol_id provided, return the uniquely generated path
            return temp_web_path

    except Exception as e:
        current_app.logger.error(f"Error in generate_ssol_image utility: {e}", exc_info=True)
        return url_for('static', filename='images/sspec_default.png') # Fallback to default


# --- SSOL ID Generation (Consider for deprecation if create_ssol is primary) ---
def generate_ssol_id(USE_DATABASE: bool, selected_goal_title: str) -> str:
    """
    Finds an existing SSOL by title or creates a new one (minimal) and returns its ID.
    NOTE: This might be redundant if speculate.create_ssol is the primary way to create SSOLs.
    """
    from models import SSOL, get_engine_and_session # Local import
    from store import ssol_store # Local import
    from app import app # For app_context

    if USE_DATABASE:
        with app.app_context():
            engine, SessionLocal = get_engine_and_session()
            session = SessionLocal()
            try:
                ssol_instance = session.query(SSOL).filter_by(title=selected_goal_title).first()
                if not ssol_instance:
                    current_app.logger.info(f"generate_ssol_id: No SSOL found for title '{selected_goal_title}', creating a new minimal one.")
                    new_id = uuid.uuid4()
                    ssol_instance = SSOL(id=new_id, title=selected_goal_title, description="Initial placeholder description.")
                    session.add(ssol_instance)
                    session.commit()
                    return str(new_id)
                return str(ssol_instance.id)
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"DB error in generate_ssol_id: {e}", exc_info=True)
                raise # Or return a specific error indicator
            finally:
                session.close()
    else: # In-memory
        for s_id, s_data in ssol_store.items():
            if s_data.get('title') == selected_goal_title:
                return s_id
        # Not found, create new minimal one
        current_app.logger.info(f"generate_ssol_id: No in-memory SSOL for title '{selected_goal_title}', creating new.")
        new_id_str = str(uuid.uuid4())
        ssol_store[new_id_str] = {
            'id': new_id_str,
            'title': selected_goal_title,
            'description': "Initial placeholder description.",
            'phases': {} # Initialize phases
        }
        return new_id_str


# --- Badge Class for Status ---
def get_badge_class_from_status(status: str) -> str:
   return {
       'Proposed': 'bg-info',
       'In Progress': 'bg-warning text-dark',
       'Completed': 'bg-success',
       'Rejected': 'bg-danger'
   }.get(status, 'bg-secondary') # Default if status is unexpected

üü© goal_selection.html:
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
  <h1>What is your Commitment?</h1>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Your Input</th>
        <th class="text-end">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="user-input"> <!-- This td itself is not ideal for direct text content if edit/save target specific children -->
          <span class="user-input-display">{{ user_input }}</span>
          <input type="text" class="form-control form-control-sm user-input-edit d-none" value="{{ user_input }}">
        </td>
        <td class="text-end">
          <button type="button" class="btn btn-primary btn-sm edit-user-input">Edit</button>
          <button type="button" class="btn btn-success btn-sm save-user-input d-none">Update</button>
          <button type="button" class="btn btn-danger btn-sm cancel-user-input d-none">Cancel</button>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    Based on your input, we have speculated three high-level outcomes.
    Please choose the one that is closest to your desired result, or click the "Speculate New Outcomes" button to
    generate a new set of possibilities.
  </p>
  <div class="row card-container">
    {% for goal in goals %}
      <div class="col-md-4 mb-4">
        <div class="card retro-futuristic-card text-center">
          <div class="card-body card-content">
            <div class="card-upper-content">
                <i class="{{ goal.icon }} fa-2x mb-3"></i>
                <p class="domain domain-text">{{ goal.domain | title }}</p>
                <div class="goal-description goal-text">
                    {{ goal.goal | replace('\n', '<br>') | safe }}
                </div>
            </div>
            <form action="/outcome" method="post" class="goal-selection-form">
              <input type="hidden" name="selected_goal" value="{{ goal.goal }}">
              <input type="hidden" name="domain" value="{{ goal.domain }}">
              <input type="hidden" name="domain_icon" value="{{ goal.icon }}">
              <input type="hidden" name="selected_goal_title" value="{{ goal.title }}">
              <button type="submit" class="btn btn-primary">Select</button>
            </form>
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
  <div class="text-center">
    <button type="button" class="btn btn-outline-primary" id="generate-new-goals">
      <span class="refresh-icon"><i class="fas fa-sync-alt"></i></span> Speculate New Outcomes</button>
  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Removed the large inline script block -->
<!-- All JavaScript logic will now be driven by goal_selection.js and base_functions.js -->
<script type="module" src="{{ url_for('static', filename='js/goal_selection.js') }}"></script>
{% endblock %}

üü¶ outcome.html:
{% extends 'base.html' %}

{% block content %}
<div class="container">
    <!-- Title Row (Spanning Full Width) -->
    <div class="row">
        <div class="col text-center">
            <h1 class="ssol-title">{{ ssol.ssol_title | safe }}</h1>
        </div>
    </div>

    <!-- Image and Domain Row -->
    <div class="row outcome-header">
        <div class="col-md-4 text-center">
            <!-- Image Wrapper to reserve space and manage aspect ratio -->
            <div class="image-wrapper">
                <img src="{{ url_for('static', filename='images/SSPEC_Logo_Motion.gif') }}" 
                     alt="Structured Solution Image" 
                     class="rounded mb-3 ssol-dynamic-image" 
                     id="ssolImageOutcome" 
                     onerror="this.onerror=null; this.src='{{ url_for('static', filename='images/sspec_default.png') }}'; this.alt='Error loading image. Displaying default.';">
            </div>
            <!-- Container for error messages -->
            <div id="image-error-container" class="mt-2 small text-danger"></div>

            <h2>Domain</h2>
            <i class="{{ ssol.domain_icon }} fa-3x mb-3"></i>
            <p class="domain domain-text text-center">{{ ssol.domain | title }}</p>
            <h2>Fulfilled Goal</h2>
            <p><strong>{{ ssol.selected_goal | safe }}</strong></p>
            <div id="ssol-goal" style="display: none;">{{ ssol.selected_goal | safe }}</div>
            <div class="text-center mt-4">
                <button id="save-as-pdf-button" data-ssol-id="{{ ssol_id }}" class="btn btn-info" title="Save as PDF">
                    <i class="fas fa-download me-2"></i>PDF
                </button>
            </div>
        </div>

        <!-- Summary Column -->
        <div class="col-md-8">
            <h1>Preliminary Structured Solution</h1>
            <p id="ssol-summary">{{ ssol.ssol_summary | safe }}</p>
        </div>
    </div>

    <!-- Phases & Conditions of Satisfaction Row (Table structure remains the same) -->
    <div class="row">
        <h1>Phases & Conditions of Satisfaction</h1>
        <div class="col">
            <div class="accordion mt-4" id="phase-accordion">
                {% for phase_name, cos_list in ssol.phases.items() %}
                <div class="accordion-item">
                    <h2 class="accordion-header phase-colors" id="heading-{{ phase_name | replace(' ', '_') }}">
                        <button
                            class="accordion-button"
                            type="button"
                            data-bs-toggle="collapse"
                            data-bs-target="#collapse-{{ phase_name | replace(' ', '_') }}"
                            aria-expanded="true" 
                            aria-controls="collapse-{{ phase_name | replace(' ', '_') }}"
                            style="background-color: var(--phase-{{ loop.index0 }});">
                            {{ phase_name | title }} PHASE
                        </button>
                    </h2>
                    <div
                        id="collapse-{{ phase_name | replace(' ', '_') }}"
                        class="accordion-collapse collapse show" 
                        aria-labelledby="heading-{{ phase_name | replace(' ', '_') }}"
                        data-bs-parent="#phase-accordion">
                        <div class="accordion-body phase-table-container" data-ssol-id="{{ ssol_id }}" style="border: 2px solid var(--phase-{{ loop.index0 }});">
                            {% if cos_list %}
                            <table class="table table-striped table-hover phase-table" id="{{ phase_name | replace(' ', '_') }}-table">
                                <thead>
                                    <tr>
                                        <th scope="col" style="width: 10%;">Status</th>
                                        <th scope="col" style="width: 40%;">Condition of Satisfaction</th>
                                        <th scope="col" style="width: 15%;">Accountable Party</th>
                                        <th scope="col" style="width: 15%;">Completion Date</th>
                                        <th scope="col" class="text-end actions-header" style="width: 20%;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for cos in cos_list %}
                                    <tr class="cos-row" data-cos-id="{{ cos.id }}" data-editing="false">
                                        <td class="status-cell align-middle">
                                            <span class="status-pill {{ cos.status | get_badge_class_from_status }}">{{ cos.status | upper }}</span>
                                        </td>
                                        <td class="cos-content-cell align-middle">
                                            <div class="cos-content-display">{{ cos.content | safe }}</div>
                                            <div class="cos-content-edit d-none">
                                                <textarea class="form-control form-control-sm cos-content-textarea" rows="3">{{ cos.content | striptags }}</textarea>
                                            </div>
                                        </td>
                                        <td class="cos-accountable-party-cell align-middle">
                                            <span class="cos-accountable-party-display">{{ cos.accountable_party or 'N/A' }}</span>
                                            <input type="text" class="form-control form-control-sm cos-accountable-party-edit d-none" value="{{ cos.accountable_party }}">
                                        </td>
                                        <td class="cos-completion-date-cell align-middle">
                                            <span class="cos-completion-date-display">{{ cos.completion_date or 'N/A' }}</span>
                                            <input type="date" class="form-control form-control-sm cos-completion-date-edit d-none" value="{{ cos.completion_date }}">
                                        </td>
                                        <td class="text-end actions-cell align-middle">
                                            <div class="btn-group cos-actions" role="group">
                                                <button class="btn btn-sm btn-primary edit-cos-button" title="Edit COS"><i class="fas fa-edit"></i></button>
                                                <button class="btn btn-sm btn-success update-cos-button d-none" title="Update COS"><i class="fas fa-check"></i></button>
                                                <button class="btn btn-sm btn-secondary cancel-cos-button d-none" title="Cancel Edit"><i class="fas fa-times"></i></button>
                                                <button class="btn btn-sm btn-danger delete-cos-button" title="Delete COS"><i class="fas fa-trash"></i></button>
                                                <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="{{ cos.id }}" title="Analyze COS"><i class="fas fa-search-plus"></i></button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                            <button class="btn btn-success btn-sm add-cos mt-2" data-phase="{{ phase_name | replace(' ', '_') }}">
                                <i class="fas fa-plus"></i> Add Condition of Satisfaction
                            </button>
                            {% else %}
                            <p>No Conditions of Satisfaction found for this phase.</p>
                            <button class="btn btn-success btn-sm add-cos mt-2" data-phase="{{ phase_name | replace(' ', '_') }}">
                                <i class="fas fa-plus"></i> Add Condition of Satisfaction
                            </button>
                            {% endif %}
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="errorModalLabel">Error</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">{{ error_message }}</div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Placeholder for dynamic modals -->
    <div id="dynamicModalContainer"></div>
</div>
{% endblock %}

{% block scripts %}
<script type="module" src="{{ url_for('static', filename='js/cos_table.js') }}"></script>
<script type="module" src="{{ url_for('static', filename='js/ce_table.js') }}"></script>
<script type="module" src="{{ url_for('static', filename='js/ce_cards.js') }}"></script>

<link href="https://unpkg.com/tabulator-tables@4.9.3/dist/css/tabulator.min.css" rel="stylesheet">
<script src="https://unpkg.com/tabulator-tables@4.9.3/dist/js/tabulator.min.js"></script>

<script type="module">
  document.addEventListener('DOMContentLoaded', () => {
    const ssolId = "{{ ssol_id }}";
    const ssolImageElement = document.getElementById('ssolImageOutcome'); // Unique ID for this image
    const imageErrorContainer = document.getElementById('image-error-container');

    // Initial state: Image is set to placeholder GIF by default in HTML src.
    // We will try to fetch the actual image.

    if (ssolImageElement) {
        fetch(`/get_ssol_image/${ssolId}`)
          .then(response => {
            if (!response.ok) {
              // Try to parse error from JSON, otherwise use status text
              return response.json().then(err => {
                throw new Error(err.error || err.message || `HTTP error! status: ${response.status}`);
              }).catch(() => { // If error is not JSON or other parsing error
                throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
              });
            }
            return response.json();
          })
          .then(data => {
            if (data.image_path && data.image_path !== "{{ url_for('static', filename='images/SSPEC_Logo_Motion.gif') }}" && !data.error) {
              // Valid custom image path received
              ssolImageElement.src = data.image_path;
              ssolImageElement.alt = "Structured Solution Image"; // Update alt text
              if (imageErrorContainer) imageErrorContainer.innerHTML = ''; // Clear previous errors
            } else if (data.error) {
              // Server explicitly reported an error or issue (e.g., image not ready)
              console.warn(`Image retrieval issue for SSOL ${ssolId}: ${data.error}`);
              if (imageErrorContainer) {
                imageErrorContainer.textContent = `Image notice: ${data.message || data.error}. Displaying default.`;
              }
              ssolImageElement.src = "{{ url_for('static', filename='images/sspec_default.png') }}";
              ssolImageElement.alt = "Default SSPEC Image (generation issue)";
            } else {
              // No specific image path, or it's the placeholder - use the static default
              ssolImageElement.src = "{{ url_for('static', filename='images/sspec_default.png') }}";
              ssolImageElement.alt = "Default SSPEC Image";
            }
          })
          .catch(error => {
            console.error('Error fetching or processing image data:', error);
            if (ssolImageElement) {
                ssolImageElement.src = "{{ url_for('static', filename='images/sspec_default.png') }}";
                ssolImageElement.alt = 'Error loading image. Displaying default.';
            }
            if(imageErrorContainer) {
                imageErrorContainer.textContent = 'Image loading failed: ' + error.message;
            }
          });
    }
  });
</script>

<script type="text/javascript">
    const NODES = {{ nodes | tojson }};
</script>
{% endblock %}

üü™ cos_table.js:
// cos_table.js (Refactored for Bootstrap Table Layout in outcome.html)
import { displayCEModal } from './ce_cards.js'; // For CE pill clicks

// --- Utility Functions ---
function getBadgeClassFromStatus(status) {
    switch (status) {
        case 'Proposed': return 'bg-info';
        case 'In Progress': return 'bg-warning text-dark';
        case 'Completed': return 'bg-success';
        case 'Rejected': return 'bg-danger';
        default: return 'bg-secondary';
    }
}

function handleApiResponse(response) {
    if (!response.ok) {
        return response.json().then(errorData => {
            const message = errorData.error || errorData.message || JSON.stringify(errorData);
            throw new Error(`Server responded with ${response.status}: ${message}`);
        });
    }
    return response.json();
}

// --- DOM Manipulation & State ---

/**
 * Stores the original values of a COS row before entering edit mode.
 * @param {HTMLTableRowElement} cosRow - The <tr> element representing the COS.
 */
function storeOriginalValues(cosRow) {
    const statusPill = cosRow.querySelector('.status-cell .status-pill');
    const contentDisplay = cosRow.querySelector('.cos-content-cell .cos-content-display');
    const accountablePartyDisplay = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-display');
    const completionDateDisplay = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-display');

    cosRow.dataset.originalValues = JSON.stringify({
        status: statusPill ? statusPill.textContent.trim().toUpperCase() : 'PROPOSED',
        contentHTML: contentDisplay ? contentDisplay.innerHTML : '', // Store raw HTML with CE pills
        accountableParty: accountablePartyDisplay ? accountablePartyDisplay.textContent.trim() : '',
        completionDate: completionDateDisplay ? completionDateDisplay.textContent.trim() : ''
    });
}

/**
 * Reverts a COS row to its original stored values after cancelling edit.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 */
function revertToOriginalValues(cosRow) {
    if (!cosRow.dataset.originalValues) return;
    const original = JSON.parse(cosRow.dataset.originalValues);

    // Restore Status
    const statusCell = cosRow.querySelector('.status-cell');
    if (statusCell) {
        statusCell.innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(original.status)}">${original.status}</span>`;
    }

    // Restore Content
    const contentDisplay = cosRow.querySelector('.cos-content-cell .cos-content-display');
    const contentEditDiv = cosRow.querySelector('.cos-content-cell .cos-content-edit');
    if (contentDisplay) contentDisplay.innerHTML = original.contentHTML;
    if (contentEditDiv) contentEditDiv.querySelector('textarea').value = stripHtmlForTextarea(original.contentHTML);


    // Restore Accountable Party
    const accPartyDisplay = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-display');
    const accPartyEditInput = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-edit');
    if (accPartyDisplay) accPartyDisplay.textContent = original.accountableParty;
    if (accPartyEditInput) accPartyEditInput.value = original.accountableParty;

    // Restore Completion Date
    const compDateDisplay = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-display');
    const compDateEditInput = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-edit');
    if (compDateDisplay) compDateDisplay.textContent = original.completionDate;
    if (compDateEditInput) compDateEditInput.value = original.completionDate;

    toggleEditModeUI(cosRow, false); // Switch back to display mode
}

/**
 * Updates the display of a COS row with new data from the server.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 * @param {object} cosData - The COS data object from the server.
 */
function updateRowDisplay(cosRow, cosData) {
    const statusCell = cosRow.querySelector('.status-cell');
    if (statusCell) { // Should always exist
        statusCell.innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(cosData.status)}">${cosData.status.toUpperCase()}</span>`;
    }

    const contentDisplay = cosRow.querySelector('.cos-content-cell .cos-content-display');
    if (contentDisplay) contentDisplay.innerHTML = cosData.content; // Assumes cosData.content has CE pills

    const accountablePartyDisplay = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-display');
    if (accountablePartyDisplay) accountablePartyDisplay.textContent = cosData.accountable_party || '';

    const completionDateDisplay = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-display');
    if (completionDateDisplay) completionDateDisplay.textContent = cosData.completion_date || '';

    initializeCEPillEventListeners(cosRow.querySelector('.cos-content-cell')); // Re-bind pills in the updated content
}


/**
 * Toggles the UI between display and edit mode for a COS row.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 * @param {boolean} editing - True for edit mode, false for display mode.
 */
function toggleEditModeUI(cosRow, editing) {
    cosRow.dataset.editing = editing.toString(); // For CSS state styling if needed

    // Toggle visibility of display spans and edit inputs/textareas
    const elementsToToggle = [
        { display: '.cos-content-display', edit: '.cos-content-edit' },
        { display: '.cos-accountable-party-display', edit: '.cos-accountable-party-edit' },
        { display: '.cos-completion-date-display', edit: '.cos-completion-date-edit' }
    ];

    elementsToToggle.forEach(pair => {
        const displayEl = cosRow.querySelector(pair.display);
        const editEl = cosRow.querySelector(pair.edit);
        if (displayEl) displayEl.classList.toggle('d-none', editing);
        if (editEl) editEl.classList.toggle('d-none', !editing);
    });

    // Handle status pill/dropdown
    const statusCell = cosRow.querySelector('.status-cell');
    const statusPill = statusCell.querySelector('.status-pill');
    const statusDropdown = statusCell.querySelector('select.status-edit-select');

    if (editing) {
        if (statusPill && !statusDropdown) { // Only create dropdown if it doesn't exist
            const currentStatus = statusPill.textContent.trim();
            statusPill.classList.add('d-none');
            // statusPill.style.display = 'none';
            statusCell.insertAdjacentHTML('beforeend', createStatusDropdown(currentStatus));
        }
    } else {
        if (statusDropdown) statusDropdown.remove();
        if (statusPill) statusPill.classList.remove('d-none');
        // if (statusPill) statusPill.style.display = '';
    }

    // Toggle action buttons
    cosRow.querySelector('.edit-cos-button').classList.toggle('d-none', editing);
    cosRow.querySelector('.update-cos-button').classList.toggle('d-none', !editing);
    cosRow.querySelector('.cancel-cos-button').classList.toggle('d-none', !editing);
    cosRow.querySelector('.delete-cos-button').classList.toggle('d-none', editing); // Hide delete in edit mode
    cosRow.querySelector('.analyze-cos-button').classList.toggle('d-none', editing); // Hide analyze in edit mode
}

/**
 * Helper to strip HTML for placing content into a textarea for plain text editing.
 * CE pills will be lost if not re-analyzed on save.
 * @param {string} htmlString
 * @returns {string} Plain text.
 */
function stripHtmlForTextarea(htmlString) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;
    return tempDiv.textContent || tempDiv.innerText || "";
}

/**
 * Creates the HTML for the status dropdown.
 * @param {string} selectedStatus - The currently selected status.
 * @returns {string} HTML string for the select element.
 */
function createStatusDropdown(selectedStatus) {
    const statuses = ['Proposed', 'In Progress', 'Completed', 'Rejected'];
    let optionsHtml = statuses.map(status =>
        `<option value="${status}"${status.toUpperCase() === selectedStatus.toUpperCase() ? ' selected' : ''}>${status}</option>`
    ).join('');
    return `<select class="form-select form-select-sm status-edit-select">${optionsHtml}</select>`;
}


// --- Event Handlers ---

/**
 * Handles clicks within the phase table body (event delegation).
 * @param {Event} event - The click event.
 */
function handlePhaseTableBodyClick(event) {
    const button = event.target.closest('button'); // Focus on button clicks
    if (!button) return;

    const cosRow = button.closest('.cos-row');
    if (!cosRow) return;

    const cosId = cosRow.dataset.cosId;

    if (button.classList.contains('edit-cos-button')) {
        event.preventDefault();
        if (cosRow.dataset.editing === 'true') return; // Already editing
        storeOriginalValues(cosRow);

        // Populate textarea with plain text from current display for editing
        const contentDisplay = cosRow.querySelector('.cos-content-cell .cos-content-display');
        const contentTextarea = cosRow.querySelector('.cos-content-cell .cos-content-edit textarea');
        if (contentDisplay && contentTextarea) {
            contentTextarea.value = stripHtmlForTextarea(contentDisplay.innerHTML);
        }
        // Populate other edit fields
        const accPartyDisplay = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-display');
        const accPartyEditInput = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-edit');
        if (accPartyDisplay && accPartyEditInput) accPartyEditInput.value = accPartyDisplay.textContent.trim();

        const compDateDisplay = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-display');
        const compDateEditInput = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-edit');
        if (compDateDisplay && compDateEditInput) compDateEditInput.value = compDateDisplay.textContent.trim();

        toggleEditModeUI(cosRow, true);

    } else if (button.classList.contains('update-cos-button')) {
        event.preventDefault();
        handleUpdateCOS(cosRow, cosId);
    } else if (button.classList.contains('cancel-cos-button')) {
        event.preventDefault();
        revertToOriginalValues(cosRow); // This also calls toggleEditModeUI(cosRow, false)
    } else if (button.classList.contains('delete-cos-button')) {
        event.preventDefault();
        handleDeleteCOS(cosRow, cosId);
    } else if (button.classList.contains('analyze-cos-button')) {
        event.preventDefault();
        handleAnalyzeCOS(button, cosRow, cosId);
    }
}

/**
 * Handles the update logic for a COS row.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 * @param {string} cosId - The ID of the COS.
 */
function handleUpdateCOS(cosRow, cosId) {
    const contentTextarea = cosRow.querySelector('.cos-content-cell .cos-content-edit textarea');
    // Sending plain text; backend needs to re-analyze for CE pills.
    const newContent = contentTextarea ? contentTextarea.value.trim() : '';

    const statusSelect = cosRow.querySelector('.status-cell select.status-edit-select');
    const newStatus = statusSelect ? statusSelect.value : cosRow.querySelector('.status-cell .status-pill').textContent.trim();

    const accountablePartyInput = cosRow.querySelector('.cos-accountable-party-cell .cos-accountable-party-edit');
    const newAccountableParty = accountablePartyInput ? accountablePartyInput.value.trim() : '';

    const completionDateInput = cosRow.querySelector('.cos-completion-date-cell .cos-completion-date-edit');
    const newCompletionDate = completionDateInput ? completionDateInput.value : '';

    const payload = {
        content: newContent, // Plain text, backend re-analyzes
        status: newStatus,
        accountable_party: newAccountableParty,
        completion_date: newCompletionDate
    };

    const updateButton = cosRow.querySelector('.update-cos-button');
    const originalButtonHtml = updateButton.innerHTML;
    updateButton.disabled = true;
    updateButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;

    fetch(`/update_cos/${cosId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify(payload)
    })
    .then(handleApiResponse)
    .then(data => {
        if (data.success && data.cos) {
            updateRowDisplay(cosRow, data.cos); // data.cos.content should have pills
            toggleEditModeUI(cosRow, false);
        } else {
            throw new Error(data.error || data.message || 'Update failed to return COS data.');
        }
    })
    .catch(error => {
        console.error('Error updating COS:', error);
        alert(`Error: ${error.message}`);
        // Optionally revert if critical error: revertToOriginalValues(cosRow);
    })
    .finally(() => {
        updateButton.disabled = false;
        updateButton.innerHTML = originalButtonHtml;
    });
}

/**
 * Handles deletion of a COS row.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 * @param {string} cosId - The ID of the COS.
 */
function handleDeleteCOS(cosRow, cosId) {
    if (confirm('Are you sure you want to delete this Condition of Satisfaction? This cannot be undone.')) {
        fetch(`/delete_cos/${cosId}`, {
            method: 'DELETE',
            headers: { 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(handleApiResponse)
        .then(data => {
            if (data.success) {
                cosRow.remove();
            } else {
                throw new Error(data.error || data.message || 'Deletion failed.');
            }
        })
        .catch(error => {
            console.error('Error deleting COS:', error);
            alert(`Error: ${error.message}`);
        });
    }
}

/**
 * Handles analysis of a COS row's content.
 * @param {HTMLButtonElement} analyzeButton - The analyze button.
 * @param {HTMLTableRowElement} cosRow - The <tr> element.
 * @param {string} cosId - The ID of the COS.
 */
function handleAnalyzeCOS(analyzeButton, cosRow, cosId) {
    const originalButtonHtml = analyzeButton.innerHTML;
    analyzeButton.disabled = true;
    analyzeButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;

    fetch(`/analyze_cos/${cosId}`, { // Route from routes.py
        headers: { 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest' }
    })
    .then(handleApiResponse)
    .then(data => {
        if (data.success && data.analysis_results && data.analysis_results.content_with_ce) {
            const contentDisplay = cosRow.querySelector('.cos-content-cell .cos-content-display');
            if (contentDisplay) {
                contentDisplay.innerHTML = data.analysis_results.content_with_ce;
                initializeCEPillEventListeners(contentDisplay); // Re-bind pills
            }
        } else {
            throw new Error(data.message || 'Analysis failed to return expected results.');
        }
    })
    .catch(error => {
        console.error('Error analyzing COS:', error);
        alert(`Analysis Failed: ${error.message}`);
    })
    .finally(() => {
        analyzeButton.disabled = false;
        analyzeButton.innerHTML = originalButtonHtml; // Restore original icon/text
    });
}

/**
 * Handles adding a new COS.
 * @param {Event} event - The click event from the "Add COS" button.
 */
function handleAddCOSButtonClick(event) {
    const button = event.currentTarget;
    const phaseNameIdentifier = button.dataset.phase; // e.g., "Discovery_Phase"
    const accordionBody = button.closest('.accordion-body');
    const ssolId = accordionBody ? accordionBody.dataset.ssolId : null;
    const table = accordionBody ? accordionBody.querySelector('table.phase-table') : null;
    const tbody = table ? table.tBodies[0] : null;

    if (!ssolId) {
        console.error('SSOL ID not found for adding COS.');
        alert('Cannot add COS: Critical data missing.');
        return;
    }

    const payload = {
        content: 'New Condition of Satisfaction - edit me!', // Default content
        status: 'Proposed',
        ssol_id: ssolId,
        // Optionally, you could send phase_name_identifier if backend uses it
    };

    button.disabled = true;
    const originalButtonText = button.innerHTML;
    button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Adding...`;

    fetch(`/create_cos`, { // This route needs to be implemented in routes.py
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify(payload)
    })
    .then(handleApiResponse)
    .then(data => {
        if (data.success && data.cos) {
            if (tbody) {
                const newRow = createCosTableRow(data.cos);
                tbody.appendChild(newRow);
            } else if (table) { // Table exists but no tbody (shouldn't happen with valid HTML)
                const newTbody = document.createElement('tbody');
                const newRow = createCosTableRow(data.cos);
                newTbody.appendChild(newRow);
                table.appendChild(newTbody);
            } else {
                // This case means no table existed (phase was empty)
                // We need to create the table structure
                const newTableHtml = `
                    <table class="table table-striped table-hover phase-table" id="${phaseNameIdentifier}-table">
                        <thead>
                            <tr>
                                <th scope="col" style="width: 10%;">Status</th>
                                <th scope="col" style="width: 40%;">Condition of Satisfaction</th>
                                <th scope="col" style="width: 15%;">Accountable Party</th>
                                <th scope="col" style="width: 15%;">Completion Date</th>
                                <th scope="col" class="text-end actions-header" style="width: 20%;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>`;
                const pTag = accordionBody.querySelector('p'); // "No COS found" paragraph
                if(pTag) pTag.remove();
                accordionBody.insertAdjacentHTML('afterbegin', newTableHtml); // Insert table at the top
                const newTbody = accordionBody.querySelector('table.phase-table tbody');
                if(newTbody){
                    const newRow = createCosTableRow(data.cos);
                    newTbody.appendChild(newRow);
                }
            }
        } else {
            throw new Error(data.error || data.message || 'Failed to create COS.');
        }
    })
    .catch(error => {
        console.error('Error creating COS:', error);
        alert(`Error: ${error.message}`);
    })
    .finally(() => {
        button.disabled = false;
        button.innerHTML = originalButtonText;
    });
}

/**
 * Creates a new <tr> element for a COS.
 * @param {object} cos - The COS data object.
 * @returns {HTMLTableRowElement} The new <tr> element.
 */
function createCosTableRow(cos) {
    const newRow = document.createElement('tr');
    newRow.classList.add('cos-row');
    newRow.dataset.cosId = cos.id;
    newRow.dataset.editing = 'false';

    // Ensure cos.content is defined, default to empty string if not
    const cosContentHtml = cos.content || '';
    // For textarea, strip HTML. Backend will re-analyze and add pills.
    const cosContentText = stripHtmlForTextarea(cosContentHtml);

    newRow.innerHTML = `
        <td class="status-cell align-middle">
            <span class="status-pill ${getBadgeClassFromStatus(cos.status)}">${cos.status.toUpperCase()}</span>
        </td>
        <td class="cos-content-cell align-middle">
            <div class="cos-content-display">${cosContentHtml}</div>
            <div class="cos-content-edit d-none">
                <textarea class="form-control form-control-sm cos-content-textarea" rows="3">${cosContentText}</textarea>
            </div>
        </td>
        <td class="cos-accountable-party-cell align-middle">
            <span class="cos-accountable-party-display">${cos.accountable_party || ''}</span>
            <input type="text" class="form-control form-control-sm cos-accountable-party-edit d-none" value="${cos.accountable_party || ''}">
        </td>
        <td class="cos-completion-date-cell align-middle">
            <span class="cos-completion-date-display">${cos.completion_date || ''}</span>
            <input type="date" class="form-control form-control-sm cos-completion-date-edit d-none" value="${cos.completion_date || ''}">
        </td>
        <td class="text-end actions-cell align-middle">
            <div class="btn-group cos-actions" role="group">
                <button class="btn btn-sm btn-primary edit-cos-button" title="Edit COS"><i class="fas fa-edit"></i></button>
                <button class="btn btn-sm btn-success update-cos-button d-none" title="Update COS"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-cos-button d-none" title="Cancel Edit"><i class="fas fa-times"></i></button>
                <button class="btn btn-sm btn-danger delete-cos-button" title="Delete COS"><i class="fas fa-trash"></i></button>
                <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="${cos.id}" title="Analyze COS"><i class="fas fa-search-plus"></i></button>
            </div>
        </td>
    `;
    initializeCEPillEventListeners(newRow.querySelector('.cos-content-cell')); // Init pills for the new row
    return newRow;
}


// --- CE Pill Click Handling ---
/**
 * Adds event listeners to CE pills.
 * @param {HTMLElement} parentElement - The parent element to search within for CE pills. Defaults to document.
 */
function initializeCEPillEventListeners(parentElement = document) {
    parentElement.querySelectorAll('.ce-pill').forEach(pill => {
        pill.removeEventListener('click', handleCEPillClick); // Prevent duplicates
        pill.addEventListener('click', handleCEPillClick);
    });
}

/**
 * Handles clicks on CE pills to open the CE modal.
 * @param {Event} event - The click event.
 */
function handleCEPillClick(event) {
    event.preventDefault(); // Prevent any default action if pill is inside a link
    const pill = event.currentTarget;
    const ceId = pill.dataset.ceId;

    if (!ceId) {
        console.warn('CE Pill clicked without a ce-id.');
        return;
    }

    const ceType = pill.dataset.ceType || "Default";
    const cosRow = pill.closest('.cos-row'); // Pills are inside cos-content-cell of a cos-row
    const cosContentDisplay = cosRow ? cosRow.querySelector('.cos-content-cell .cos-content-display') : null;
    // Send the entire HTML content of the COS, so the modal can display context with other pills
    const cosContextContent = cosContentDisplay ? cosContentDisplay.innerHTML : '';

    const accordionItem = cosRow ? cosRow.closest('.accordion-item') : null;
    const phaseButton = accordionItem ? accordionItem.querySelector('.accordion-header .accordion-button') : null;
    let phaseName = "Unknown Phase";
    if (phaseButton) {
        const buttonTextClone = phaseButton.cloneNode(true);
        buttonTextClone.querySelectorAll('.phase-progress-bar, .accordion-button-icon').forEach(el => el.remove()); // Remove non-text parts
        phaseName = buttonTextClone.textContent.trim().replace(/\s*PHASE\s*$/i, "").trim(); // Remove " PHASE" suffix
    }
    
    let phaseIndex = 0; // Default
    if (accordionItem) {
        const allAccordionItems = Array.from(accordionItem.parentElement.children);
        phaseIndex = allAccordionItems.indexOf(accordionItem);
    }


    const ssolGoalElement = document.querySelector('#ssol-goal');
    const ssolGoal = ssolGoalElement ? ssolGoalElement.textContent.trim() : "SSOL Goal Not Available";

    const payload = {
        ce_id: ceId,
        cos_content: cosContextContent, // Send the HTML for context
        phase_name: phaseName,
        phase_index: phaseIndex,
        ssol_goal: ssolGoal,
        // existing_ces: [] // Populate if you want to send other CEs from THIS COS for advanced context
    };

    fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(handleApiResponse)
    .then(data => {
        if (data.modal_html) {
            // displayCEModal is imported from ce_cards.js
            displayCEModal(data.modal_html, ceId, ceType, cosContextContent, phaseName, phaseIndex, data.ai_generated_data, ssolGoal);
        } else {
            throw new Error(data.error || 'Modal HTML content not found in response.');
        }
    })
    .catch(error => {
        console.error('Error fetching or displaying CE modal:', error);
        alert(`Error interacting with Conditional Element: ${error.message}`);
    });
}


// --- PDF Export ---
function triggerPdfExport(ssolId) {
    const printableElement = document.documentElement.cloneNode(true);

    // Remove scripts, action buttons, modals, edit fields for PDF
    const selectorsToRemove = [
        'script', '.cos-actions', '.add-cos', '#save-as-pdf-button',
        '.modal', '#dynamicModalContainer', '.cos-content-edit',
        '.cos-accountable-party-edit', '.cos-completion-date-edit',
        'select.status-edit-select', '#image-error-container'
    ];
    printableElement.querySelectorAll(selectorsToRemove.join(', ')).forEach(el => el.remove());

    // Ensure all accordions are shown open in PDF
    printableElement.querySelectorAll('.accordion-collapse').forEach(collapse => {
        collapse.classList.add('show');
        collapse.style.display = 'block'; // Force display if .show is not enough
    });
    printableElement.querySelectorAll('.accordion-button').forEach(button => {
        button.classList.remove('collapsed');
        button.setAttribute('aria-expanded', 'true');
    });

    // Ensure images use absolute paths
    printableElement.querySelectorAll('img').forEach(img => {
        if (img.src && !img.src.startsWith('http') && !img.src.startsWith('data:')) {
            try {
                img.src = new URL(img.getAttribute('src'), window.location.href).href;
            } catch (e) {
                console.warn("Could not convert image src to absolute URL:", img.src, e);
            }
        }
    });
    // Ensure static assets like CSS are correctly linked if needed by PDF generator,
    // though pdfkit usually handles this via the css parameter.

    const htmlContent = printableElement.outerHTML;
    const pdfButton = document.getElementById('save-as-pdf-button');
    const originalButtonHtml = pdfButton.innerHTML;
    pdfButton.disabled = true;
    pdfButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';

    fetch(`/save_as_pdf/${ssolId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ htmlContent: htmlContent })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => { throw new Error(err.error || `PDF generation failed: ${response.status}`); });
        }
        return response.blob();
    })
    .then(blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `SSPEC_Solution_${ssolId}.pdf`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    })
    .catch(error => {
        console.error('Error saving PDF:', error);
        alert(`PDF Export Error: ${error.message}`);
    })
    .finally(() => {
        pdfButton.disabled = false;
        pdfButton.innerHTML = originalButtonHtml;
    });
}

// --- Global Initialization ---
function initializePageEventListeners() {
    // Delegate clicks for COS row actions to the tbody of each phase table
    document.querySelectorAll('.phase-table tbody').forEach(tbody => {
        tbody.removeEventListener('click', handlePhaseTableBodyClick); // Remove first to avoid duplicates
        tbody.addEventListener('click', handlePhaseTableBodyClick);
    });

    // Attach listeners to "Add COS" buttons
    document.querySelectorAll('.add-cos').forEach(button => {
        button.removeEventListener('click', handleAddCOSButtonClick); // Remove first
        button.addEventListener('click', handleAddCOSButtonClick);
    });

    // Initialize CE pill listeners on the whole document initially
    initializeCEPillEventListeners(document);

    // PDF Export Button
    const savePdfButton = document.getElementById('save-as-pdf-button');
    if (savePdfButton) {
        savePdfButton.addEventListener('click', (event) => {
            event.preventDefault();
            const ssolId = savePdfButton.dataset.ssolId;
            if (!ssolId) {
                console.error('SSOL ID missing for PDF.');
                alert('Cannot generate PDF: SSOL ID is missing.');
                return;
            }
            triggerPdfExport(ssolId);
        });
    }
}

// Auto-initialize when the DOM is ready
document.addEventListener('DOMContentLoaded', initializePageEventListeners);

‚¨ú speculate.py:
# speculate.py (Complete and Refactored with async/await fixes)
import re
import os
import html
import json
import uuid
from uuid import UUID
import logging
from bs4 import BeautifulSoup
from flask import current_app
from ce_nodes import NODES, get_valid_node_types # Assuming NODES is defined here or imported
from ce_templates import replace_ce_tags_with_pills
from sqlalchemy.exc import SQLAlchemyError
from ai_service import generate_chat_response_with_node_types, generate_chat_response # Ensure these are correctly async

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- COS Analysis and CE Pill Generation ---
async def analyze_cos(cos_content: str, cos_id: str = None) -> dict:
    """
    Analyzes COS content using AI to identify CEs, and prepares content with CE pills.
    Returns a dictionary: {'content_with_ce': <html_string>, 'ces_data_list': [<ce_dict>, ...]}
    """
    prompt = (
        f"Analyze the following Condition of Satisfaction (COS) text: '{cos_content}'. "
        "Identify all Conditional Elements (CEs) within this text. "
        "A CE is a specific part of the COS that requires further detail or action. "
        f"For each CE found, determine its most appropriate 'NodeType' from this list ONLY: {', '.join(get_valid_node_types())}. "
        "Your response MUST be a valid JSON object with two keys: "
        "'analyzed_cos_text': This should be the original COS text but with each identified CE "
        "wrapped in <ce type='NodeType'>Your CE Text Here</ce> tags. " # Explicitly ask for tags in text
        "And 'identified_ces': an array of objects, where each object represents a CE and has 'text' and 'type' keys. "
        "Example JSON: "
        '{'
        '  "analyzed_cos_text": "The <ce type=\'Research\'>literature review</ce> must be completed and <ce type=\'Stakeholder\'>key experts</ce> identified.",'
        '  "identified_ces": ['
        '    {"text": "literature review", "type": "Research"},'
        '    {"text": "key experts", "type": "Stakeholder"}'
        '  ]'
        '}'
    ).format(cos_content=cos_content, valid_node_types_list=get_valid_node_types())


    messages = [
        {"role": "system", "content": "You are an expert in analyzing text to identify conditional elements and structure them in JSON. Ensure NodeTypes are from the provided list. The 'analyzed_cos_text' MUST include the <ce> tags."},
        {"role": "user", "content": prompt},
    ]
    response_text = "" # Initialize for logging in case of error
    try:
        response_text = await generate_chat_response_with_node_types(messages, role='COS Analysis', task='Analyze COS for CEs')
        response_json = json.loads(response_text)

        # Text from AI, now expected to have <ce> tags embedded by the AI
        ai_analyzed_text_with_tags = response_json.get("analyzed_cos_text", cos_content)
        
        # List of CEs identified by AI (primarily for data structuring if needed, pills come from tags)
        ai_identified_ces_list = response_json.get("identified_ces", [])

        # Convert ai_identified_ces_list to the structure expected by replace_ce_tags_with_pills if needed for metadata
        # (e.g., if replace_ce_tags_with_pills adds counts or 'new' indicators based on this list)
        ces_data_for_pills = []
        for ce_item in ai_identified_ces_list:
            if ce_item.get("type") in get_valid_node_types():
                ce_data = {
                    'content': ce_item.get("text", ""),
                    'node_type': ce_item.get("type")
                }
                if cos_id: # If cos_id is available, link it
                    ce_data['cos_id'] = cos_id
                # 'id' for CE pill will be generated by replace_ce_tags_with_pills
                ces_data_for_pills.append(ce_data)

        # `replace_ce_tags_with_pills` will find <ce type='...'> tags in `ai_analyzed_text_with_tags`
        # and replace them with interactive <span class="ce-pill" data-ce-id="..." ...> pills.
        # It will generate UUIDs for data-ce-id.
        # The `ces_data_for_pills` can be used by it to add metadata like counts to these pills.
        content_with_pills_html = replace_ce_tags_with_pills(ai_analyzed_text_with_tags, ces_data_for_pills)

        # For creating CE records, we need a list of CEs with their final text and type, and generated IDs
        # We can parse the `content_with_pills_html` to get these.
        final_ces_data_list = []
        soup = BeautifulSoup(content_with_pills_html, 'html.parser')
        for pill_tag in soup.find_all('span', class_='ce-pill'):
            final_ces_data_list.append({
                'id': pill_tag.get('data-ce-id'), # The UUID generated by replace_ce_tags_with_pills
                'content': pill_tag.string if pill_tag.string else "",
                'node_type': pill_tag.get('data-ce-type'),
                'cos_id': cos_id # Link back to the parent COS
            })
        
        return {'content_with_ce': content_with_pills_html, 'ces_data_list': final_ces_data_list}

    except json.JSONDecodeError as e:
        current_app.logger.error(f"JSONDecodeError in analyze_cos: {e}. AI Response: '{response_text}'", exc_info=True)
        # Fallback: return original content, no CEs identified
        return {'content_with_ce': html.escape(cos_content), 'ces_data_list': []}
    except Exception as e:
        current_app.logger.error(f"Exception in analyze_cos: {e}. AI Response: '{response_text}'", exc_info=True)
        return {'content_with_ce': html.escape(cos_content), 'ces_data_list': []}


# --- COS CRUD Operations ---
async def create_cos(USE_DATABASE: bool, ssol_id: UUID, content: str, status: str, accountable_party: str = None, completion_date=None) -> str:
    from models import COS, CE, get_engine_and_session
    from store import ce_store, cos_store
    from app import app # For app_context

    analysis_result = {} # Initialize for logging in case of error prior to its assignment
    try:
        new_cos_uuid = uuid.uuid4()
        cos_id_str = str(new_cos_uuid)

        analysis_result = await analyze_cos(content, cos_id_str)
        content_with_pills = analysis_result['content_with_ce']
        extracted_ces_data = analysis_result['ces_data_list'] # This list now contains 'id' for each CE pill

        if USE_DATABASE:
            with app.app_context():
                engine, session = get_engine_and_session()
                cos_instance = COS(
                    id=new_cos_uuid,
                    content=content_with_pills,
                    status=status,
                    accountable_party=accountable_party,
                    completion_date=completion_date,
                    ssol_id=ssol_id
                )
                session.add(cos_instance)

                for ce_data in extracted_ces_data:
                    ce_instance = CE(
                        id=UUID(ce_data['id']), # Use the ID from analysis_result (generated by replace_ce_tags_with_pills)
                        content=ce_data['content'],
                        node_type=ce_data['node_type'],
                        cos_id=new_cos_uuid # Link to the new COS
                    )
                    session.add(ce_instance)
                session.commit()
                session.close()
        else:
            cos_record = {
                'id': cos_id_str,
                'content': content_with_pills,
                'status': status,
                'ssol_id': str(ssol_id),
                'accountable_party': accountable_party,
                'completion_date': str(completion_date) if completion_date else None,
                'conditional_elements': [] # Will store CE dicts
            }
            cos_store[cos_id_str] = cos_record

            for ce_data in extracted_ces_data:
                ce_record = {
                    'id': ce_data['id'], # Use ID from analysis
                    'content': ce_data['content'],
                    'node_type': ce_data['node_type'],
                    'cos_id': cos_id_str
                }
                ce_store[ce_data['id']] = ce_record # Store CE by its own ID
                cos_record['conditional_elements'].append(ce_record)
        
        return cos_id_str

    except KeyError as e: # Should be less likely if analyze_cos is robust
        current_app.logger.error(f"KeyError in create_cos: {e}. Analysis result: {analysis_result}", exc_info=True)
        raise
    except Exception as e:
        current_app.logger.error(f"Error creating COS: {e}", exc_info=True)
        if USE_DATABASE and 'session' in locals() and session.is_active:
            session.rollback()
            session.close()
        raise


def get_cos_by_id(USE_DATABASE: bool, cos_id: UUID): # Expects UUID if DB, can be str if not
    from models import COS, get_engine_and_session
    from store import cos_store
    from app import app

    if USE_DATABASE:
        if not isinstance(cos_id, UUID): # Ensure it's UUID for DB query
            try:
                cos_id = UUID(str(cos_id))
            except ValueError:
                current_app.logger.error(f"Invalid UUID format for cos_id: {cos_id}")
                return None
        with app.app_context():
            engine, session = get_engine_and_session()
            cos = session.query(COS).get(cos_id)
            session.close()
            return cos
    else:
        return cos_store.get(str(cos_id))


async def update_cos_by_id(USE_DATABASE: bool, cos_id_param: UUID, updated_data: dict) -> dict:
    from models import COS, CE, get_engine_and_session
    from store import cos_store, ce_store
    from app import app

    analysis_result = {} # Initialize
    try:
        cos_id_uuid = cos_id_param # Already UUID from routes.py
        cos_id_str = str(cos_id_uuid)

        new_content_text = updated_data.get('content') # This is likely plain text from textarea
        content_with_pills_for_update = None
        new_ces_data_list_from_analysis = []

        if new_content_text is not None:
            # Re-analyze the plain text content to regenerate CE pills and CE data list
            analysis_result = await analyze_cos(new_content_text, cos_id_str)
            content_with_pills_for_update = analysis_result['content_with_ce']
            new_ces_data_list_from_analysis = analysis_result['ces_data_list']
            # Update the 'content' in updated_data to be the HTML with pills
            updated_data['content'] = content_with_pills_for_update
        
        if USE_DATABASE:
            with app.app_context():
                engine, session = get_engine_and_session()
                cos = session.query(COS).get(cos_id_uuid)
                if not cos:
                    session.close()
                    return {'success': False, 'message': f"COS {cos_id_str} not found.", 'status_code': 404}

                # Update standard COS fields (excluding 'content' if it was processed)
                for key, value in updated_data.items():
                    if key not in ['conditional_elements', 'id', 'ssol_id']: # Content already handled
                        setattr(cos, key, value)
                
                # If content was updated and re-analyzed, update CEs
                if new_content_text is not None:
                    # Strategy: Delete existing CEs for this COS, then add the new ones.
                    session.query(CE).filter_by(cos_id=cos_id_uuid).delete(synchronize_session=False)
                    session.flush() # Ensure deletes are processed before adds if there are constraints

                    for ce_data in new_ces_data_list_from_analysis:
                        new_ce_instance = CE(
                            id=UUID(ce_data['id']), # ID from analysis (generated by replace_ce_tags_with_pills)
                            content=ce_data['content'],
                            node_type=ce_data['node_type'],
                            cos_id=cos_id_uuid
                        )
                        session.add(new_ce_instance)
                
                session.commit()
                # Fetch fresh to_dict to include updated CEs relation
                updated_cos_dict = cos.to_dict()
                session.close()
                return {'success': True, 'cos': updated_cos_dict}
        else: # In-memory store
            cos_record = cos_store.get(cos_id_str)
            if not cos_record:
                return {'success': False, 'message': f"COS {cos_id_str} not found.", 'status_code': 404}

            # Update standard fields
            for key, value in updated_data.items():
                if key != 'conditional_elements': # content is handled if re-analyzed
                    cos_record[key] = value
            
            if new_content_text is not None:
                # Clear old CEs from ce_store and the cos_record's list
                if 'conditional_elements' in cos_record:
                    for old_ce in cos_record['conditional_elements']:
                        ce_store.pop(old_ce['id'], None)
                cos_record['conditional_elements'] = []

                # Add new CEs
                for ce_data in new_ces_data_list_from_analysis:
                    new_ce_dict = {
                        'id': ce_data['id'],
                        'content': ce_data['content'],
                        'node_type': ce_data['node_type'],
                        'cos_id': cos_id_str
                    }
                    ce_store[ce_data['id']] = new_ce_dict
                    cos_record['conditional_elements'].append(new_ce_dict)
            
            return {'success': True, 'cos': cos_record}

    except KeyError as e:
        current_app.logger.error(f"KeyError updating COS {cos_id_param}: {e}. Analysis result: {analysis_result}", exc_info=True)
        return {'success': False, 'message': f"Data error: {str(e)}", 'status_code': 400} # Or 500
    except Exception as e:
        current_app.logger.error(f"Error updating COS {cos_id_param}: {e}", exc_info=True)
        if USE_DATABASE and 'session' in locals() and session.is_active:
            session.rollback(); session.close()
        return {'success': False, 'message': f"Unexpected error: {str(e)}", 'status_code': 500}


def delete_cos_by_id(USE_DATABASE: bool, cos_id: UUID) -> bool: # Expects UUID
    from models import COS, CE, get_engine_and_session
    from store import cos_store, ce_store
    from app import app

    try:
        cos_id_uuid = cos_id # Already UUID from routes.py
        cos_id_str = str(cos_id_uuid)

        if USE_DATABASE:
            with app.app_context():
                engine, session = get_engine_and_session()
                # Delete associated CEs first due to foreign key constraints
                session.query(CE).filter_by(cos_id=cos_id_uuid).delete(synchronize_session=False)
                # Then delete the COS
                cos = session.query(COS).get(cos_id_uuid)
                if cos:
                    session.delete(cos)
                    session.commit()
                    session.close()
                    return True
                session.close()
                return False
        else:
            if cos_id_str in cos_store:
                # Also remove associated CEs from ce_store
                cos_record = cos_store.get(cos_id_str, {})
                for ce_data in cos_record.get('conditional_elements', []):
                    ce_store.pop(ce_data['id'], None)
                del cos_store[cos_id_str]
                return True
            return False
    except Exception as e:
        current_app.logger.error(f"Error deleting COS {cos_id}: {e}", exc_info=True)
        if USE_DATABASE and 'session' in locals() and session.is_active: # Check if session was defined and is active
            session.rollback()
            session.close()
        return False

# --- SSOL CRUD Operations (Example Stubs - Implement as needed) ---
def create_ssol(USE_DATABASE: bool, title: str, description: str) -> str:
    from models import SSOL, get_engine_and_session
    from store import ssol_store
    from app import app

    if USE_DATABASE:
        with app.app_context():
            engine, session = get_engine_and_session()
            new_ssol_uuid = uuid.uuid4()
            ssol = SSOL(id=new_ssol_uuid, title=title, description=description)
            session.add(ssol)
            session.commit()
            ssol_id_to_return = str(new_ssol_uuid)
            session.close()
            return ssol_id_to_return
    else:
        ssol_id = str(uuid.uuid4())
        ssol_store[ssol_id] = {'id': ssol_id, 'title': title, 'description': description, 'phases': {}} # Added phases
        return ssol_id

def get_ssol_by_id(USE_DATABASE: bool, ssol_id: UUID): # Expects UUID if DB
    from models import SSOL, get_engine_and_session
    from store import ssol_store
    from app import app
    if USE_DATABASE:
        if not isinstance(ssol_id, UUID): ssol_id = UUID(str(ssol_id))
        with app.app_context():
            engine, session = get_engine_and_session()
            ssol = session.query(SSOL).get(ssol_id)
            session.close()
            return ssol
    else:
        return ssol_store.get(str(ssol_id))

# --- CE CRUD Operations ---
def get_ce_by_id(USE_DATABASE: bool, ce_id: UUID): # Expects UUID if DB
    from models import CE, get_engine_and_session
    from store import ce_store
    from app import app
    try:
        if USE_DATABASE:
            if not isinstance(ce_id, UUID): ce_id = UUID(str(ce_id)) # Ensure UUID for DB
            with app.app_context():
                engine, session = get_engine_and_session()
                ce = session.query(CE).get(ce_id)
                session.close()
        else: # In-memory
            ce = ce_store.get(str(ce_id)) # Use string ID for dict key

        if not ce:
            # Log or raise a more specific "Not Found" if desired
            current_app.logger.debug(f"CE with ID {ce_id} not found (USE_DATABASE={USE_DATABASE}).")
        return ce
    except ValueError as e: # Handle invalid UUID format string
        current_app.logger.error(f"ValueError retrieving CE by ID {ce_id}: {e}")
        return None # Or raise
    except Exception as e:
        current_app.logger.error(f"Unexpected error retrieving CE by ID {ce_id}: {e}", exc_info=True)
        raise # Re-raise for higher level handling or return None


def create_ce(USE_DATABASE: bool, content: str, node_type: str, cos_id: UUID) -> str: # cos_id is UUID
    from models import CE, get_engine_and_session
    from store import ce_store
    from app import app

    new_ce_uuid = uuid.uuid4()
    ce_id_str = str(new_ce_uuid)

    if USE_DATABASE:
        with app.app_context():
            engine, session = get_engine_and_session()
            ce = CE(id=new_ce_uuid, content=content, node_type=node_type, cos_id=cos_id)
            session.add(ce)
            session.commit()
            session.close()
    else:
        ce_data = {'id': ce_id_str, 'content': content, 'node_type': node_type, 'cos_id': str(cos_id)}
        ce_store[ce_id_str] = ce_data
    return ce_id_str


def update_ce_by_id(USE_DATABASE: bool, ce_id: UUID, ce_data: dict) -> bool: # Expects UUID
    from models import CE, get_engine_and_session
    from store import ce_store
    from app import app

    ce_id_uuid = ce_id # Already UUID from routes.py
    ce_id_str = str(ce_id_uuid)

    if USE_DATABASE:
        with app.app_context():
            engine, session = get_engine_and_session()
            ce = session.query(CE).get(ce_id_uuid)
            if ce:
                for key, value in ce_data.items():
                    if hasattr(ce, key) and key not in ['id', 'cos_id']: # Don't update PK or FK directly
                        setattr(ce, key, value)
                session.commit()
                session.close()
                return True
            session.close()
            return False
    else:
        if ce_id_str in ce_store:
            ce_store[ce_id_str].update(ce_data)
            return True
        return False

def delete_ce_by_id(USE_DATABASE: bool, ce_id: UUID) -> bool: # Expects UUID
    from models import CE, get_engine_and_session
    from store import ce_store
    from app import app
    
    ce_id_uuid = ce_id # Already UUID from routes.py
    ce_id_str = str(ce_id_uuid)

    if USE_DATABASE:
        with app.app_context():
            engine, session = get_engine_and_session()
            ce = session.query(CE).get(ce_id_uuid)
            if ce:
                session.delete(ce)
                session.commit()
                session.close()
                return True
            session.close()
            return False
    else:
        return bool(ce_store.pop(ce_id_str, None))


# --- Initial SSOL Generation Logic ---
def parse_ai_response_and_generate_html(USE_DATABASE: bool, response_json: dict, ssol_id_for_cos: UUID) -> dict:
    """
    Parses AI response for phases and COS, generates CE pills, and structures data.
    This function is called during initial SSOL creation.
    It PREPARES the data structure including CE pills. Actual DB save for COS/CE happens elsewhere (e.g., in create_cos).
    However, if this is part of a larger initial save, it can create CE records if needed.
    For initial generation, CEs are created based on tags in AI content.
    """
    from models import COS, CE, get_engine_and_session # Local import if creating DB records here
    from store import cos_store, ce_store            # Local import for in-memory
    from app import app                          # For app_context

    structured_solution = {}
    expected_phases = ["Discovery", "Engagement", "Action", "Completion", "Legacy"]

    # This ssol_id_for_cos is the ID of the SSOL these COS objects will belong to.
    # It's NOT the COS ID itself.

    for phase_name in expected_phases:
        structured_solution[phase_name] = []
        cos_list_from_ai = response_json.get(phase_name, [])

        for cos_dict_from_ai in cos_list_from_ai:
            # Each COS gets a new unique ID
            cos_uuid = uuid.uuid4()
            cos_id_str = str(cos_uuid)
            
            # Raw content from AI, expected to have <ce type="...">...</ce> tags
            raw_cos_content_from_ai = cos_dict_from_ai.get('content', '')

            # Use replace_ce_tags_with_pills to convert <ce> tags to <span class="ce-pill" data-ce-id="...">
            # This will generate unique UUIDs for data-ce-id attributes on the pills.
            # The second argument (list of CEs) to replace_ce_tags_with_pills is for metadata like counts,
            # which isn't typically available at this initial generation stage from this specific AI prompt.
            # So, we pass an empty list for that.
            content_with_html_pills = replace_ce_tags_with_pills(raw_cos_content_from_ai, [])

            # Now, extract the CE data (including their generated UUIDs) from the HTML with pills
            ces_for_this_cos_data = []
            soup = BeautifulSoup(content_with_html_pills, 'html.parser')
            for pill_tag in soup.find_all('span', class_='ce-pill'):
                ce_pill_id_str = pill_tag.get('data-ce-id')
                ce_content_text = pill_tag.string if pill_tag.string else ""
                ce_node_type = pill_tag.get('data-ce-type')

                if ce_pill_id_str and ce_node_type: # Basic validation
                    ce_data_item = {
                        'id': ce_pill_id_str, # This is the CE's own ID (from pill)
                        'content': ce_content_text,
                        'node_type': ce_node_type,
                        'cos_id': cos_id_str # Link to the parent COS ID we just generated
                    }
                    ces_for_this_cos_data.append(ce_data_item)

                    # PERSIST CE to DB or In-Memory Store HERE during initial SSOL generation
                    if USE_DATABASE:
                        with app.app_context(): # Ensure context for DB operations
                            engine, session = get_engine_and_session()
                            ce_instance = CE(
                                id=UUID(ce_pill_id_str),
                                content=ce_content_text,
                                node_type=ce_node_type,
                                cos_id=cos_uuid # Use the UUID of the parent COS
                            )
                            session.add(ce_instance)
                            # Commit for CEs could happen after all COS for this SSOL, or per COS
                            # For now, let's assume a commit will happen after this function or per SSOL.
                            # If committing here: session.commit() then session.close()
                    else:
                        ce_store[ce_pill_id_str] = ce_data_item


            # Structure for the COS to be added to the SSOL's phase
            # This COS itself is not yet saved if using DB, only its CEs are staged/saved above.
            # The actual COS record for DB will be created by the calling function (e.g. generate_outcome_data -> which should call create_cos)
            # This function prepares the structure that `generate_outcome_data` will use.
            
            # Store the COS in the appropriate data store
            # The ID for this COS is cos_id_str (or cos_uuid)
            # The accountable_party and completion_date are not typically generated by this AI call,
            # so they'd be empty/None initially.
            if USE_DATABASE:
                with app.app_context():
                    engine, session = get_engine_and_session()
                    new_cos_db = COS(
                        id=cos_uuid,
                        content=content_with_html_pills,
                        status='Proposed',
                        ssol_id=ssol_id_for_cos, # Link to parent SSOL
                        accountable_party=None,
                        completion_date=None
                        # CEs are linked via their own cos_id pointing to this cos_uuid
                    )
                    session.add(new_cos_db)
                    # Defer commit to allow all parts of SSOL to be added in one transaction
            else: # In-memory
                 cos_store[cos_id_str] = {
                    'id': cos_id_str,
                    'content': content_with_html_pills,
                    'status': 'Proposed',
                    'ssol_id': str(ssol_id_for_cos),
                    'accountable_party': None,
                    'completion_date': None,
                    'conditional_elements': ces_for_this_cos_data # Store list of CE dicts
                }


            # Add to the structured_solution for returning to `generate_outcome_data`
            # This dict is what gets rendered in `outcome.html`
            structured_solution[phase_name].append({
                'id': cos_id_str, # ID of this COS
                'content': content_with_html_pills, # HTML content with CE pills
                'status': 'Proposed', # Default status
                'accountable_party': None, # Default
                'completion_date': None,   # Default
                # 'ces': ces_for_this_cos_data # This was how it was before, but conditional_elements is the model field.
                                             # For rendering, `cos.content` has the pills.
                                             # If JS needs separate list of CEs, this can be added.
                                             # The `to_dict()` method of COS model will provide `conditional_elements`
            })
    
    # If using DB, the session that added all these COS and CE instances
    # should be committed by the calling function (e.g., in generate_outcome_data or after it).
    if USE_DATABASE:
        with app.app_context():
            engine, session = get_engine_and_session()
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing initial SSOL COS/CEs: {e}", exc_info=True)
                raise
            finally:
                session.close()

    return structured_solution

üü´ ce_table.js:
import { displayCEModal } from './ce_cards.js';

function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  const ceType = event.currentTarget.dataset.ceType || "Default";
  const cosContent = event.target.closest('tr').querySelector('.cos-content-cell').textContent.trim();
  const phaseElement = event.target.closest('.accordion-item');
  const phaseName = phaseElement.querySelector('.accordion-header button').innerText.trim();
  const phaseIndex = Array.from(phaseElement.parentElement.children).indexOf(phaseElement);

  const requestData = {
    ce_id: ceId,
    cos_content: cosContent,
    phase_name: phaseName,
    phase_index: phaseIndex,
    ssol_goal: document.querySelector('#ssol-goal').textContent.trim()
  };

  fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestData)
  })
  .then(response => response.json())
  .then(data => {
    if (data && data.modal_html) {
      displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, data.ai_generated_data);
    } else {
      throw new Error('Modal HTML content not found or error in response');
    }
  })
  .catch(error => console.error('Error fetching modal content:', error));
}


function handleSaveButtonClick(event, row) {
  const ceContentInput = row.querySelector('.ce-content-input');
  const newContent = ceContentInput.value.trim();
  const ceId = row.dataset.ceId;
  // Send the updated content to the server
  fetch(`/update_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId, content: newContent}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the update was successful
    if (data.success) {
      // Update the UI to show the new content
      const ceContentCell = row.querySelector('.ce-content-cell');
      ceContentCell.textContent = newContent;
      // Change the "Save" button back to an "Edit" button
      const editButton = row.querySelector('.edit-ce-button');
      editButton.classList.remove('d-none');
      event.target.classList.add('d-none');
    } else {
      console.error('Error updating CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleDeleteButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send a delete request to the server
  fetch(`/delete_cos`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({cos_id: ceId}),
  })
  .then(response => response.json())
  .then(data => {
    // Check if the delete was successful
    if (data.success) {
      // Remove the row from the table
      row.remove();
    } else {
      console.error('Error deleting CE:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

function handleAnalyzeButtonClick(event) {
  const row = event.target.closest('tr');
  const ceId = row.dataset.ceId;
  // Send the COS/CE content to the server for analysis
  fetch(`/analyze_cos/${ceId}`)
  .then(response => response.json())
  .then(data => {
    // Display the analysis results
    if (data.analysis_results) { // Corrected: Check for data.analysis_results instead of data.analyzed_cos (based on routes.py response)
      // Update the UI with the analyzed data
      const cosContentCell = row.querySelector('.cos-content-cell');
      cosContentCell.innerHTML = data.analysis_results.content_with_ce;
      initializeCEPillEventListeners(); // Re-initialize CE pill event listeners after content update
    } else {
      console.error('Error analyzing COS:', data.error);
    }
  })
  .catch(error => console.error('Error:', error));
}

export { handleCEPillClick }; // Only export handleCEPillClick, other functions are internal to this module.

üè≥Ô∏è‚Äçüåà ce_nodes.py:
NODES = {  
    "Default": {  
        "definition": "This node is a default research mode for undefined node types.",  
        "icon": "fa-solid fa-icons",  
        "modal_config": {  
            "fields": [  
                {"type": "text", "name": "subject", "placeholder": "Subject"},  
                {"type": "textarea", "name": "details", "placeholder": "Details"},  
                {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}  
            ],  
            "explanation": "Default Resource Node.",  
            "ai_context": "Provide general information and suggestions to help achieve the Condition of Satisfaction (COS)."  
        },  
        "tabulator_config": {  
            "columns": [  
                {"title": "Subject", "field": "subject", "editor": "input"},  
                {"title": "Details", "field": "details", "editor": "input"},  
                {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}  
            ]  
        }  
    },  
    "Research": {  
        "definition": "Aggregates and summarizes research materials and resources pertinent to the COS.",  
        "icon": "fa-solid fa-flask",  
        "modal_config": {  
            "fields": [  
                {"type": "text", "name": "research_topic", "placeholder": "Research Topic"},  
                {"type": "textarea", "name": "research_summary", "placeholder": "Research Summary"},  
                {"type": "text", "name": "research_website", "placeholder": "Research Website"}  
            ],  
            "explanation": "Capture relevant research aspects of the node.",  
            "ai_context": "Provide detailed research information, studies, and academic resources relevant to the COS."  
        },  
        "tabulator_config": {  
            "columns": [  
                {"title": "Research Topic", "field": "research_topic", "editor": "input"},  
                {"title": "Research Summary", "field": "research_summary", "editor": "textarea"},  
                {"title": "Research Website", "field": "research_website", "editor": "input"}  
            ]  
        }  
    },  
    "Stakeholder": {
        "definition": "Captures details of stakeholders involved in the COS.",
        "icon": "fa-solid fa-user-friends",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "stakeholder_name", "placeholder": "Stakeholder Name"},
                {"type": "textarea", "name": "stakeholder_role", "placeholder": "Stakeholder Role"},
                {"type": "email", "name": "stakeholder_email", "placeholder": "Stakeholder Email"},
                {"type": "text", "name": "stakeholder_phone", "placeholder": "Stakeholder Phone"},
            ],
            "explanation": "Detail the roles and contact information of stakeholders related to the COS.",
            "ai_context": "Identify and provide details of stakeholders involved in the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Stakeholder Name", "field": "stakeholder_name", "editor": "input"},
                {"title": "Stakeholder Role", "field": "stakeholder_role", "editor": "textarea"},
                {"title": "Stakeholder Email", "field": "stakeholder_email", "editor": "input"},
                {"title": "Stakeholder Phone", "field": "stakeholder_phone", "editor": "input"},
            ]
        }
    },
    "Advocacy": {  
    "definition": "Focuses on efforts to influence public policy and resource allocation decisions.",  
    "icon": "fa-solid fa-bullhorn",  
    "modal_config": {  
        "fields": [  
            {"type": "text", "name": "campaign_name", "placeholder": "Campaign Name"},  
            {"type": "textarea", "name": "campaign_objective", "placeholder": "Campaign Objective"},  
            {"type": "text", "name": "target_audience", "placeholder": "Target Audience"}  
        ],  
        "explanation": "Detail the advocacy campaign's objectives and target audience.",  
        "ai_context": "Provide information on advocacy efforts and campaign strategies pertinent to the COS."  
    },  
    "tabulator_config": {  
        "columns": [  
            {"title": "Campaign Name", "field": "campaign_name", "editor": "input"},  
            {"title": "Campaign Objective", "field": "campaign_objective", "editor": "textarea"},  
            {"title": "Target Audience", "field": "target_audience", "editor": "input"}  
        ]  
    }
    },

    "Resource": {
        "definition": "Lists resources or assets essential for achieving the COS.",
        "icon": "fa-solid fa-tools",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "resource_name", "placeholder": "Resource Name"},
                {"type": "textarea", "name": "resource_details", "placeholder": "Resource Details"},
                {"type": "text", "name": "resource_type", "placeholder": "Resource Type"}
            ],
            "explanation": "Provide details about resources or assets required for the COS.",
            "ai_context": "List and detail resources or assets essential for achieving the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Resource Name", "field": "resource_name", "editor": "input"},
                {"title": "Resource Details", "field": "resource_details", "editor": "textarea"},
                {"title": "Resource Type", "field": "resource_type", "editor": "input"}
            ]
        }
    },
    "Praxis": {
        "definition": "Defines actions or tasks necessary to meet the COS.",
        "icon": "fa-solid fa-tasks",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "action_name", "placeholder": "Action Name"},
                {"type": "textarea", "name": "action_description", "placeholder": "Action Description"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ],
            "explanation": "Specify tasks or actions required to fulfill the COS.",
            "ai_context": "Detail actions or tasks necessary to meet the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Action Name", "field": "action_name", "editor": "input"},
                {"title": "Action Description", "field": "action_description", "editor": "textarea"},
                {"title": "Responsible Person", "field": "responsible_person", "editor": "input"}
            ]
        }
    },
    "Timeline": {
        "definition": "Specifies time frames or deadlines associated with the COS.",
        "icon": "fa-solid fa-clock",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "time_frame", "placeholder": "Time Frame"},
                {"type": "date", "name": "start_date", "placeholder": "Start Date"},
                {"type": "date", "name": "end_date", "placeholder": "End Date"}
            ],
            "explanation": "Provide time-related information such as deadlines and schedules for the COS.",
            "ai_context": "Detail time frames or deadlines associated with the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Time Frame", "field": "time_frame", "editor": "input"},
                {"title": "Start Date", "field": "start_date", "editor": "input"},
                {"title": "End Date", "field": "end_date", "editor": "input"}
            ]
        }
    },
    "Collaboration": {
        "definition": "Focuses on partnerships or collaboration efforts necessary for the COS.",
        "icon": "fa-solid fa-handshake",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "partner_name", "placeholder": "Partner Name"},
                {"type": "textarea", "name": "collaboration_details", "placeholder": "Collaboration Details"},
                {"type": "text", "name": "contact_person", "placeholder": "Contact Person"}
            ],
            "explanation": "Outline collaboration efforts and partnerships related to the COS.",
            "ai_context": "Detail partnerships or collaboration efforts necessary for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Partner Name", "field": "partner_name", "editor": "input"},
                {"title": "Collaboration Details", "field": "collaboration_details", "editor": "textarea"},
                {"title": "Contact Person", "field": "contact_person", "editor": "input"}
            ]
        }
    },
    "Policy": {
        "definition": "Addresses policy or regulatory aspects pertinent to the COS.",
        "icon": "fa-solid fa-gavel",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "policy_name", "placeholder": "Policy Name"},
                {"type": "textarea", "name": "policy_details", "placeholder": "Policy Details"},
                {"type": "text", "name": "regulatory_body", "placeholder": "Regulatory Body"}
            ],
            "explanation": "Detail policies or regulations impacting the COS.",
            "ai_context": "Provide information on policies or regulatory aspects pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Policy Name", "field": "policy_name", "editor": "input"},
                {"title": "Policy Details", "field": "policy_details", "editor": "textarea"},
                {"title": "Regulatory Body", "field": "regulatory_body", "editor": "input"}
            ]
        }
    },
    "Legislation": {
        "definition": "Covers legal considerations or requirements pertinent to the COS.",
        "icon": "fa-solid fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "legal_requirements", "placeholder": "Legal Requirements"},
                {"type": "text", "name": "relevant_legislation", "placeholder": "Relevant Legislation"},
                {"type": "text", "name": "compliance_officer", "placeholder": "Compliance Officer"}
            ],
            "explanation": "Detail legal considerations and requirements for the COS.",
            "ai_context": "Provide information on legal considerations or requirements pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Legal Requirements", "field": "legal_requirements", "editor": "textarea"},
                {"title": "Relevant Legislation", "field": "relevant_legislation", "editor": "input"},
                {"title": "Compliance Officer", "field": "compliance_officer", "editor": "input"}
            ]
        }
    },
    "Environment": {
        "definition": "Addresses environmental factors related to the COS.",
        "icon": "fa-solid fa-leaf",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "environmental_factor", "placeholder": "Environmental Factor"},
                {"type": "textarea", "name": "impact_assessment", "placeholder": "Impact Assessment"},
                {"type": "text", "name": "mitigation_strategy", "placeholder": "Mitigation Strategy"}
            ],
            "explanation": "Detail environmental factors and their impact on the COS.",
            "ai_context": "Provide information on environmental factors and impact assessments pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Environmental Factor", "field": "environmental_factor", "editor": "input"},
                {"title": "Impact Assessment", "field": "impact_assessment", "editor": "textarea"},
                {"title": "Mitigation Strategy", "field": "mitigation_strategy", "editor": "input"}
            ]
        }
    },
    "Risk": {
        "definition": "Identifies potential risks and mitigation strategies for the COS.",
        "icon": "fa-solid fa-exclamation-triangle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "risk_name", "placeholder": "Risk Name"},
                {"type": "textarea", "name": "risk_description", "placeholder": "Risk Description"},
                {"type": "text", "name": "mitigation_plan", "placeholder": "Mitigation Plan"}
            ],
            "explanation": "Detail potential risks and strategies to mitigate them for the COS.",
            "ai_context": "Identify potential risks and provide mitigation strategies for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Risk Name", "field": "risk_name", "editor": "input"},
                {"title": "Risk Description", "field": "risk_description", "editor": "textarea"},
                {"title": "Mitigation Plan", "field": "mitigation_plan", "editor": "input"}
            ]
        }
    },
    "Opportunity": {
        "definition": "Identifies opportunities that can enhance the COS.",
        "icon": "fa-solid fa-lightbulb",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "opportunity_name", "placeholder": "Opportunity Name"},
                {"type": "textarea", "name": "opportunity_description", "placeholder": "Opportunity Description"},
                {"type": "text", "name": "exploitation_plan", "placeholder": "Exploitation Plan"}
            ],
            "explanation": "Detail opportunities and strategies to capitalize on them for the COS.",
            "ai_context": "Identify opportunities and provide strategies to exploit them for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Opportunity Name", "field": "opportunity_name", "editor": "input"},
                {"title": "Opportunity Description", "field": "opportunity_description", "editor": "textarea"},
                {"title": "Exploitation Plan", "field": "exploitation_plan", "editor": "input"}
            ]
        }
    }
}

def get_valid_node_types():  
    return list(NODES.keys()) 

üîµ ce_cards.js:
// ce_cards.js
import { showLoadingSpinner, hideLoadingSpinner } from './base_functions.js';

// Initialize ce_store (if not already defined - best practice)
const ce_store = window.ce_store || {};

// --- Default Configurations for CE Modals and Tables ---
// Define default configurations to be used if specific CE type configurations are missing in NODES
const DEFAULT_FIELDS_CONFIG = [
    { type: "text", name: "subject", placeholder: "Subject" },
    { type: "textarea", name: "details", placeholder: "Details" },
    { type: "text", name: "stakeholders", placeholder: "Stakeholders" }
];

const DEFAULT_TABULATOR_CONFIG = {
    columns: [
        { title: "Subject", field: "subject", editor: "input" },
        { title: "Details", field: "details", editor: "input" },
        { title: "Stakeholders", field: "stakeholders", editor: "input" }
    ]
};

// --- NODES Definition ---
// Defines configuration for different Conditional Element (CE) types.
const NODES = {
    "Default": {
        icon: 'fa-spinner',
        modal_config: {
            fields: DEFAULT_FIELDS_CONFIG, // Use DEFAULT_FIELDS_CONFIG here
            explanation: "Default Resource Node.",
            ai_context: "Provide general information."
        },
        tabulator_config: DEFAULT_TABULATOR_CONFIG // Use DEFAULT_TABULATOR_CONFIG here
    },
    // ... (Your other CE type definitions - Research, Stakeholder, etc.)
    "Research": {
        "definition": "Aggregates and summarizes research materials.",
        "icon": "fa-solid fa-flask",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "research_topic", "placeholder": "Research Topic"},
                {"type": "textarea", "name": "research_summary", "placeholder": "Research Summary"},
                {"type": "text", "name": "research_website", "placeholder": "Research Website"}
            ],
            "explanation": "Capture relevant research aspects of the node.",
            "ai_context": "Provide detailed research information."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Research Topic", "field": "research_topic", "editor": "input"},
                {"title": "Research Summary", "field": "research_summary", "editor": "textarea"},
                {"title": "Research Website", "field": "research_website", "editor": "input"}
            ]
        }
    },
    "Stakeholder": {
        "definition": "Captures details of stakeholders involved.",
        "icon": "fa-solid fa-user-friends",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "stakeholder_name", "placeholder": "Stakeholder Name"},
                {"type": "textarea", "name": "stakeholder_role", "placeholder": "Stakeholder Role"},
                {"type": "email", "name": "stakeholder_email", "placeholder": "Stakeholder Email"},
                {"type": "text", "name": "stakeholder_phone", "placeholder": "Stakeholder Phone"},
            ],
            "explanation": "Detail stakeholder roles and contact information.",
            "ai_context": "Identify and provide details of stakeholders."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Stakeholder Name", "field": "stakeholder_name", "editor": "input"},
                {"title": "Stakeholder Role", "field": "stakeholder_role", "editor": "textarea"},
                {"title": "Stakeholder Email", "field": "stakeholder_email", "editor": "input"},
                {"title": "Stakeholder Phone", "field": "stakeholder_phone", "editor": "input"},
            ]
        }
    },
  "Advocacy": {
        "definition": "Focuses on efforts to influence public policy.",
        "icon": "fa-solid fa-bullhorn",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "campaign_name", "placeholder": "Campaign Name"},
                {"type": "textarea", "name": "campaign_objective", "placeholder": "Campaign Objective"},
                {"type": "text", "name": "target_audience", "placeholder": "Target Audience"}
            ],
            "explanation": "Detail the advocacy campaign's objectives and target audience.",
            "ai_context": "Provide information on advocacy efforts."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Campaign Name", "field": "campaign_name", "editor": "input"},
                {"title": "Campaign Objective", "field": "campaign_objective", "editor": "textarea"},
                {"title": "Target Audience", "field": "target_audience", "editor": "input"}
            ]
        }
    },

    "Resource": {
        "definition": "Lists resources or assets essential for achieving the COS.",
        "icon": "fa-solid fa-tools",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "resource_name", "placeholder": "Resource Name"},
                {"type": "textarea", "name": "resource_details", "placeholder": "Resource Details"},
                {"type": "text", "name": "resource_type", "placeholder": "Resource Type"}
            ],
            "explanation": "Provide details about required resources.",
            "ai_context": "List and detail resources or assets."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Resource Name", "field": "resource_name", "editor": "input"},
                {"title": "Resource Details", "field": "resource_details", "editor": "textarea"},
                {"title": "Resource Type", "field": "resource_type", "editor": "input"}
            ]
        }
    },
    "Praxis": {
        "definition": "Defines actions or tasks necessary to meet the COS.",
        "icon": "fa-solid fa-tasks",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "action_name", "placeholder": "Action Name"},
                {"type": "textarea", "name": "action_description", "placeholder": "Action Description"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ],
            "explanation": "Specify tasks or actions required.",
            "ai_context": "Detail actions or tasks."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Action Name", "field": "action_name", "editor": "input"},
                {"title": "Action Description", "field": "action_description", "editor": "textarea"},
                {"title": "Responsible Person", "field": "responsible_person", "editor": "input"}
            ]
        }
    },
    "Timeline": {
        "definition": "Specifies time frames or deadlines.",
        "icon": "fa-solid fa-clock",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "time_frame", "placeholder": "Time Frame"},
                {"type": "date", "name": "start_date", "placeholder": "Start Date"},
                {"type": "date", "name": "end_date", "placeholder": "End Date"}
            ],
            "explanation": "Provide time-related information.",
            "ai_context": "Detail time frames or deadlines."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Time Frame", "field": "time_frame", "editor": "input"},
                {"title": "Start Date", "field": "start_date", "editor": "input"},
                {"title": "End Date", "field": "end_date", "editor": "input"}
            ]
        }
    },
    "Collaboration": {
        "definition": "Focuses on partnerships or collaboration efforts.",
        "icon": "fa-solid fa-handshake",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "partner_name", "placeholder": "Partner Name"},
                {"type": "textarea", "name": "collaboration_details", "placeholder": "Collaboration Details"},
                {"type": "text", "name": "contact_person", "placeholder": "Contact Person"}
            ],
            "explanation": "Outline collaboration efforts.",
            "ai_context": "Detail partnerships or collaboration efforts."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Partner Name", "field": "partner_name", "editor": "input"},
                {"title": "Collaboration Details", "field": "collaboration_details", "editor": "textarea"},
                {"title": "Contact Person", "field": "contact_person", "editor": "input"}
            ]
        }
    },
    "Policy": {
        "definition": "Addresses policy or regulatory aspects.",
        "icon": "fa-solid fa-gavel",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "policy_name", "placeholder": "Policy Name"},
                {"type": "textarea", "name": "policy_details", "placeholder": "Policy Details"},
                {"type": "text", "name": "regulatory_body", "placeholder": "Regulatory Body"}
            ],
            "explanation": "Detail policies or regulations.",
            "ai_context": "Provide information on policies."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Policy Name", "field": "policy_name", "editor": "input"},
                {"title": "Policy Details", "field": "policy_details", "editor": "textarea"},
                {"title": "Regulatory Body", "field": "regulatory_body", "editor": "input"}
            ]
        }
    },
    "Legislation": {
        "definition": "Covers legal considerations or requirements.",
        "icon": "fa-solid fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "legal_requirements", "placeholder": "Legal Requirements"},
                {"type": "text", "name": "relevant_legislation", "placeholder": "Relevant Legislation"},
                {"type": "text", "name": "compliance_officer", "placeholder": "Compliance Officer"}
            ],
            "explanation": "Detail legal considerations.",
            "ai_context": "Provide information on legal considerations."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Legal Requirements", "field": "legal_requirements", "editor": "textarea"},
                {"title": "Relevant Legislation", "field": "relevant_legislation", "editor": "input"},
                {"title": "Compliance Officer", "field": "compliance_officer", "editor": "input"}
            ]
        }
    },
    "Environment": {
        "definition": "Addresses environmental factors.",
        "icon": "fa-solid fa-leaf",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "environmental_factor", "placeholder": "Environmental Factor"},
                {"type": "textarea", "name": "impact_assessment", "placeholder": "Impact Assessment"},
                {"type": "text", "name": "mitigation_strategy", "placeholder": "Mitigation Strategy"}
            ],
            "explanation": "Detail environmental factors and their impact.",
            "ai_context": "Provide information on environmental factors."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Environmental Factor", "field": "environmental_factor", "editor": "input"},
                {"title": "Impact Assessment", "field": "impact_assessment", "editor": "textarea"},
                {"title": "Mitigation Strategy", "field": "mitigation_strategy", "editor": "input"}
            ]
        }
    },
    "Risk": {
        "definition": "Identifies potential risks and mitigation strategies.",
        "icon": "fa-solid fa-exclamation-triangle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "risk_name", "placeholder": "Risk Name"},
                {"type": "textarea", "name": "risk_description", "placeholder": "Risk Description"},
                {"type": "text", "name": "mitigation_plan", "placeholder": "Mitigation Plan"}
            ],
            "explanation": "Detail potential risks and strategies to mitigate them.",
            "ai_context": "Identify potential risks and provide mitigation strategies."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Risk Name", "field": "risk_name", "editor": "input"},
                {"title": "Risk Description", "field": "risk_description", "editor": "textarea"},
                {"title": "Mitigation Plan", "field": "mitigation_plan", "editor": "input"}
            ]
        }
    },
    "Opportunity": {
        "definition": "Identifies opportunities that can enhance the COS.",
        "icon": "fa-solid fa-lightbulb",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "opportunity_name", "placeholder": "Opportunity Name"},
                {"type": "textarea", "name": "opportunity_description", "placeholder": "Opportunity Description"},
                {"type": "text", "name": "exploitation_plan", "placeholder": "Exploitation Plan"}
            ],
            "explanation": "Detail opportunities and strategies to capitalize on them.",
            "ai_context": "Identify opportunities and provide strategies."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Opportunity Name", "field": "opportunity_name", "editor": "input"},
                {"title": "Opportunity Description", "field": "opportunity_description", "editor": "textarea"},
                {"title": "Exploitation Plan", "field": "exploitation_plan", "editor": "input"}
            ]
        }
    },
    "AnotherType": {
        icon: 'fa-solid fa-question', // A default icon
        modal_config: {
            fields: DEFAULT_FIELDS_CONFIG,
            explanation: "Generic Conditional Element.",
            ai_context: "Provide general information."
        },
        tabulator_config: DEFAULT_TABULATOR_CONFIG
    }
};


// --- End of NODES Definition ---



document.addEventListener('DOMContentLoaded', setupEventListeners);

/**
 * Sets up event listeners for CE pills after the DOM is loaded.
 */
function setupEventListeners() {
    console.log("setupEventListeners() - Adding event listeners to CE pills");
    document.querySelectorAll('.ce-pill').forEach(pill => {
        console.log("setupEventListeners() - Processing pill:", pill);
        pill.removeEventListener('click', handleCEPillClick); // Prevent duplicate listeners
        pill.addEventListener('click', handleCEPillClick);
        pill.title = 'Double-click to open Conditional Element'; // Tooltip for CE pills
    });
    console.log("setupEventListeners() - Event listeners added.");
}

/**
 * Handles the click event on a CE pill. Fetches and displays the CE modal.
 * @param {Event} event - The click event object.
 */
async function handleCEPillClick(event) {
    event.preventDefault();
    event.stopPropagation();

    console.log("handleCEPillClick() - CE Pill Clicked!", event.target);

    // Remove existing modal (if any)
    const existingModal = document.querySelector('.modal.fade.show');
    if (existingModal) {
        console.log("handleCEPillClick() - Found existing modal, removing it:", existingModal);
        existingModal.remove();
    } else {
        console.log("handleCEPillClick() - No existing modal found.");
    }

    const ceId = event.target.dataset.ceId;
    const ceType = event.target.dataset.ceType || "Default";
    const iconClass = NODES[ceType]?.icon || 'fa-spinner';
    const cosContentCell = event.target.closest('.cos-card')?.querySelector('.cos-content-display');
    const cosContent = cosContentCell ? cosContentCell.innerHTML : '';
    const phaseElement = event.target.closest('.accordion-item');
    const phaseName = phaseElement?.querySelector('.accordion-header button')?.innerText.trim();
    const phaseIndex = phaseElement ? Array.from(phaseElement.parentElement.children).indexOf(phaseElement) : 0;
    const ssolGoal = document.querySelector('#ssol-goal')?.textContent.trim() || "Goal Not Found";

    const requestData = {
        ce_id: ceId,
        cos_content: cosContent,
        phase_name: phaseName,
        phase_index: phaseIndex,
        ssol_goal: ssolGoal
    };

    showLoadingSpinner(`Loading ${ceType} data...`, iconClass);
    try {
        const response = await fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });

        if (!response.ok) {
            console.error("handleCEPillClick() - Fetch Response NOT OKAY:", response);
            throw new Error(`Network response was not ok: ${response.status}`);
        }

        const data = await response.json();
        hideLoadingSpinner();

        if (data && data.modal_html) {
            console.log("handleCEPillClick() - Received modal_html, displaying modal:", data);
             // Call displayCEModal *WITHOUT* passing tableData and _tabulatorColumns initially.
            displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, data.ai_generated_data, [], [], ssolGoal);
        } else {
            console.error(`CE type "${ceType}" not found or invalid response:`, data);
            alert('Error fetching CE Data');
        }
    } catch (error) {
        hideLoadingSpinner();
        console.error(`handleCEPillClick() - Fetch ERROR: ${error}`);
        alert('Error fetching CE Data');
    }
}

/**
 * Defines the Tabulator table columns based on the CE type.
 * @param {string} ceType - The type of Conditional Element.
 * @returns {Array<object>} - An array of Tabulator column definitions.
 */
function tabulatorColumnsDefinition(ceType) {
    const defaultColumns = [
        { formatter: "rowSelection", titleFormatter: "rowSelection", hozAlign: "center", headerSort: false, width: 40, resizable: false, cellClick: (e, cell) => cell.getRow().toggleSelect() },
        {
            title: "Source",
            field: "source_url",
            formatter: "link",
            formatterParams: {
                labelField: "source_title",
                target: "_blank",
            },
            headerSort: false,
        },
        { title: "Snippet", field: "source_snippet", headerSort: false, formatter: "textarea" },
    ];

    const nodeConfig = NODES && NODES[ceType] ? NODES[ceType].tabulator_config : undefined;
    const additionalColumns = nodeConfig && nodeConfig.columns ? nodeConfig.columns : [];

    return [...defaultColumns, ...additionalColumns];
}


/**
 * Displays the Conditional Element modal, handling DOM insertion and event listeners.
 * @param {string} modalHtml The HTML content of the modal.
 * @param {string} ceId The ID of the conditional element.
 * @param {string} p_ceType The type of the conditional element.
 * @param {string} cosContent The content of the related condition of satisfaction.
 * @param {string} p_phaseName The name of the current phase.
 * @param {number} phaseIndex The index of the current phase.
 * @param {object} aiGeneratedData The AI-generated data for the CE (optional).
 * @param {object[]} tableData The initial data for the tabulator table.
 * @param {object[]} _tabulatorColumns // Now unused.
 * @param {string} ssolGoal The goal of the structured solution.
 */
function displayCEModal(modalHtml, ceId, p_ceType, cosContent, p_phaseName, phaseIndex, aiGeneratedData = { fields: {} }, tableData = [], _tabulatorColumns, ssolGoal) {
    const modalContainer = document.getElementById('dynamicModalContainer');
    if (!modalContainer) {
        console.error('Modal container element (#dynamicModalContainer) not found.');
        return;
    }

    console.log("displayCEModal - Received ceId:", ceId);
    console.log("displayCEModal - Received p_ceType:", p_ceType);

    modalContainer.innerHTML = modalHtml;
    console.log("displayCEModal - Set modalContainer.innerHTML from modalHtml");

    // Log the *entire* innerHTML of the modalContainer to see exactly what's there
    console.log("displayCEModal - modalContainer.innerHTML BEFORE observer:", modalContainer.innerHTML); // *** ADDED LOGGING ***

    const observer = new MutationObserver((mutations, obs) => {
        const expectedId = `ceModal-${ceId}`; // *** ADDED VARIABLE ***
        console.log("MutationObserver callback triggered."); // *** ADDED LOGGING ***
        console.log("MutationObserver - Expected Modal ID:", expectedId); // *** ADDED LOGGING ***
        const modalElement = modalContainer.querySelector(`#${expectedId}`); // Use variable here
        console.log("MutationObserver - querySelector result (modalElement):", modalElement); // *** ADDED LOGGING ***

        if (modalElement) {
            console.log("displayCEModal() - modalElement found:", modalElement);
            const modal = new bootstrap.Modal(modalElement);

            modalElement.addEventListener('shown.bs.modal', () => {
                const tableElementId = `#dynamicTable-${ceId}`;
                const tableElement = document.querySelector(tableElementId);

                if (tableElement) {
                    tableElement.innerHTML = '';
                }

                initializeTabulatorTable(tableElementId, tableData, tabulatorColumnsDefinition(p_ceType), p_ceType, modalElement);

                const attribution = aiGeneratedData.attribution || '';
                if (attribution) {
                    const attributionElement = document.createElement('p');
                    attributionElement.classList.add('text-muted', 'small', 'mt-2');
                    attributionElement.textContent = attribution;
                    modalElement.querySelector('.modal-body').appendChild(attributionElement);
                }

                setupModalEventListeners(modalElement, ceId, p_ceType, cosContent, p_phaseName, ssolGoal);
            });

            modalElement.addEventListener('hidden.bs.modal', () => {
              if (modalElement.dataset.hasUnsavedChanges === 'true' && !confirm('You have unsaved changes.  Close anyway?')) {
                    modal.show(); // Re-show modal if unsaved changes and user cancels close
                } else {
                    modalElement.dataset.hasUnsavedChanges = 'false';
                    setupEventListeners();
                }
            });

            modal.show();
            obs.disconnect();
        } else {
            console.error(`MutationObserver: Modal element still not found for CE ID: ${ceId}`);
        }
    });

    observer.observe(modalContainer, { childList: true, subtree: true });
}

/**
 * Generates HTML form fields based on the fields configuration.
 * @param {Array<object>} fieldsConfig - Configuration for form fields.
 * @param {object} aiData - AI-generated data to pre-populate fields.
 * @returns {string} - HTML string of form fields.
 */
function generateFormFields(fieldsConfig, aiData = {}) {
    if (!fieldsConfig) {
        console.error("No fieldsConfig provided.");
        return 'No form fields.';
    }
    return fieldsConfig.map(field => {
        const fieldValue = aiData[field.name] || '';
        const placeholder = field.placeholder || '';
        const fieldType = field.type || 'text';

        switch (fieldType) {
            case 'textarea':
                return `<div class="form-group">
                            <label for="${field.name}">${placeholder}</label>
                            <textarea class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}" rows="3">${fieldValue}</textarea>
                        </div>`;
            case 'select':
                 const options = field.options || [];
                 const optionsHtml = options.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
                 return `<div class="form-group">
                            <label for="${field.name}">${placeholder}</label>
                            <select class="form-control" id="${field.name}" name="${field.name}">${optionsHtml}</select>
                        </div>`
            default:
                return `<div class="form-group">
                            <label for="${field.name}">${placeholder}</label>
                            <input type="${fieldType}" class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}" value="${fieldValue}">
                        </div>`;
        }
    }).join('');
}

/**
 * Clears all input fields within a given form.
 * @param {string} formSelector - CSS selector for the form element.
 */
function clearFormFields(formSelector) {
    const form = document.querySelector(formSelector);
    if (form) {
        form.querySelectorAll('input, textarea, select').forEach(field => {
            if (field.type !== 'checkbox' && field.type !== 'radio') {
                field.value = '';
            }
        });
    }
}

/**
 * Sets up event listeners for buttons and form interactions within the modal.
 * @param {HTMLElement} modalElement - The modal element.
 * @param {string} ceId - ID of the Conditional Element.
 * @param {string} p_ceType - Type of the Conditional Element.
 * @param {string} cosContent - Content of the Condition of Satisfaction.
 * @param {string} p_phaseName - Name of the phase.
 * @param {string} ssolGoal - The overall SSPEC goal.
 */
function setupModalEventListeners(modalElement, ceId, p_ceType, cosContent, p_phaseName, ssolGoal) {
    const addRowButton = modalElement.querySelector(`#addRowButton-${ceId}`);
    const generateRowButton = modalElement.querySelector(`#generateRowButton-${ceId}`);
    const saveChangesButton = modalElement.querySelector('.btn-save-changes');
    const deleteSelectedRowsButton = modalElement.querySelector(`#deleteSelectedRowsButton-${ceId}`);
    const duplicateSelectedRowsButton = modalElement.querySelector(`#duplicateSelectedRowsButton-${ceId}`);

    const table = modalElement._tabulator;

     if (generateRowButton) {
        generateRowButton.addEventListener('click', () => {
            generateFieldsFromAI(ceId, p_ceType, cosContent, ssolGoal);
        });
    }

    modalElement.addEventListener('input', () => {
        modalElement.dataset.hasUnsavedChanges = 'true';
    });

      modalElement.addEventListener('hidden.bs.modal', () => {
        if (modalElement.dataset.hasUnsavedChanges === 'true' && !confirm('You have unsaved changes. Close anyway?')) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement); // Correct way to get instance
            if (modalInstance) {
                modalInstance.show(); // Re-show modal if unsaved changes and user cancels
            }
        } else {
             modalElement.dataset.hasUnsavedChanges = 'false';
            setupEventListeners();
        }
    });

    if (addRowButton) {
        addRowButton.addEventListener('click', () => {
            const table = modalElement._tabulator; // Get Tabulator instance from modal
            const form = modalElement.querySelector(`#ceForm-${ceId}`);
            const formData = new FormData(form);
            const rowData = {};
            let isAnyFieldFilled = false;

            formData.forEach((value, key) => {
                if (value.trim() !== "") {
                    isAnyFieldFilled = true;
                }
                rowData[key] = value;
            });

            if (!isAnyFieldFilled) {
                alert("Please fill in at least one field before adding a row.");
                return;
            }

            const rows = table.getRows();
            let emptyRow = rows.find(row => Object.values(row.getData()).every(val => val === ''));

            if (emptyRow) {
                emptyRow.update(rowData);
            } else {
                table.addRow(rowData, true);
            }

            clearFormFields(`#ceForm-${ceId}`);
            modalElement.dataset.hasUnsavedChanges = 'true';
        });
    }

    if (saveChangesButton) {
        saveChangesButton.addEventListener('click', () => {
          saveCEChanges(ceId);
           modalElement.dataset.hasUnsavedChanges = 'false';
        });
    }

    if (deleteSelectedRowsButton) {
        deleteSelectedRowsButton.addEventListener('click', () => {
            const table = modalElement._tabulator; // Get Tabulator instance from modal
            if (table) {
                const selectedRows = table.getSelectedRows();
                selectedRows.forEach(row => row.delete());
                modalElement.dataset.hasUnsavedChanges = 'true';
            }
        });
    }

    if (duplicateSelectedRowsButton) {
        duplicateSelectedRowsButton.addEventListener('click', () => {
            const table = modalElement._tabulator; // Get Tabulator instance from modal
            if (table) {
                const selectedRows = table.getSelectedRows();
                selectedRows.forEach(row => {
                  const rowData = row.getData();
                    table.addRow({...rowData});
                });
                modalElement.dataset.hasUnsavedChanges = 'true';
            }
        });
    }
}

/**
 * Saves changes made in the CE modal to the server and updates the UI.
 * @param {string} ceId - ID of the Conditional Element.
 */
function saveCEChanges(ceId) {
    const modalElement = document.querySelector(`#ceModal-${ceId}`);
    const table = modalElement._tabulator;
    const tableData = table ? table.getData() : [];
     const nonNullRows = tableData.filter(row =>
        Object.values(row).some(value => value !== null && (typeof value === 'string' ? value.trim() !== '' : value !== ''))
    );

    const updatedData = {
        table_data: nonNullRows,
        form_data: getFormData(modalElement.querySelector(`#ceForm-${ceId}`))
    };

    fetch(`/update_ce/${encodeURIComponent(ceId)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedData)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            console.log(`CE ID ${ceId} updated successfully`);
            updateCEPills(ceId, nonNullRows.length);
            setupEventListeners();
             bootstrap.Modal.getInstance(modalElement).hide();

        } else {
            console.error('Error updating CE:', data.error);
            alert(`Error updating CE: ${data.error}`);
        }
    })
    .catch(error => {
        console.error('Error updating CE:', error);
        alert(`An error occurred: ${error.message}`);
    });
}

/**
 * Extracts form data from a given form element.
 * @param {HTMLFormElement} form - The form element.
 * @returns {object} - An object containing form data (key-value pairs).
 */
function getFormData(form) {
    const formData = new FormData(form);
    const data = {};
    formData.forEach((value, key) => { data[key] = value; });
    return data;
}

/**
 * Updates the counter badge on CE pills to reflect the number of resources.
 * @param {string} ceId - ID of the Conditional Element.
 * @param {number} resourceCount - Number of resources associated with the CE.
 */
function updateCEPills(ceId, resourceCount) {
    const cePills = document.querySelectorAll(`.ce-pill[data-ce-id="${ceId}"]`); // Select all pills with the given CE ID
    cePills.forEach(cePill => {
        const ceText = cePill.textContent.replace(/\(\d+\)$/, '').trim(); // Remove existing counter from pill text
        cePill.innerHTML = ''; // Clear pill content to rebuild

        const textNode = document.createTextNode(ceText); // Create text node for pill text
        cePill.appendChild(textNode); // Append text node to pill

        if (resourceCount > 0) {
            const tally = document.createElement('span');
            tally.className = 'badge rounded-pill bg-light text-dark ms-2 counter'; // Style for counter badge
            tally.textContent = resourceCount.toString(); // Set counter text
            cePill.appendChild(tally); // Append counter badge to pill
        }
        cePill.addEventListener('click', handleCEPillClick); // Re-attach click event listener to pill
    });
}


/**
 * Generates form fields and table data using AI for a specific CE type.
 * @param {string} ceId - ID of the Conditional Element.
 * @param {string} ceType - Type of the Conditional Element.
 * @param {string} cosContent - Content of the Condition of Satisfaction.
 * @param {string} ssolGoal - The overall SSPEC goal.
 */
async function generateFieldsFromAI(ceId, ceType, cosContent, ssolGoal) {
  const form = document.querySelector(`#ceForm-${ceId}`);
    if (!form) {
        console.error(`Form not found for CE ID: ${ceId}`);
        return;
    }

    // Collect existing CEs (excluding the current one) for context
    const existingCEs = Array.from(document.querySelectorAll('.ce-pill'))
        .filter(pill => pill.dataset.ceId !== ceId) // Exclude current CE pill
        .map(pill => ({
            id: pill.dataset.ceId,
            type: pill.dataset.ceType,
            content: pill.textContent.trim() // Get text content of the pill
        }));

    const requestData = { // Data to send to server for AI generation
        ce_id: ceId,
        ce_type: ceType,
        cos_content: cosContent,
        ssol_goal: ssolGoal,
        existing_ces: existingCEs // Include existing CEs for context
    };

    showLoadingSpinner(`Generating ${ceType}...`); // Show loading spinner during AI call
    try {
        const response = await fetch('/ai-query-endpoint', { // Fetch AI-generated data from server
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });

        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`); // Handle HTTP errors
        }

        const data = await response.json(); // Parse JSON response
        hideLoadingSpinner(); // Hide loading spinner after response

        if (data && data.ai_response) {
            populateFormFields(ceId, data.ai_response.fields); // Populate form fields with AI data

            const tableElementId = `#dynamicTable-${ceId}`;
            const modalElement = document.querySelector(`#ceModal-${ceId}`); // Get modal element (needed for table init)
             if (modalElement) { //Check if the modal element has been created
                const table = initializeTabulatorTable(tableElementId, [], tabulatorColumnsDefinition(ceType), ceType, modalElement); // Initialize Tabulator table (empty initially)

                 if (data.ai_response.table_data && Array.isArray(data.ai_response.table_data)) {
                     table.setData(data.ai_response.table_data); // Set table data if provided in AI response
                 }
             } else {
                console.error("Modal element not found when trying to initialize Tabulator.");
             }

        } else {
            console.error('AI response not found or error in response:', data);
        }
    } catch (error) {
        hideLoadingSpinner(); // Ensure spinner is hidden even on error
        console.error('Error generating fields from AI:', error);
    }
}

/**
 * Populates form fields with AI-generated data.
 * @param {string} ceId - ID of the Conditional Element.
 * @param {object} aiData - AI-generated data for form fields.
 */
function populateFormFields(ceId, aiData) {
    const form = document.querySelector(`#ceForm-${ceId}`);
    if (form && aiData) {
        Object.keys(aiData).forEach(fieldName => { // Iterate through AI data fields
            const input = form.querySelector(`[name="${fieldName}"]`); // Find corresponding input field in form
            if (input) {
                input.value = aiData[fieldName] || ''; // Set input value from AI data or default to empty
            }
        });
    }
}


export { displayCEModal };

üìÜ models.py:
import os
import uuid
from dotenv import load_dotenv
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, Date, inspect
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker, relationship

load_dotenv()

db = SQLAlchemy()
Base = declarative_base()

#  --- Removed _engine, SessionLocal, session here ---

class SSOL(db.Model):
    __tablename__ = 'ssol'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)  # Use UUID for SSOL id
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    cos = relationship('COS', back_populates='ssol')

    def to_dict(self):
        return {
            'id': str(self.id),  # Return UUID as string
            'title': self.title,
            'description': self.description,
            'cos': [cos.to_dict() for cos in self.cos]
        }

class COS(db.Model):
    __tablename__ = 'cos'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(Text, nullable=False)  # Changed to Text for larger content
    status = Column(String(50), nullable=False)
    accountable_party = Column(String(255), nullable=True)
    completion_date = Column(Date, nullable=True)
    ssol_id = Column(UUID(as_uuid=True), ForeignKey('ssol.id'), nullable=False)  # Use UUID for ssol_id
    ssol = relationship('SSOL', back_populates='cos')
    conditional_elements = relationship('CE', back_populates='cos')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'status': self.status,
            'accountable_party': self.accountable_party,
            'completion_date': self.completion_date.isoformat() if self.completion_date else None,
            'ssol_id': str(self.ssol_id),  # Return UUID as string
            'conditional_elements': [ce.to_dict() for ce in self.conditional_elements]
        }

class CE(db.Model):
    __tablename__ = 'ce'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(Text, nullable=False)   # Changed to Text for larger content
    node_type = Column(String(50), nullable=True)
    details = Column(Text, nullable=True)  # Keep this as Text (for Tabulator)
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), nullable=False)
    cos = relationship('COS', back_populates='conditional_elements')

    def to_dict(self):
        return {
            'id': str(self.id),
            'content': self.content,
            'node_type': self.node_type,
            'details': self.details,
            'cos_id': str(self.cos_id)
        }

# --- Removed COS_CE_Link --- (It's redundant with the relationship)

# --- Moved engine and session creation to a function ---
def get_engine_and_session():
    engine = create_engine(os.environ.get('SQLALCHEMY_DATABASE_URI'), echo=True)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    session = scoped_session(SessionLocal)
    return engine, session

# --- Removed Base.metadata.create_all(_engine) --- Use Flask-Migrate
# In app.py (or wherever you initialize your app):
# from flask_migrate import Migrate
# migrate = Migrate(app, db) #  after db.init_app(app)

# Example of conditional table creation (ONLY if not using Flask-Migrate)
def create_tables_if_not_exist(engine):
     if not inspect(engine).has_table("ssol"):
          Base.metadata.create_all(engine)

üì± app.py:
# app.py (Corrected Circular Import)
import os
import logging
from flask import Flask
from flask_migrate import Migrate
from dotenv import load_dotenv
from models import db, get_engine_and_session, create_tables_if_not_exist
import colorlog  # Import colorlog
# from utilities import get_badge_class_from_status  # REMOVE THIS LINE

load_dotenv()

USE_DATABASE = os.environ.get('USE_DATABASE', 'False').lower() in ('true', '1', 't', 'y', 'yes')

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'a_good_default_secret_key')

# Configure colorlog
handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter(
    '%(log_color)s%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    log_colors={
        'DEBUG':    'cyan',
        'INFO':     'green',
        'WARNING':  'yellow',
        'ERROR':    'red',
        'CRITICAL': 'red,bg_white',
    }
))

# Use Flask's logger and add the colorlog handler
logger = logging.getLogger()  # Get root logger (Flask uses this)
logger.setLevel(logging.INFO) # Change to INFO level
logger.addHandler(handler)

def get_badge_class_from_status(status):
   return {
       'Proposed': 'bg-info',
       'In Progress': 'bg-warning text-dark',
       'Completed': 'bg-success',
       'Rejected': 'bg-danger'
   }.get(status, 'bg-secondary')

if USE_DATABASE:
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('SQLALCHEMY_DATABASE_URI')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['SQLALCHEMY_ECHO'] = os.environ.get('SQLALCHEMY_ECHO', 'False').lower() in ('true', '1', 't', 'y', 'yes')

    db.init_app(app)
    migrate = Migrate(app, db)

from routes import routes_bp
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

app.register_blueprint(routes_bp, name='routes_bp')

if __name__ == '__main__':
    app.run(debug=True, port=5000) # Keep debug=True for Flask's debugger

üè™ store.py:
# store.py  
ssol_store = {}  
cos_store = {}  
ce_store = {}  

üß© ce_templates.py:
# ce_templates.py
from flask import current_app
import json
import logging
import uuid
from uuid import UUID
from store import ce_store
from bs4 import BeautifulSoup
from flask import render_template_string, current_app
from ce_nodes import NODES, get_valid_node_types
from ai_service import generate_chat_response, get_grounded_data  # Import get_grounded_data

BASE_MODAL_TEMPLATE = """
<div class="modal fade ceModal" id="ceModal-{{ ceId }}" tabindex="-1" aria-labelledby="ceModalLabel-{{ ceId }}" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content ce-modal">
            <!-- Modal Header -->
            <div class="modal-header ce-modal-header" style="background-color: {{ phaseColor }};">
                <div class="node-icon">
                    <i class="{{ icon_class }}"></i>
                </div>
                <h5 class="modal-title ce-title" id="ceModalLabel-{{ ceId }}">
                    {{ ceType.replace('_', ' ').title() }}
                </h5>
                <span class="phase-name">// {{ phase_name.title() }} PHASE</span>
                <button type="button" class="close-btn close-button" data-bs-dismiss="modal" aria-label="Close">√ó</button>
            </div>

            <!-- Modal Body -->
            <div class="modal-body ce-modal-body">
                <!-- SECTION 1: CONTEXT -->
                <div class="section">
                    <h2 class="section-heading">CONTEXT - Understanding the Context of this Element</h2>

                    <!-- SUB-SECTION 1.1: Condition of Satisfaction Context -->
                    <div class="sub-section">
                        <h3 class="sub-heading">Condition of Satisfaction Context</h3>
                        <div class="context-label">Source Condition of Satisfaction (COS):</div>
                        <div class="content-block italic">
                            {{ cos_content_with_pills | safe }}
                        </div>
                    </div>

                    <!-- SUB-SECTION 1.2: [CE Type Name] Node Context & Insight -->
                    <div class="sub-section">
                        <h3 class="sub-heading">{{ ceType.replace('_', ' ').title() }} Node Context & Insight</h3>
                        <div class="context-label">{{ ceType.replace('_', ' ').title() }} Node & Context:</div>
                        <div class="content-block">
                            <p><b>Definition:</b></p>
                            <p class="definition-text">{{ node_info.modal_config.explanation }}</p>
                            <hr style="margin: 10px 0; border-top: 1px dashed #ccc;">
                            <p><b>AI Contextual Insight:</b></p>
                            <p class="content italic">{{ ai_generated_data.contextual_description or 'No AI contextual description available.' }}</p>
                        </div>
                    </div>
                </div>

                <!-- SECTION 2: DETAILS -->
                <div class="section">
                    <h2 class="section-heading">DETAILS - Attributes and Specifications of the {{ ceType.replace('_', ' ').title() }}</h2>

                    <!-- FORM FIELDS -->
                    <div class="form-grid">
                        {{ form_fields | safe }}
                    </div>

                    <!-- Resource Action Buttons - Positioned BETWEEN form fields and table -->
                    <div class="action-row">
                        <button type="button" class="btn btn-primary" id="addRowButton-{{ ceId }}"><i class="fas fa-plus"></i> Add {{ ceType.replace('_', ' ').title() }}</button>
                        <button type="button" class="btn btn-primary" id="generateRowButton-{{ ceId }}"><i class="fas fa-magic"></i> Generate {{ ceType.replace('_', ' ').title() }}</button>
                    </div>
                </div>

                <!-- SECTION 3: RESOURCES -->
                <div class="section">
                    <h2 class="section-heading">RESOURCES - Data and References for this Element</h2>
                    <h3 class="sub-heading">Related Resources for {{ ceType.replace('_', ' ').title() }}</h3>

                    <!-- TABULATOR TABLE -->
                    <div id="dynamicTable-{{ ceId }}" class="tabulator-table resources-table"></div>

                    <!-- Resource Management Buttons -->
                    <div class="action-row">
                        <button type="button" class="btn btn-danger" id="deleteSelectedRowsButton-{{ ceId }}"><i class="fas fa-trash-alt"></i> Delete Selected</button>
                        <button type="button" class="btn btn-default" id="duplicateSelectedRowsButton-{{ ceId }}"><i class="fas fa-copy"></i> Duplicate Selected</button>
                    </div>
                </div>
            </div>

            <!-- Modal Footer -->
            <div class="modal-footer ce-modal-footer">
                <button type="button" class="btn btn-default btn-close-modal" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="{{ ceId }}">Save Changes</button>
            </div>
        </div>
    </div>
</div>
"""

DEFAULT_FIELDS_CONFIG = [
    {"type": "text", "name": "subject", "placeholder": "Subject"},
    {"type": "textarea", "name": "details", "placeholder": "Details"},
    {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}
]

DEFAULT_TABULATOR_CONFIG = {
    "columns": [
        {"title": "Subject", "field": "subject", "editor": "input"},
        {"title": "Details", "field": "details", "editor": "input"},
        {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}
    ]
}

def generate_form_field(field_type, field_name, field_value='', placeholder='', options=None):
    current_app.logger.debug(f"Generating form field: type={field_type}, name={field_name}, value={field_value}, placeholder={placeholder}")
    field_templates = {
        'text': '<div class="form-group"><label for="{name}">{label}</label><input type="text" class="form-control form-input" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'number': '<div class="form-group"><label for="{name}">{label}</label><input type="number" class="form-control form-input" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'textarea': '<div class="form-group"><label for="{name}">{label}</label><textarea class="form-control form-input form-textarea" id="{name}" name="{name}" placeholder="{placeholder}" data-placeholder="{placeholder}" rows="4">{value}</textarea></div>',
        'email': '<div class="form-group"><label for="{name}">{label}</label><input type="email" class="form-control form-input" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'password': '<div class="form-group"><label for="{name}">{label}</label><input type="password" class="form-control form-input" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',
        'date': '<div class="form-group"><label for="{name}">{label}</label><input type="date" class="form-control form-input" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'time': '<div class="form-group"><label for="{name}">{label}</label><input type="time" class="form-control form-input" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'datetime-local': '<div class="form-group"><label for="{name}">{label}</label><input type="datetime-local" class="form-control form-input" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'color': '<div class="form-group"><label for="{name}">{label}</label><input type="color" class="form-control form-input" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',
        'checkbox': '<div class="form-check"><input type="checkbox" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',
        'radio': '<div class="form-check"><input type="radio" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',
        'select': '<div class="form-group"><label for="{name}">{label}</label><select class="form-control form-input" id="{name}" name="{name}">{options}</select></div>',
    }

    checked = 'checked' if field_value and field_type in ['checkbox', 'radio'] else ''
    label = field_name.replace('_', ' ').title()  # Generate a label from the field name

    if field_type in ['radio', 'select']:
        options_html = ''.join(f'<option value="{opt_value}" {"selected" if field_value and opt_value == field_value else ""}>{opt_label}</option>' for opt_value, opt_label in (options or {}).items())
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, options=options_html)
    else:
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, checked=checked)

def generate_form_fields(fields_config, ai_generated_data=None):
    if not fields_config:
        current_app.logger.error("No fields_config provided to generate form fields.")
        return "No form fields available."
    current_app.logger.debug(f"Generating form fields with config: {fields_config}")
    form_fields_html = ""
    for field in fields_config:
        current_app.logger.debug(f"Generating field: {field}")
        # Check if AI-generated data exists for the field
        field_value = ai_generated_data.get(field['name'], '') if ai_generated_data else ''
        field_html = generate_form_field(
            field_type=field['type'],
            field_name=field['name'],
            field_value=field_value,
            placeholder=field.get('placeholder', ''),
            options=field.get('options', None)
        )
        form_fields_html += field_html
    return form_fields_html


def generate_table_headers(fields_config):
    table_headers_html = ""
    for field in fields_config:
        header_label = field['name'].replace('_', ' ').title()
        table_headers_html += f"<th><strong>{header_label}</strong></th>"
    return table_headers_html

async def generate_dynamic_modal(ce_type, ce_data=None, cos_content=None, ai_generated_data=None, phase_name=None, phase_index=None, ce_store=None):
    current_app.logger.debug(f"generate_dynamic_modal - START - ce_type: {ce_type}, phase_name: {phase_name}, phase_index: {phase_index}")
    current_app.logger.debug(f"CE data: {ce_data}")
    current_app.logger.debug(f"COS content: {cos_content}")
    current_app.logger.debug(f"AI generated data: {ai_generated_data}")
    current_app.logger.debug(f"Phase name: {phase_name}")
    current_app.logger.debug(f"Phase index: {phase_index}")

    node_info = NODES.get(ce_type, NODES['Default'])
    fields_config = node_info['modal_config']['fields']
    tabulator_config = node_info['tabulator_config']

    saved_form_data = ce_data.get('form_data', {}) if ce_data else {}
    form_fields = generate_form_fields(fields_config, saved_form_data or ai_generated_data.get('fields', {}))
    table_headers = generate_table_headers(fields_config)
    table_data = ce_data.get('table_data', []) if ce_data else []

    node_name = ce_type.replace('_', ' ').title()
    ai_context_description = ai_generated_data.get('contextual_description', 'No contextual description provided.')

    # Process the COS content to replace CE tags with CE pills
    ces = list(ce_store.values())  # Ensure that ce_store contains the correct structure
    for ce in ces:
        if 'node_type' not in ce:  # Corrected to use node_type
            ce['node_type'] = 'Unknown' # Corrected to use node_type
            current_app.logger.warning(f"Added missing 'node_type' to CE: {ce}")

    cos_content_with_pills = replace_ce_tags_with_pills(cos_content, ces)

    # Determine phase color
    phase_colors = ["#e91e63", "#00bcd4", "#9c27b0", "#ffc107", "#66bd0e"]  # Example colors
    phaseColor = phase_colors[phase_index % len(phase_colors)] if phase_index is not None else "#6c757d"  # Default color

    # Get icon class, awaiting the async function
    icon_class = NODES[ce_type].get('icon') if ce_type in NODES else await get_node_type_icon_and_name(ce_type)

    current_app.logger.debug(f"generate_dynamic_modal - BEFORE RENDER - Context: {locals()}") # *** ADDED LOGGING - LOG CONTEXT ***
    modal_content = render_template_string( # <-- CORRECTED: Using render_template_string HERE
        BASE_MODAL_TEMPLATE,
        ceId=ce_data.get('id', 'unknown_ce_id') if ce_data else 'unknown_ce_id', # Pass ceId
        ceType=ce_type, # Pass ceType
        icon_class = icon_class,
        node_info=node_info,
        form_fields=form_fields,
        table_headers=table_headers,
        table_data=table_data,
        tabulator_columns=[
            { 'formatter': 'rowSelection', 'titleFormatter': 'rowSelection', 'hozAlign': 'center', 'headerSort': False, 'cellClick': lambda e, cell: cell.getRow().toggleSelect() },
            *tabulator_config['columns'],
        ],
        cos_content_with_pills=cos_content_with_pills,  # Use processed COS content with CE pills
        ai_generated_data=ai_generated_data,
        phase_name=phase_name,
        phase_index=phase_index,
        phaseColor = phaseColor # Pass phaseColor
    )

    return modal_content

async def get_node_type_icon_and_name(node_type):
    messages = [
        {"role": "user", "content": f"You are an AI that suggests a FontAwesome 6 Solid (fas) class icon based on the node type name. Output only the icon class in JSON format."},
        {"role": "user", "content": f"What is the best FontAwesome icon class for the node type '{node_type}'?"}
    ]
    response_content = await generate_chat_response(messages, role='Icon Generation', task='Fetch FontAwesome 6 Icon', temperature=0.37)

    try:
        # Log the raw response content for debugging
        current_app.logger.debug(f"Raw response content: {response_content}")

        # Parse the JSON string into a dictionary
        response_data = json.loads(response_content)
        # Make sure to match the keys exactly with the response content
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"

        if not icon_class:
            # Log a warning if expected keys are missing
            current_app.logger.warning("Missing 'iconClass' in AI response.")
            raise ValueError("Failed to generate icon. Please try again.")

        return icon_class

    except json.JSONDecodeError as e:
        # Log the JSON parsing error
        current_app.logger.error(f"JSON parsing error: {e}")
        raise ValueError("Failed to parse JSON response. Please try again.")

    except Exception as e:
        # Log any other exceptions
        current_app.logger.error(f"Unexpected error: {e}")
        raise

def assign_ce_type(ce):
    if 'node_type' not in ce or not ce['node_type']: #Corrected to node_type
        # Assign a default CE type if none is provided
        ce['node_type'] = 'Default' #Corrected to node_type
        logging.info(f"Assigned default 'node_type' to CE: {ce}")
    return ce

def replace_ce_tags_with_pills(content, ces):
    soup = BeautifulSoup(content, 'html.parser')

    # First, find and replace all <ce> tags in the content
    for ce_tag in soup.find_all('ce'):
        ce_type = ce_tag.get('type', 'Default')  # Default type if not specified
        ce_uuid = str(uuid.uuid4())
        new_tag = soup.new_tag('span', attrs={
            'class': 'badge rounded-pill bg-secondary ce-pill position-relative',
            'data-ce-id': ce_uuid,
            'data-ce-type': ce_type
        })
        new_tag.string = ce_tag.text  # Use the text content of the <ce> tag

        # Add indicator for new CEs (assuming you have a way to identify new CEs, e.g., a flag in 'ce_data')
        # if ce_data.get('is_new'):
        #     green_dot = soup.new_tag('span', attrs={
        #         'class': 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle'
        #     })
        #     visually_hidden_text = soup.new_tag('span', attrs={'class': 'visually-hidden'})
        #     visually_hidden_text.string = 'New CE'
        #     green_dot.append(visually_hidden_text)
        #     new_tag.append(green_dot)

        ce_tag.replace_with(new_tag)

    # Then, process the provided 'ces' list to update or add pill counts
    for ce in ces:
        ce = assign_ce_type(ce)
        # Find existing pills by data-ce-id, if available.  Otherwise, fall back to finding by content.
        if 'id' in ce:
            existing_pill = soup.find('span', attrs={'data-ce-id': ce['id']})
        else:
            existing_pill = soup.find('span', class_='ce-pill', string=ce['content'])

        if existing_pill:
            # Update existing pill
            if ce.get('count', 0) > 0:
                counter_tag = existing_pill.find('span', class_='counter')
                if counter_tag:
                    counter_tag.string = str(ce['count'])
                else:
                    counter_tag = soup.new_tag('span', attrs={'class': 'badge rounded-pill bg-light text-dark ms-2 counter'})
                    counter_tag.string = str(ce['count'])
                    existing_pill.append(counter_tag)
            if ce.get('is_new'):
                green_dot = existing_pill.find('span', class_='position-absolute')
                if not green_dot:
                  green_dot = soup.new_tag('span', attrs={
                      'class': 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle'
                  })
                  visually_hidden_text = soup.new_tag('span', attrs={'class': 'visually-hidden'})
                  visually_hidden_text.string = 'New CE'
                  green_dot.append(visually_hidden_text)
                  existing_pill.append(green_dot)


        else:
          #Add new pills that may not exist in the original text:
          ce_uuid = str(uuid.uuid4())
          new_tag = soup.new_tag('span', attrs={
              'class': 'badge rounded-pill bg-secondary ce-pill position-relative',
              'data-ce-id': ce_uuid,
              'data-ce-type': ce['node_type']
          })
          new_tag.string = ce['content']

          # Add counter if applicable
          if ce.get('count', 0) > 0:
              counter_tag = soup.new_tag('span', attrs={
                  'class': 'badge rounded-pill bg-light text-dark ms-2 counter'
              })
              counter_tag.string = str(ce['count'])
              new_tag.append(counter_tag)
          if ce.get('is_new'):
                green_dot = soup.new_tag('span', attrs={
                    'class': 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle'
                })
                visually_hidden_text = soup.new_tag('span', attrs={'class': 'visually-hidden'})
                visually_hidden_text.string = 'New CE'
                green_dot.append(visually_hidden_text)
                new_tag.append(green_dot)
          soup.append(new_tag)

    return str(soup)


async def get_ce_modal(ce_type):
    modal_html = await generate_dynamic_modal(ce_type)
    return modal_html

async def generate_ai_data(cos_text, ce_id, ce_type, ssol_goal, existing_ces=None):
    if existing_ces is None:
        existing_ces = []  # Default to an empty list if no existing CEs are provided

    node_info = NODES.get(ce_type, NODES['Default'])
    ai_context = node_info.get('modal_config', {}).get('ai_context', '')
    modal_config_fields = node_info.get('modal_config', {}).get('fields', [])

    if not ai_context:
        current_app.logger.debug(f"No AI context provided for CE type: {ce_type}")
        return {"summary": "No AI context provided.", "fields": {}}

     # --- Construct the Search Query ---
    #This is the most important part.  Be VERY specific and use all available context.
    query = (
        f"Find information related to: {ce_type} for '{cos_text}' in the context of '{ssol_goal}'.  "
    )
    #Add additional context if it exists.
    if existing_ces:
        query += f"Consider these existing elements: {', '.join([ce['content'] for ce in existing_ces])}. "

    for field in modal_config_fields:
        query += f"Find {field['name']}. " #Add the names of the fields you want filled.

    current_app.logger.info(f"Constructed query: {query}")

    # --- Get Grounded Data ---
    grounded_data = await get_grounded_data(query, ce_type)

    if grounded_data:
        current_app.logger.info(f"Grounded Data Retrieved {grounded_data}")
        #Initialize ai_generated_data:
        ai_generated_data = {
          "summary": grounded_data.get('summary', 'Summary not available.'),
          "contextual_description": grounded_data.get('contextual_description', 'No contextual description available.'),
          "fields": {},
          "table_data": [],
          "attribution": grounded_data.get('attribution', '')
        }

        #Process each result.  Extract data and map to fields and table.
        for result in grounded_data.get('results', []):
            # 1. Populate Form Fields (if possible)
            for field in modal_config_fields:
                field_name = field['name']
                if field_name in result.get('extracted_data', {}):
                #Add to the ai_generated_data['fields'] dictionary:
                    ai_generated_data['fields'][field_name] = result['extracted_data'][field_name]

            # 2. Populate Tabulator Table
            row_data = {'source_title': result.get('title'), 'source_url': result.get('url'), 'source_snippet': result.get('snippet')}
            row_data.update(result.get('extracted_data', {}))  # Merge extracted data
            ai_generated_data['table_data'].append(row_data)

    else:
        current_app.logger.warning("No grounded data returned.")
        # Fallback to the original AI generation if grounding fails
        # --- Original AI Generation (as fallback) ---

        valid_node_types = ', '.join(get_valid_node_types())
        field_labels = [field['name'] for field in modal_config_fields]
        # System instruction as part of messages:
        system_message = {
            "role": "user",
            "content": (
                "You are a helpful assistant. Generate contextually relevant data based on the Structured Solution (SSOL) goal, "
                "the parent Condition of Satisfaction (COS) text, and the specific Conditional Element Identifier (CE ID) and type provided. Use this information to generate "
                "detailed and specific insights or data that can fulfill on satisfying the COS and ultimately achieving the SSOL goal. "
                "Choose the most appropriate conditional element type from within the following list: {valid_node_types}."
            ).format(valid_node_types=valid_node_types)
        }
        messages = [
            system_message, # Put system message first!
            {
                "role": "user",
                "content": (
                    f"SSOL Goal: {ssol_goal}\n"
                    f"COS Text: {cos_text}\n"
                    f"CE ID: {ce_id}\n"
                    f"CE Type: {ce_type}\n"
                    f"Context: {ai_context}\n"
                    f"Form Field Labels: {', '.join(field_labels)}\n"
                    f"Existing Conditional Elements: {json.dumps(existing_ces)}\n"  # Include existing CEs
                    f"Based on the SSOL goal and the context provided by the parent COS and other conditional elements, "
                    f"generate a JSON response with the following structure:\n"
                    f"{{\n"
                    f"  \"summary\": \"Summary of the Conditional Element\",\n"
                    f"  \"contextual_description\": \"Contextual description of the CE\",\n"
                    f"  \"fields\": {{\n"
                    f"    \"field_label_1\": \"Unique value for field_label_1\",\n"
                    f"    \"field_label_2\": \"Unique value for field_label_2\",\n"
                    f"    ...\n"
                    f"  }}\n"
                    f"}}\n"
                    f"Ensure that the generated fields are unique and provide new information that complements the existing conditional elements."
                )
            }
        ]

        try:
            response = await generate_chat_response(messages, role='AI Contextual Query', task=f'Generate Data for {ce_type}')
            current_app.logger.debug(f"AI Response: {response}")
            ai_data = json.loads(response)
            current_app.logger.debug(f"Parsed AI Data: {ai_data}")
            return ai_data
        except Exception as e:
            current_app.logger.error(f"Error generating AI data: {e}")
            return {"summary": "Error generating AI data.", "contextual_description": "Error generating context.", "fields": {}}

    return ai_generated_data

üé® styles.css:
/* styles.css - Complete and Consolidated Styles (Refactored for Bootstrap Table COS Layout & CE Modals) */

/* ================================================== */
/* ==============  1. Base Typography  ============== */
/* ================================================== */
body {
  font-family: 'Jost', sans-serif;
  font-weight: 400;
  background-color: #f5f5f5;
  color: #333;
}

h1 {
  font-family: 'Mr Dafoe', cursive;
  font-weight: 400;
  color: #ffa726;
  text-shadow: 1px 1px 0px #e91e63;
  font-size: 3.0rem;
  text-align: center;
  margin-top: 1rem;
  margin-bottom: 1rem;
}

h2, .section-heading {
  font-family: 'Unica One', sans-serif;
  font-weight: 500;
  text-transform: uppercase;
  color: #104a3a;
  text-shadow: 1px 1px 0px #000000; /* Consider a more subtle shadow or none */
}

/* Specific h2 styling for outcome page sections if needed */
.outcome-header h2,
.row > h1 { /* Targeting the "Phases & Conditions of Satisfaction" h1 */
    margin-top: 1.5rem;
    margin-bottom: 1rem;
}

.section-heading { /* Used in CE Modals */
    font-size: 1.5rem;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #e0e0e0;
}

h3, .sub-heading {
  font-family: 'Unica One', sans-serif;
  font-weight: 500;
  text-transform: uppercase;
  color: #555;
}

.sub-heading { /* Used in CE Modals */
    font-family: 'Unica One', sans-serif;
    font-weight: 500;
    color: #333;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    padding-bottom: 0.25rem;
}


/* ================================================== */
/* ==============  2. Navigation Bar  =============== */
/* ================================================== */
nav.navbar {
  background-image: linear-gradient(120deg, #673ab7 0%, #00bcd4 100%);
  border-bottom: 5px solid #e91e63;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

nav.navbar .navbar-brand {
  color: #ffffff;
  font-weight: 500;
  font-size: 2.8rem; /* Adjusted for better fit with tagline */
  padding-top: 0;
  padding-bottom: 0;
}

.navbar-brand h1 { /* If h1 is directly in navbar-brand */
  font-size: inherit; /* Inherit from .navbar-brand for consistency */
  color: #ffa726; /* Match general h1 color */
  text-shadow: 1px 1px 0px #e91e63; /* Match general h1 shadow */
  margin-bottom: 0;
  line-height: 1;
}

.structured-speculation {
  display: block;
  font-family: 'Unica One', sans-serif;
  font-weight: 700;
  font-size: 0.8rem; /* Adjusted for better fit */
  text-transform: uppercase;
  color: rgba(0, 0, 0, 0.85); /* Lighter for better contrast on gradient */
  letter-spacing: 0.5em; /* Adjusted */
  line-height: 1;
  margin-top: -5px; /* Pull up slightly under the main brand text */
}


/* ================================================== */
/* =========  3. Retro-futuristic Background Pattern ======== */
/* ================================================== */
body:before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: radial-gradient(circle at 10% 20%, #e91e63 10%, transparent 10%),
                    radial-gradient(circle at 90% 20%, #00bcd4 10%, transparent 10%),
                    radial-gradient(circle at 40% 60%, #9c27b0 10%, transparent 10%),
                    radial-gradient(circle at 60% 80%, #ffc107 10%, transparent 10%);
  background-size: 40px 40px;
  background-attachment: fixed;
  opacity: 0.3; /* Slightly more subtle */
  z-index: -1;
}


/* ================================================== */
/* ===========  4. General Container & Card Styles ========== */
/* ================================================== */
.container { /* Main page container */
  background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white for depth */
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  margin-top: 20px;
  margin-bottom: 20px;
}

.card { /* General card styling, like for Goal Selection */
  background-color: #ffffff;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  margin-bottom: 20px;
  transition: box-shadow 0.3s ease-in-out;
}

.card:hover {
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
}

.card-header,
.card-footer { /* Bootstrap default card header/footer */
  background-color: #673ab7;
  color: #ffffff;
  border-radius: 8px 8px 0 0; /* Match card radius if header is at top */
}
.card-footer {
  border-radius: 0 0 8px 8px;
}


/* Retro-futuristic Card (Specific card style for goal selection cards) */
.retro-futuristic-card {
  border: 3px solid #00bcd4;
  height: 100%;
}
.retro-futuristic-card.non-compliant { border-color: red; }
.retro-futuristic-card.non-compliant:hover { box-shadow: 0 8px 16px rgba(196, 93, 93, 0.2); }
.retro-futuristic-card.non-compliant .card-body { box-shadow: inset 0 0 10px rgba(196, 93, 93, 0.5); }


/* ================================================== */
/* ===============  5. Button Styles  ================ */
/* ================================================== */
.btn { /* General button enhancements */
    transition: all 0.2s ease-in-out;
}
.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn-primary {
  background-color: #ff5722;
  border-color: #ff5722;
}
.btn-primary:hover, .btn-primary:focus, .btn-primary:active {
  background-color: #e64a19 !important; /* Ensure override */
  border-color: #d84315 !important;
}

.btn-danger {
  color: #fff;
  background-color: #dc3545;
  border-color: #dc3545;
}
.btn-danger:hover {
  color: #fff;
  background-color: #c82333 !important;
  border-color: #bd2130 !important;
}
.btn-info { /* Used for PDF button */
    background-color: #17a2b8;
    border-color: #17a2b8;
}
.btn-info:hover {
    background-color: #138496 !important;
    border-color: #117a8b !important;
}
.btn-success { /* Used for Add COS, Update COS */
    background-color: #28a745;
    border-color: #28a745;
}
.btn-success:hover {
    background-color: #218838 !important;
    border-color: #1e7e34 !important;
}


/* ================================================== */
/* ==============  6. Outcome Page Styles  ============ */
/* ================================================== */
.outcome-header { /* Row containing image/domain and summary */
  margin-bottom: 2rem;
}
.outcome-header .col-md-4 h2, .outcome-header .col-md-8 h1 { /* Specific headings in outcome header */
    text-align: left; /* Align these to left */
}
.outcome-header .col-md-4 h2 { font-size: 1.5rem; margin-bottom: 0.5rem; } /* Smaller for Domain/Fulfilled Goal */


/* ================================================== */
/* ===========  7. Loading Spinner Styles  ============= */
/* ================================================== */
.loading-spinner-overlay { /* Full screen overlay */
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(255, 255, 255, 0.4); /* Slightly more opaque backdrop */
  display: flex; justify-content: center; align-items: center;
  z-index: 10000; /* Ensure it's on top of everything */
}
.spinner-box { /* Box containing the spinner and text */
  width: auto; min-width: 300px; max-width: 550px;
  height: auto; min-height: 150px; max-height: 200px;
  background-color: rgba(255, 255, 255, 0.95);
  display: flex; justify-content: center; align-items: center;
  border-radius: 10px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
  padding: 25px;
}
.spinner-container { display: flex; flex-direction: column; align-items: center; }
.spinner-text {
  margin-top: 15px;
  font-family: 'Unica One', sans-serif;
  text-transform: uppercase;
  color: #333; /* Darker text for readability */
  letter-spacing: 0.3em;
  text-align: center;
  font-size: 0.9rem;
}

/* Animations in section 17 */


/* ================================================== */
/* ===========  8. Refresh Icon Animation  =========== */
/* ================================================== */
#generate-new-goals .refresh-icon { display: inline-block; transition: transform 0.5s ease; }
#generate-new-goals:hover .refresh-icon { transform: rotate(360deg); }


/* ================================================== */
/* ============  9. Domain Icon Styles  ============== */
/* ================================================== */
.domain-text {
  font-family: 'Unica One', sans-serif;
  text-transform: uppercase;
  font-size: 1.3rem; /* Slightly adjusted */
  color: #555;
}
.outcome-header .fa-3x { /* Domain icon on outcome page */
    color: #00bcd4; /* Match a theme color */
}


/* ================================================== */
/* ==========  10. Report Section Title (Unused) ======== */
/* ================================================== */
/* .report-section-title { ... } */


/* ================================================== */
/* == 11. Phase Accordion & COS Table Styles == */
/* ================================================== */
.accordion-header {
  color: #ffffff;
  border-radius: 5px 5px 0 0; /* Rounded top corners */
  margin-bottom: 0; /* No margin if border is directly on accordion-item */
}
.accordion-item {
    margin-bottom: 10px; /* Space between accordion items */
    border-radius: 5px;
    border: 1px solid #ddd; /* Overall border for accordion item */
}
.accordion-button {
  text-transform: uppercase;
  font-family: 'Unica One', sans-serif;
  font-weight: 500;
  font-size: 1rem; /* Increased size */
  text-shadow: 1px 1px 0px rgba(0,0,0,0.3);
  color: #ffffff;
  border-radius: 4px 4px 0 0 !important; /* Ensure top radius for button too */
}
.accordion-button:focus { outline: none; box-shadow: none; }
.accordion-button:not(.collapsed) { color: #ffffff; }

.accordion-body.phase-table-container { /* Where the table resides */
  background-color: #ffffff; /* White background for table area */
  border-radius: 0 0 5px 5px; /* Rounded bottom corners */
  padding: 15px;
  /* border-top: none; */ /* Top border is handled by header */
}

.phase-colors { /* CSS variables for phase-specific colors */
  --phase-0: #e91e63; --phase-1: #00bcd4; --phase-2: #9c27b0;
  --phase-3: #ffc107; --phase-4: #66bd0e;
}

/* COS Table Styling */
.phase-table {
    margin-bottom: 1rem; /* Space below table before "Add COS" button */
    border-collapse: separate; /* Allows border-spacing */
    border-spacing: 0; /* Remove default spacing if any */
}
.phase-table thead th {
    background-color: #f8f9fa; /* Light grey for table header */
    color: #343a40;
    border-bottom-width: 2px; /* Bootstrap default */
    font-family: 'Jost', sans-serif;
    font-weight: 600;
    font-size: 0.9rem;
    text-transform: uppercase;
    vertical-align: middle;
}
.phase-table tbody tr.cos-row { /* Each COS row */
    background-color: #fff; /* Ensure white background for rows */
}
.phase-table tbody tr.cos-row:hover {
    background-color: #f1f8ff; /* Light blue hover for rows */
}
.phase-table td {
    vertical-align: middle; /* Default vertical alignment for all cells */
    padding: 0.75rem; /* Standard Bootstrap padding */
    font-size: 0.9rem;
}

/* Specific Cell Styling */
.status-cell { text-align: center; } /* Center the status pill */
.cos-content-cell .cos-content-display {
    line-height: 1.6;
    word-break: break-word; /* Ensure long content wraps */
}
.cos-content-cell .cos-content-display .ce-pill {
    margin-right: 4px;
    margin-bottom: 4px; /* For wrapping */
}
.cos-content-textarea { /* Textarea when editing COS content */
  width: 100%;
  border-radius: 4px;
  border: 1px solid #ced4da;
  padding: 0.5rem 0.75rem;
  font-size: 0.9rem;
  min-height: 80px; /* Adjust as needed */
}
.actions-cell .btn-group.cos-actions { /* Ensure buttons in group are tight */
    white-space: nowrap;
}
.actions-cell .btn-group.cos-actions .btn {
    margin-right: 3px; /* Small space between buttons */
}
.actions-cell .btn-group.cos-actions .btn:last-child {
    margin-right: 0;
}

.add-cos.btn { /* "Add Condition of Satisfaction" button */
    margin-top: 0.5rem; /* Space above it */
}


/* ================================================== */
/* =========  12. Status & CE Pill Styles  =========== */
/* ================================================== */
.status-pill {
  color: #fff !important;
  text-align: center;
  text-transform: uppercase;
  font-size: 0.65em; /* Smaller for table cell fit */
  font-weight: 600; /* Bold */
  text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.2);
  padding: .3em .7em;
  border-radius: 10rem;
  line-height: 1; /* Prevent extra space */
  display: inline-block; /* Ensure it behaves well in flow */
}

.ce-pill {
  display: inline-flex; align-items: center;
  color: #fff !important;
  background-color: #6c757d; /* Default CE pill background */
  text-align: center;
  text-shadow: 1px 1px 0px rgba(0,0,0,0.2);
  padding: .25em .6em;
  font-size: 0.8rem; /* Slightly smaller */
  border-radius: 10rem;
  cursor: pointer;
  transition: background-color 0.2s ease, transform 0.2s ease;
  line-height: 1.3; /* Adjust for vertical centering with text */
}
.ce-pill:hover {
    background-color: #5a6268;
    transform: translateY(-1px);
}
.ce-pill .counter {
  background-color: rgba(255, 255, 255, 0.85) !important;
  color: #212529 !important;
  text-shadow: none !important;
  font-size: 0.7em;
  font-weight: bold;
  padding: 0.1em 0.4em;
  margin-left: 0.35em;
  border-radius: 10rem;
  line-height: 1;
}


/* ================================================== */
/* ==========  13. Badge Color Overrides  ============ */
/* ================================================== */
.bg-info { background-color: #007bff !important; } /* Bootstrap 4 blue */
.bg-warning { color: #212529 !important; background-color: #ffc107 !important; }
.bg-success { background-color: #28a745 !important; }
.bg-danger { background-color: #dc3545 !important; }
.bg-secondary { background-color: #6c757d !important; }


/* ================================================== */
/* ===========  14. Action Column Styles  ============ */
/* ================================================== */
.actions-header { /* th for Actions column */
  white-space: nowrap;
  min-width: 210px; /* Adjusted for 5 small buttons with icons */
}
.actions-cell { /* td for Actions column */
    white-space: nowrap; /* Keep buttons on one line if possible */
}
.actions-cell .btn-group {
    flex-wrap: nowrap; /* Prevent button group from wrapping */
}


/* ================================================== */
/* == 15. Card Grid Layout (Goal Selection - Unchanged) == */
/* ================================================== */
.card-container { flex-wrap: nowrap !important; justify-content: center; }
.card { display: flex; flex-direction: column; height: 100%; }
.card-body { flex-grow: 1; display: flex; flex-direction: column; }
.card-upper-content { flex-grow: 1; display: flex; flex-direction: column; }
.card-content { display: flex; flex-direction: column; justify-content: space-between; height: 100%; }
.goal-selection-form { margin-top: auto; padding-top: 1rem; }

/* ================================================== */
/* ======  16. Generated Image & Placeholder Styles  ==== */
/* ================================================== */
.ssol-title {
    text-align: center; margin-bottom: 10px; display: block;
    font-family: 'Unica One', sans-serif; font-weight: 500; font-size: 2.8rem;
    color: #326eb6; text-transform: uppercase; text-shadow: 1px 1px 0px #000000;
    letter-spacing: 0.15em; line-height: 1;
}

.image-wrapper {
    position: relative; /* For potential future overlay elements if any */
    display: inline-block; /* Or block, depending on desired centering within col-md-4 */
    width: 100%; /* Make wrapper take full width of its column */
    max-width: 300px; /* Max width of the image itself */
    aspect-ratio: 1 / 1; /* Enforce a square aspect ratio for the space */
    background-color: #f0f0f0; /* Light background for the reserved space */
    border-radius: 25px; /* Match image border-radius */
    margin-bottom: 20px; /* Consistent margin */
    overflow: hidden; /* If image is not perfectly square, it will be contained */
}

.ssol-dynamic-image { /* Targets the single image tag by its new class */
    display: block; /* Remove extra space below inline images */
    width: 100%;    /* Image fills the wrapper width */
    height: 100%;   /* Image fills the wrapper height */
    object-fit: cover; /* Scales the image to maintain its aspect ratio while filling the element‚Äôs entire content box. If the image's aspect ratio does not match the aspect ratio of its box, then the object will be clipped to fit. */
    border-radius: 25px; /* Rounded corners for the image itself */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow */
    /* No opacity or transition here, it's a direct src change */
}

.placeholder-image, .generated-image {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    object-fit: cover; 
    border-radius: 25px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
}
.placeholder-image { opacity: 1; z-index: 1; transition: opacity 0.5s ease-out; }
.placeholder-image.hidden { opacity: 0; z-index: -1; }
.generated-image {
    opacity: 0; z-index: 2; transition: opacity 0.5s ease-in;
    background-color: #eee; 
}
.generated-image.loaded { opacity: 1; }

/* ================================================== */
/* ========  17. Consolidated Fade Animations  ========= */
/* ================================================== */
@keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }
.fade-in { opacity: 0; transition: opacity 1s ease-in; }
.fade-in.loaded { opacity: 1; }

@keyframes fadeInBlur { 0% { opacity: 0; filter: blur(5px); } 100% { opacity: 1; filter: blur(0); } }
.loading-spinner-overlay.fade-in { animation: fadeInBlur 0.5s ease-in-out forwards; }

@keyframes fadeOutBlur { 0% { opacity: 1; filter: blur(0px); } 100% { opacity: 0; filter: blur(5px); } }
.loading-spinner-overlay.fade-out { animation: fadeOutBlur 0.5s ease-in-out forwards; }

@keyframes fadeInScale { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } } /* Adjusted scale */
@keyframes fadeOutScale { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.95); } } /* Adjusted scale */
.modal.fade-in { animation: fadeInScale 0.3s forwards; } /* Faster modal fade */
.modal.fade-out { animation: fadeOutScale 0.3s forwards; }

@keyframes wipeOn { 0% { opacity: 0; transform: scaleX(0); } 100% { opacity: 1; transform: scaleX(1); } }
.text-wipe-on span { display: inline-block; overflow: hidden; animation: wipeOn 0.1s forwards; opacity: 0; transform-origin: left; }

.text-fade-in { opacity: 0; transition: opacity 0.5s ease-in-out; }
.fonts-loaded .text-fade-in { opacity: 1; }


/* ================================================== */
/* == 18. Text Input Styles (Goal Input - Unchanged) == */
/* ================================================== */
.user-input { font-weight: bold; font-size: 1.2rem; }
.user-input-display { font-weight: bold; font-size: 1.2rem; }
.user-input-edit {
  font-weight: bold; font-size: 1.2rem; border: none;
  width: 100%; background-color: transparent; padding: 0.25rem;
}
.user-input-edit:focus {
  background-color: #e9ecef; outline: none;
  box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
}

/* ================================================== */
/* == 19. Table Row Styles (Goal Input - Unchanged) === */
/* ================================================== */
.table-bordered > thead > tr > th { border-bottom: 2px dotted #dee2e6; }


/* ================================================== */
/* ==========  20. Editing State Styles (COS Table)  ============= */
/* ================================================== */
/* These control visibility of display spans vs edit inputs within table cells */
.cos-row td .cos-content-edit,
.cos-row td .cos-accountable-party-edit,
.cos-row td .cos-completion-date-edit,
.cos-row td select.status-edit-select {
    display: none; /* Hide edit fields by default */
}

.cos-row[data-editing="true"] td .cos-content-display,
.cos-row[data-editing="true"] td .cos-accountable-party-display,
.cos-row[data-editing="true"] td .cos-completion-date-display,
.cos-row[data-editing="true"] td .status-pill { /* Hide display spans/pill in edit mode */
    display: none !important;
}

.cos-row[data-editing="true"] td .cos-content-edit,
.cos-row[data-editing="true"] td .cos-accountable-party-edit,
.cos-row[data-editing="true"] td .cos-completion-date-edit,
.cos-row[data-editing="true"] td select.status-edit-select {
    display: block; /* Show edit fields in edit mode */
    width: 100%; /* Make inputs take full cell width */
}
.cos-row[data-editing="true"] td select.status-edit-select {
    font-size: 0.8rem; /* Smaller font for select in table */
}


/* Button visibility toggling (JS also helps with d-none, this is CSS backup/primary) */
.cos-row .update-cos-button,
.cos-row .cancel-cos-button {
    display: none;
}
.cos-row[data-editing="true"] .edit-cos-button,
.cos-row[data-editing="true"] .delete-cos-button, /* Hide delete/analyze during edit */
.cos-row[data-editing="true"] .analyze-cos-button {
    display: none !important;
}
.cos-row[data-editing="true"] .update-cos-button,
.cos-row[data-editing="true"] .cancel-cos-button {
    display: inline-block !important;
}


/* ================================================== */
/* ===========  21. Modal Custom Styling  ============ */
/* ================================================== */
.modal-content {
  border-radius: 10px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  border: 2px solid transparent; max-height: 90vh;
  display: flex; flex-direction: column;
}
.modal-header, .ce-modal-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 1rem 1.5rem; border-top-left-radius: 8px; border-top-right-radius: 8px;
  position: relative; color: white;
}
.ce-modal-header .node-icon {
  background-color: white; border-radius: 5px; padding: 8px 10px;
  margin-right: 1rem; flex-shrink: 0; display: inline-flex;
  align-items: center; justify-content: center;
}
.ce-modal-header .node-icon i { font-size: 1.25rem; }

.modal-title, .ce-modal-header .modal-title.ce-title {
  font-family: 'Unica One', sans-serif; font-weight: 500; text-transform: uppercase;
  text-shadow: 1px 1px 1px rgba(0,0,0,0.4); color: white;
  font-size: 1.5rem; margin-right: 0.5rem; line-height: 1.2;
}
.ce-modal-header .modal-title.ce-title { font-size: 1.6rem; }

.ce-modal-header .phase-name {
  font-family: 'Jost', sans-serif; font-size: 0.85rem; font-style: italic;
  text-transform: uppercase; color: rgba(255, 255, 255, 0.9);
  margin-left: auto; margin-right: 1rem; white-space: nowrap; line-height: 1.2;
}
.modal-header .close-button, .ce-modal-header .close-button {
  background: transparent; border: none; color: white; font-size: 1.75rem;
  opacity: 0.8; padding: 0.25rem 0.75rem; line-height: 1; text-shadow: none; margin-left: 0.5rem;
}
.modal-header .close-button:hover, .ce-modal-header .close-button:hover { opacity: 1; }

.modal-body, .ce-modal-body {
  flex-grow: 1; overflow-y: auto; padding: 1.5rem;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
}
.ce-modal-body { padding: 2rem; }
.ce-modal-body .section { margin-bottom: 2rem; }
.ce-modal-body .section:last-child { margin-bottom: 0.5rem; }
.ce-modal-body .sub-section { margin-bottom: 1.5rem; }

.modal-body .context-label {
  font-family: 'Unica One', sans-serif; font-size: 1rem; font-weight: 500;
  color: #104a3a; margin-bottom: 0.5rem; text-transform: uppercase; display: block;
}
.modal-body .content-block {
  background-color: #f8f9fa; border-left: 3px solid #dee2e6;
  padding: 0.75rem 1rem; margin-bottom: 1rem; color: #212529; line-height: 1.5;
}
.modal-body .content-block.italic { font-style: italic; }
.modal-body .definition-text { font-size: 0.9rem; color: #495057; line-height: 1.45; margin-bottom: 0.75rem; }

.modal-footer { padding: 1rem 1.5rem; background-color: #f8f9fa; border-top: 1px solid #dee2e6; }
.btn-save-changes {
  background-color: var(--bs-primary); border-color: var(--bs-primary);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
.btn-save-changes:hover { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }

/* Dynamic Phase Colors for Modals */
[data-phase-index="0"] .modal-content { border-color: var(--phase-0) !important; }
[data-phase-index="0"] .modal-header, [data-phase-index="0"] .ce-modal-header { background-color: var(--phase-0) !important; }
[data-phase-index="0"] .ce-modal-header .node-icon i { color: var(--phase-0) !important; }
/* Repeat for phase-1 to phase-4 */
[data-phase-index="1"] .modal-content { border-color: var(--phase-1) !important; }
[data-phase-index="1"] .modal-header, [data-phase-index="1"] .ce-modal-header { background-color: var(--phase-1) !important; }
[data-phase-index="1"] .ce-modal-header .node-icon i { color: var(--phase-1) !important; }
[data-phase-index="2"] .modal-content { border-color: var(--phase-2) !important; }
[data-phase-index="2"] .modal-header, [data-phase-index="2"] .ce-modal-header { background-color: var(--phase-2) !important; }
[data-phase-index="2"] .ce-modal-header .node-icon i { color: var(--phase-2) !important; }
[data-phase-index="3"] .modal-content { border-color: var(--phase-3) !important; }
[data-phase-index="3"] .modal-header, [data-phase-index="3"] .ce-modal-header { background-color: var(--phase-3) !important; }
[data-phase-index="3"] .ce-modal-header .node-icon i { color: var(--phase-3) !important; }
[data-phase-index="4"] .modal-content { border-color: var(--phase-4) !important; }
[data-phase-index="4"] .modal-header, [data-phase-index="4"] .ce-modal-header { background-color: var(--phase-4) !important; }
[data-phase-index="4"] .ce-modal-header .node-icon i { color: var(--phase-4) !important; }


/* ================================================== */
/* =========  22. Tabulator Table Styling  ============ */
/* ================================================== */
.tabulator {
  border-radius: 5px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
  margin-bottom: 1.5rem; border: 1px solid #dee2e6;
}
.resources-table { margin-top: 1.5rem; margin-bottom: 1.5rem; max-height: 350px; }
.tabulator-header {
  font-family: 'Jost', sans-serif; font-weight: 600; font-size: 0.85em;
  border-bottom: 2px solid #adb5bd; background-color: #f8f9fa; color: #343a40;
}
.tabulator-header .tabulator-col { border-right: 1px solid #e9ecef; background-color: transparent; }
.tabulator-header .tabulator-col:last-child { border-right: none; }
.tabulator-row { background-color: #ffffff; border-bottom: 1px solid #f1f3f5; }
.tabulator-row:nth-child(even) { background-color: #fbfcfd; }
.tabulator-row:hover { background-color: #e9f2fa; }
.tabulator-row:last-child { border-bottom: none; }
.tabulator-cell {
  padding: 10px 12px; border: none; white-space: normal; overflow: visible;
  word-wrap: break-word; height: auto; font-size: 0.9rem;
}
/* Dynamic Phase Colors for Tabulator Headers */
[data-phase-index="0"] .tabulator-header { border-bottom-color: var(--phase-0) !important; }
[data-phase-index="1"] .tabulator-header { border-bottom-color: var(--phase-1) !important; }
[data-phase-index="2"] .tabulator-header { border-bottom-color: var(--phase-2) !important; }
[data-phase-index="3"] .tabulator-header { border-bottom-color: var(--phase-3) !important; }
[data-phase-index="4"] .tabulator-header { border-bottom-color: var(--phase-4) !important; }

.form-group { font-weight: normal; font-size: 0.9em; margin-bottom: 0.75rem; }
.form-group label {
    display: block; margin-bottom: 0.35rem; font-family: 'Jost', sans-serif;
    font-weight: 500; font-size: 0.85rem; color: #454545;
}


/* ================================================== */
/* =======  23. Hidden Text Utility Class  =========== */
/* ================================================== */
.hidden-text { opacity: 0; }


/* ================================================== */
/* =======  24. CE Modal Specific Styles ============ */
/* ================================================== */
.modal-dialog.ce-modal { max-width: 90%; width: auto; margin: 1.75rem auto; }
.ce-modal-body .section-heading {
    font-size: 1.4rem; color: #104a3a; text-shadow: none;
    border-bottom: 1px solid #dee2e6; padding-bottom: 0.5rem; margin-bottom: 1.5rem;
}
.ce-modal-body .sub-heading {
    font-family: 'Unica One', sans-serif; font-weight: 500; color: #333;
    font-size: 1rem; text-transform: uppercase; letter-spacing: 0.05em;
    margin-top: 1.5rem; margin-bottom: 0.75rem;
}
.ce-modal-body .form-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1rem 1.5rem; margin-bottom: 2rem;
}
.ce-modal-body .form-group label { font-size: 0.9rem; font-weight: 500; color: #343a40; margin-bottom: 0.4rem; }
.ce-modal-body .form-input, .ce-modal-body .form-control,
.ce-modal-body .form-textarea, .ce-modal-body .form-select {
    padding: 0.5rem 0.75rem; font-size: 0.95rem; border-radius: 0.25rem;
    border: 1px solid #ced4da; width: 100%;
}
.ce-modal-body .form-textarea { min-height: 100px; }
.ce-modal-body .action-row {
    margin-top: 1.5rem; margin-bottom: 1.5rem; display: flex;
    flex-wrap: wrap; gap: 0.75rem;
}
.ce-modal-body .action-row .btn { padding: 0.5rem 1rem; font-size: 0.9rem; }
.ce-modal-footer { padding: 1rem 1.5rem; background-color: #f8f9fa; border-top: 1px solid #dee2e6; }
.ce-modal-body .ce-pills-container { margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 8px 10px; }
.ce-modal-body .ce-pill { padding: 5px 12px; font-size: 0.9rem; }

/* Ensure d-none utility class works as expected */
.d-none { display: none !important; }
