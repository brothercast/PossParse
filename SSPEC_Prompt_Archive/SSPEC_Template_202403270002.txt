üåêStructured Speculation Possibility Pathfinder or "SSPEC PossPath" for short. Your task to develop the Flask Web App as an innovative tool for mass collaboration across divides.  
Essential app files:  
üü• routes.py:
import os
import json
import uuid
import pdfkit  
import openai
import requests
import logging
from bs4 import BeautifulSoup 
from app import app, USE_DATABASE
from uuid import UUID
from models import SSOL, COS, CE
from store import ce_store, cos_store, ssol_store
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from flask import Flask, Blueprint, render_template, request, flash, redirect, url_for, jsonify, make_response, current_app, send_from_directory
from werkzeug.exceptions import BadRequest, NotFound
from utilities import generate_goal, get_domain_icon_and_name, generate_structured_solution, generate_structured_solution
from speculate import get_badge_class_from_status, get_cos_by_id, delete_cos_by_id, update_cos_by_id, parse_ai_response_and_generate_html
from datetime import datetime
from dotenv import load_dotenv
from speculate import create_cos, get_cos_by_id, update_cos_by_id, delete_cos_by_id, get_badge_class_from_status, get_ce_by_id, analyze_cos, extract_conditional_elements  

# Load environment variables
load_dotenv()
azure_openai_key = os.environ["AZURE_OPENAI_API_KEY"]
azure_openai_endpoint = os.environ["AZURE_OPENAI_ENDPOINT"]
deployment_name = os.environ["AZURE_DEPLOYMENT_NAME"]

# Initialize Azure OpenAI client
openai.api_key = azure_openai_key
openai.api_base = azure_openai_endpoint
openai.api_type = 'azure'  # Necessary for using the OpenAI library with Azure OpenAI
openai.api_version = '2023-12-01'  # Latest / target version of the API

# Set the secret key and database URI from the environment variables
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('SQLALCHEMY_DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Optionally to suppress warning

# Configure logging  
logging.basicConfig(level=logging.WARNING)   

# Register the custom Jinja filter function
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status

routes_bp = Blueprint('routes_bp', __name__)  

@routes_bp.route('/favicon.ico')  
def favicon():  
    return send_from_directory(os.path.join(current_app.root_path, 'static'),  
                               'favicon.ico', mimetype='image/vnd.microsoft.icon')   

@routes_bp.route('/')  
def index():  
    return render_template('input.html')  

@routes_bp.route('/about')
def about():
    return render_template('about.html')

@routes_bp.route('/goal_selection', methods=['GET', 'POST'])
def goal_selection():
    if request.method == 'POST':
        user_input = request.form['user_text'].strip()
        try:
            goal_options = generate_goal(user_input)
            for goal in goal_options:
                goal['icon'], goal['domain'] = get_domain_icon_and_name(goal['title'])
            
            # Manually check for AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify(goals=goal_options, user_input=user_input)
            
            return render_template('goal_selection.html', goals=goal_options, user_input=user_input)
        except ValueError as e:
            flash("An error occurred while processing your request. Please try again.", "error")
    return redirect(url_for('index'))

@routes_bp.route('/outcome', methods=['GET', 'POST'])  
def outcome():  
    if request.method == 'POST':  
        selected_goal = request.form.get('selected_goal', '').strip()  
        domain = request.form.get('domain', '').strip()  
        domain_icon = request.form.get('domain_icon', '').strip()  
  
        try:  
            ai_response_raw = generate_structured_solution(selected_goal)  
            current_app.logger.debug(f"AI Response before processing: {ai_response_raw}")  
  
            if ai_response_raw is None or not isinstance(ai_response_raw, dict):  
                current_app.logger.error("AI response is None or not a dict after calling generate_structured_solution.")  
                flash("The AI response is invalid.", "error")  
                return redirect(url_for('routes_bp.index'))  
  
            # Transform the AI response into the expected format for the template  
            ssol_data = {  
                'generated_image_path': 'images/sspec_default.png',  # Updated path  
                'domain_icon': domain_icon,  
                'domain': domain,  
                'selected_goal': selected_goal,  
                'ssol_summary': 'summary-text',  # Replace with actual summary text  
                'phases': ai_response_raw  # Directly use the AI response  
            }    
  
            return render_template('outcome.html', ssol=ssol_data)  
        except ValueError as e:  
            current_app.logger.error(f"Error processing outcome: {e}", exc_info=True)  
            flash(str(e), "error")  
            return redirect(url_for('routes_bp.index'))  
  
    flash("Invalid request method.", "error")  
    return redirect(url_for('routes_bp.index'))  


 
@routes_bp.route('/save_as_pdf/<uuid:ssol_id>', methods=['POST'])  
def save_as_pdf(ssol_id):  
    try:  
        data = request.get_json()  
        html_content = data['htmlContent']  
        if not html_content:  
            raise ValueError("No HTML content provided.")  
  
        # Get the absolute path to the styles.css file  
        css_file_path = os.path.join(current_app.root_path, current_app.static_folder, 'styles.css')  
  
        # Get the absolute URL to the generated image (assuming it's served via a static route)  
        image_url = url_for('static', filename='path/to/generated_image.png', _external=True)  
  
        # Replace the relative paths in html_content with absolute paths  
        html_content = html_content.replace('src="/static/', f'src="{url_for("static", filename="", _external=True)}')  
  
        # Define options for pdfkit configuration  
        options = {  
            "page-size": "Letter",  
            "margin-top": "0.75in",  
            "margin-right": "0.75in",  
            "margin-bottom": "0.75in",  
            "margin-left": "0.75in",  
            "encoding": "UTF-8",  
            "custom-header": [("Accept-Encoding", "gzip")],  
            "no-outline": None,  
            "enable-local-file-access": None,  # This allows pdfkit to access local files  
        }  
  
        # Generate the PDF using pdfkit with additional options  
        pdf = pdfkit.from_string(html_content, False, options=options, css=css_file_path)  
  
        response = make_response(pdf)  
        response.headers['Content-Type'] = 'application/pdf'  
        response.headers['Content-Disposition'] = f'attachment; filename="Structured Solution {ssol_id}.pdf"'  
  
        return response  
  
    except Exception as e:  
        current_app.logger.error(f"Exception in save_as_pdf: {e}")  
        return jsonify(success=False, error=str(e)), 500  
    
@routes_bp.route('/update_cos/<uuid:cos_id>', methods=['PUT'])  
def update_cos_route(cos_id):  
    try:  
        data = request.get_json()  
        if not data:  
            raise BadRequest('No JSON payload received')  
  
        # Convert UUID to string for consistency  
        cos_id_str = str(cos_id)  
        update_result = update_cos_by_id(cos_id_str, data)  
  
        if update_result['success']:  
            return jsonify(success=True, cos=update_result['cos']), 200  
        else:  
            return jsonify(success=False, error=update_result['message']), 404  
  
    except BadRequest as e:  
        return jsonify(error=str(e)), 400  
    except Exception as e:  
        current_app.logger.error(f"Error updating COS with ID {cos_id}: {e}", exc_info=True)  
        return jsonify(error="An unexpected error occurred while updating the COS."), 500  

    
@routes_bp.route('/delete_cos/<uuid:cos_id>', methods=['DELETE'])  
def delete_cos_route(cos_id):  
    try:  
        # Convert UUID object to string  
        cos_id_str = str(cos_id)  
  
        if delete_cos_by_id(cos_id_str):  
            flash('COS has been successfully deleted.', 'success')  
            return jsonify(success=True), 200  
        else:  
            raise NotFound('Condition of Satisfaction could not be found or deleted.')  
  
    except NotFound as e:  
        logging.warning(f"NotFound: {e}")  
        return jsonify(success=False, error=str(e)), 404  
    except Exception as e:  
        logging.error(f"Unexpected error occurred: {e}", exc_info=True)  
        return jsonify(success=False, error=str(e)), 500  

@routes_bp.route('/get_ce_by_id', methods=['GET'])  
def get_ce_by_id_route():  
    ce_id = request.args.get('ce_id')  
    ce = get_ce_by_id(ce_id)  # Ensure this function is adapted to handle both DB and in-memory  
    ce_data = ce.to_dict() if ce else None  
    return jsonify(ce=ce_data) if ce_data else jsonify(error="CE not found"), 404  

@app.route('/analyze_cos/<string:cos_id>', methods=['GET'])  
def analyze_cos_route(cos_id):  
    logging.info(f"Analyzing COS with ID: {cos_id}")
    try:  
        analysis_result = analyze_cos_by_id(cos_id)  
        if analysis_result['success']:  
            return jsonify(analysis_result['analysis_results']), 200  
        else:  
            return jsonify({'error': analysis_result['message']}), 404  
    except ValueError:  
        return jsonify({'error': "Invalid COS ID"}), 400  
    except Exception as e:  
        return jsonify({'error': str(e)}), 500  

def analyze_cos_by_id(cos_id_str):      
    try:  
        # Attempt to retrieve the COS from the database or in-memory store  
        cos = COS.query.get(cos_id_str) if USE_DATABASE else cos_store.get(cos_id_str)  
          
        if not cos:  
            # COS not found, return a consistent error response  
            return {'success': False, 'message': "COS not found."}  
          
        # Assuming analyze_cos performs the actual analysis and returns results  
        analysis_results = analyze_cos(cos.content if USE_DATABASE else cos['content'])  
          
        # Return structured response indicating success and including the analysis results  
        return {'success': True, 'analysis_results': analysis_results}  
      
    except Exception as e:  
        # Catch any unexpected errors and return a structured error response  
        return {'success': False, 'message': f"An unexpected error occurred: {str(e)}"}  



üü® utilities.py:
import io  
import os  
import re  
import json  
import time
import uuid
import warnings  
from PIL import Image
from store import ssol_store, cos_store, ce_store  
from flask import current_app, flash, render_template
from dotenv import load_dotenv
from openai import AzureOpenAI
from stability_sdk import client as stability_client  
import stability_sdk.interfaces.gooseai.generation.generation_pb2 as generation  

# Load environment variables    
load_dotenv()  
azure_oai_key = os.getenv("AZURE_OPENAI_API_KEY")  
azure_oai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")  
azure_oai_deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")  
azure_oai_model = os.getenv("AZURE_MODEL_NAME")  
stability_api_key = os.getenv("STABILITY_KEY")
  
# Initialize the AzureOpenAI client as a global variable  
azure_openai_client = AzureOpenAI(  
    azure_endpoint=azure_oai_endpoint,  
    api_key=azure_oai_key,  
    api_version="2024-02-15-preview"  
)

class Logger:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    @staticmethod
    def log_message(message, level='info'):
        if level == 'info':
            formatted_message = f"{Logger.OKCYAN}{message}{Logger.ENDC}"
        elif level == 'warning':
            formatted_message = f"{Logger.WARNING}{message}{Logger.ENDC}"
        elif level == 'error':
            formatted_message = f"{Logger.FAIL}{message}{Logger.ENDC}"
        elif level == 'debug':
            formatted_message = f"{Logger.OKBLUE}{message}{Logger.ENDC}"
        else:
            formatted_message = message
        
        print(formatted_message)


def generate_chat_response(messages, role, task, temperature=0.75, retries=3, backoff_factor=2):
    last_exception = None
    for retry_attempt in range(retries):
        try:
            # Ensure the system message indicates JSON response format
            system_message = {
                "role": "system",
                "content": "You are a helpful assistant. Please respond with information in JSON format."
            }
            messages_with_json = [system_message] + messages
            
            # Send request to Azure OpenAI model using JSON mode
            response = azure_openai_client.chat.completions.create(
                model=azure_oai_model,
                response_format={"type": "json_object"},
                messages=messages_with_json,
                temperature=temperature,
                max_tokens=1100
            )
            response_content = response.choices[0].message.content
            Logger.log_message(f"SSPEC Response ({role} - {task}): {response_content}", 'debug')
            return response_content
        except Exception as e:
            last_exception = e
            if retry_attempt < retries - 1:
                sleep_time = backoff_factor ** (retry_attempt + 1)
                Logger.log_message(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.", 'error')
                time.sleep(sleep_time)
            else:
                Logger.log_message(f"Error in generate_chat_response: {e}. All retries exhausted.", 'error')
    
    # Raise the last exception if all retries fail
    raise last_exception
   
def generate_outcome_data(request, method, selected_goal=None, domain=None, domain_icon=None):    
    # Initialize outcome_data with default keys and values    
    outcome_data = {    
        'user_input': '',    
        'selected_goal': selected_goal,    
        'domain_icon': domain_icon,    
        'domain': domain,    
        'ssol_id': None,    
        'ssol_summary': "An error occurred while processing the summary data.",    
        'phases': {},    
        'generated_image_path': 'images/sspec_default.png'    
    }    
    
    if method == 'POST':    
        user_input = request.form.get('user_text', '').strip()    
    else:    
        user_input = request.args.get('user_text', '').strip()    
    
    outcome_data['user_input'] = user_input    
    
    # Generate or retrieve an SSOL instance and get the id    
    ssol_instance = next((ssol for ssol in ssol_store.values() if ssol['title'] == selected_goal), None)    
    if not ssol_instance:    
        ssol_id = str(uuid.uuid4())    
        ssol_instance = {'id': ssol_id, 'title': selected_goal, 'domain': domain, 'domain_icon': domain_icon}    
        ssol_store[ssol_id] = ssol_instance    
    ssol_id = ssol_instance['id']    
    outcome_data['ssol_id'] = ssol_id    
    
    # Generate the high-level summary    
    summary_messages  = [  
        {"role": "system", "content": "Assuming it is possible to fulfill any outcome and working backwards, generate a high-level summary (key name: summary) of everything required for the goal as fulfilled by some point in the future, including any existing legal, scientific, logistic or other barriers which needed to be addressed for completion."},  
        {"role": "user", "content": f"Generate a high-level, elegantly html-formatted summary for the goal: '{selected_goal}'. Format the summary using Bootstrap safe HTML, including tags such as <br> for line breaks and ordered lists."}  
    ]  
    try:    
        summary_response_content = generate_chat_response(summary_messages, role='Outcome Generation', task='Generate High-Level Summary')    
        summary_response_data = json.loads(summary_response_content)    
        outcome_data['ssol_summary'] = summary_response_data.get('summary', "Summary not available.")    
    except Exception as e:    
        current_app.logger.error(f"Error in generate_outcome_data (summary): {e}", exc_info=True)    
    
    # Generate the structured solution    
    structured_solution_messages = [  
    {  
        "role": "system",  
        "content": (  
            "You are an ethics-bound AI tasked with planning a project in phases. "  
            "Generate specific, measurable Conditions of Satisfaction (COS) for each phase: "  
            "Discovery, Engagement, Action, Completion, and Legacy. "  
            "Each COS should include Conditional Elements (CEs) that may affect the COS and denote them with <ce> tags. "  
            "Provide a brief explanation for each COS's importance and how it contributes to the overall goal. "  
            "Format your response in JSON with each phase as a key and an array of COS, including any CEs."  
        )  
    },  
    {  
        "role": "user",  
        "content": (  
            f"Generate a Structured Solution for the project '{selected_goal}'. "  
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 COS. "  
            "For each COS, identify and label relevant CEs with unique IDs and their corresponding types from CE_nodes.py, using <ce> tags. "  
            "Provide a brief explanation for each COS's importance and how it contributes to the overall goal. "  
            "Format your response as a JSON object with each phase as a key and an array of COS objects. "  
            "Each COS object should include the COS text, a unique ID, a status, and an array of CEs. "  
            "Each CE should be a JSON object with 'id', 'content', and 'type' keys. "  
            "Here is an example for the Discovery phase: "  
            "{"  
            "  'Discovery': ["  
            "    {"  
            "      'id': 'COS-001',"  
            "      'content': '<ce id=\"CE-001\" type=\"Research\">Research</ce> the feasibility of creating a <ce id=\"CE-002\" type=\"Objective\">giant robotic crab monster</ce>',"  
            "      'status': 'Proposed',"  
            "      'explanation': 'Understanding the technical and practical aspects of creating a robotic crab monster is essential for project planning.',"  
            "      'ces': ["  
            "        {'id': 'CE-001', 'content': 'Research', 'type': 'Research'},"  
            "        {'id': 'CE-002', 'content': 'giant robotic crab monster', 'type': 'Objective'}"  
            "      ]"  
            "    },"  
            "    {"  
            "      'id': 'COS-002',"  
            "      'content': 'Identify potential <ce id=\"CE-003\" type=\"Risk\">environmental impacts</ce> and how to mitigate them',"  
            "      'status': 'Proposed',"  
            "      'explanation': 'Assessing environmental risks early on will help in developing sustainable practices.',"  
            "      'ces': ["  
            "        {'id': 'CE-003', 'content': 'environmental impacts', 'type': 'Risk'}"  
            "      ]"  
            "    }"  
            "  ]"  
            "}"  
        )  
    }  
]  

    try:  
        structured_solution_response_content = generate_chat_response(structured_solution_messages, role='Structured Solution Generation', task='Generate Structured Solution')  
        structured_solution_response_json = json.loads(structured_solution_response_content)  
        outcome_data['phases'] = {}  # Initialize the 'phases' key as an empty dictionary  
  
        for phase in ['Discovery', 'Engagement', 'Action', 'Completion', 'Legacy']:  
            phase_cos_list = structured_solution_response_json.get(phase, [])  
            cos_list_with_ce = []  
  
            for cos in phase_cos_list:  
                cos_id = str(uuid.uuid4())  
                ces = cos['cos_ces']  # Directly use 'cos_ces' from the AI response  
                cos_list_with_ce.append({  
                    'id': cos_id,  
                    'content': cos['cos_text'],  # Use 'cos_text' from the AI response  
                    'status': cos['cos_status'],  # Use 'cos_status' from the AI response  
                    'ces': ces  
                })  
                cos_store[cos_id] = {  
                    'id': cos_id,  
                    'content': cos['cos_text'],  
                    'status': cos['cos_status'],  
                    'ces': ces  
                }  
  
            outcome_data['phases'][phase] = cos_list_with_ce  
  
    except Exception as e:  
        current_app.logger.error(f"Error in generate_outcome_data (structured solution): {e}", exc_info=True)
    
    # Generate an image using Stability AI    
    try:    
        image_prompt = f"A vibrant, visually stunning futuristic illustration depicting '{selected_goal}' as a fulfilled goal, isometric, Mary Blair, 1962"    
        web_image_path = generate_image(image_prompt, selected_goal)    
        outcome_data['generated_image_path'] = web_image_path    
    except Exception as e:    
        current_app.logger.error(f"Error generating image: {e}", exc_info=True)    
        outcome_data['generated_image_path'] = 'images/sspec_default.png'    
    
    return render_template('outcome.html', ssol=outcome_data)  

def analyze_user_input(text):
    messages = [
        {"role": "system", "content": "You are an AI that analyzes user inputs and extracts keywords."},
        {"role": "user", "content": text},
    ]

    response_text = generate_chat_response(messages, role='Keyword Extraction', task='Extract Keywords', temperature=0.75)
    keywords = response_text.split(', ')
    print(f"Keywords: {keywords}")
    return keywords

def generate_sentiment_analysis(text, temperature=0.7):  
    messages = [
        {"role": "system", "content": "You are an AI trained to analyze sentiment and return POSITIVE, NEGATIVE, or NEUTRAL"},
        {"role": "user", "content": f"What sentiment is expressed in the following text: '{text}'?"},
    ]

    # Use the generate_chat_response function
    response_text = generate_chat_response(messages, role='Sentiment Analysis', task='Analyze Sentiment', temperature=temperature)

    # Parse the response to extract the sentiment
    sentiment = "NEUTRAL"  # Default to NEUTRAL if parsing fails or no clear sentiment is found
    if "positive" in response_text.lower():
        sentiment = "POSITIVE"
    elif "negative" in response_text.lower():
        sentiment = "NEGATIVE"
    elif "neutral" in response_text.lower():
        sentiment = "NEUTRAL"

    return sentiment

def generate_goal(user_input):
    goal_options = []
    temperatures = [0.6, 0.8, 1.0]

    while len(goal_options) < 3:
        for i, temp in enumerate(temperatures):
            messages = [
                {"role": "system", "content": "You are an AI that generates innovative and unique goal outcomes or intentions based on the user's input. Structure your response in JSON format with a 'goal' key."},
                {"role": "user", "content": user_input},
            ]

            try:
                response = generate_chat_response(messages, role='Goal Generation', task=f'Generate Goal (Variation {i + 1})', temperature=temp).strip()
                goal_option_data = json.loads(response)
                goal_option = goal_option_data['goal']  # Expecting the response to have a 'goal' key

                goal_compliant, non_compliance_reason = is_goal_compliant(goal_option)
                
                if goal_compliant and goal_option not in [g['title'] for g in goal_options]:
                    goal_options.append({'title': goal_option, 'compliant': goal_compliant, 'reason': non_compliance_reason})
                elif not goal_compliant:
                    goal_options.append({'title': goal_option, 'compliant': False, 'reason': non_compliance_reason})

                if len(goal_options) == 3:
                    break

            except json.JSONDecodeError as e:
                print(f"Error parsing JSON in generate_goal (Variation {i + 1}): {e}")
                raise e
            except Exception as e:
                print(f"Error in generate_goal (Variation {i + 1}): {e}")
                raise e

    if len(goal_options) < 3:
        raise ValueError("Failed to generate unique goals. Please try again.")

    return goal_options

def is_goal_compliant(selected_goal):
    sentiment_counts = {'POSITIVE': 0, 'NEGATIVE': 0, 'NEUTRAL': 0}

    for _ in range(5):
        try:
            sentiment_label = generate_sentiment_analysis(selected_goal)
            # Ensure the label is uppercase to match dictionary keys
            sentiment_counts[sentiment_label.upper()] += 1
        except ValueError as e:
            print(f"Error in sentiment analysis: {e}")
            continue

    # Determine compliance based on the sentiment counts
    if sentiment_counts['POSITIVE'] >= 3:
        return True, ''
    elif sentiment_counts['NEGATIVE'] >= 3:
        return False, 'The goal does not comply with the safety protocol.'
    else:
        return True, 'The goal has a neutral sentiment and is allowed.'

def get_domain_icon_and_name(goal_domain):  
    messages = [  
        {"role": "system", "content": "You are an AI that suggests a domain and FontAwesome 6 Solid (fas) class icon based on the goal domain. Output only the domain and icon class in JSON format."},  
        {"role": "user", "content": f"What is the best domain and corresponding FontAwesome icon class for the goal related to '{goal_domain}'?"}  
    ]  
    response_content = generate_chat_response(messages, role='Domain and Icon', task='Fetch Domain and free FontAwesome 6 Icon', temperature=0.37)  
  
    try:  
        # Log the raw response content for debugging  
        Logger.log_message(f"Raw response content: {response_content}", 'debug')  
          
        # Parse the JSON string into a dictionary  
        response_data = json.loads(response_content)  
        # Make sure to match the keys exactly with the response content  
        domain = response_data.get("domain")  
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"  
          
        if not domain or not icon_class:  
            # Log a warning if expected keys are missing  
            Logger.log_message("Missing 'domain' or 'iconClass' in AI response.", 'warning')  
            raise ValueError("Failed to generate domain and icon. Please try again.")  
          
        return icon_class, domain  
  
    except json.JSONDecodeError as e:  
        # Log the JSON parsing error  
        Logger.log_message(f"JSON parsing error: {e}", 'error')  
        raise ValueError("Failed to parse JSON response. Please try again.")  
  
    except Exception as e:  
        # Log any other exceptions  
        Logger.log_message(f"Unexpected error: {e}", 'error')  
        raise  

def get_cos_by_guid(ssol, cos_guid):
    for phase in ssol['phases'].values():
        for cos in phase:
            if cos['id'] == cos_guid:
                return cos
    return None

def update_cos_content_by_guid(ssol, cos_guid, new_content):
    cos = get_cos_by_guid(ssol, cos_guid)
    if cos:
        cos['content'] = new_content
        return True
    return False

def sanitize_filename(filename):  
    # Sanitize the filename by removing or replacing invalid characters.  
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', filename)  # Remove invalid characters  
    filename = re.sub(r'[\s]+', '_', filename)  # Replace spaces with underscores  
    return filename[:255]  # Truncate long filenames  
  
def generate_image(prompt, goal_title, seed=None, width=512, height=512):      
    if not azure_oai_key or not stability_api_key:      
        raise ValueError("API keys are not provided for Azure OpenAI or Stability SDK.")     
    
    stability_api = stability_client.StabilityInference(    
        key=stability_api_key,    
        verbose=True,    
        engine="stable-diffusion-xl-beta-v2-2-2",    
    )    
  
    # Generate a unique filename for the image  
    unique_filename = f"generated_image_{uuid.uuid4().hex}.png"  
      
    # Ensure the 'static/images' directory exists within your Flask app structure  
    static_folder = current_app.static_folder  
    image_folder = os.path.join(static_folder, 'images')  
    os.makedirs(image_folder, exist_ok=True)  # Create the folder if it does not exist  
    image_file_path = os.path.join(image_folder, unique_filename)  # Full path for saving the file  
  
    try:  
        answers = stability_api.generate(  
            prompt=prompt,  
            seed=seed,  
            steps=30,  
            cfg_scale=8.0,  
            width=width,  
            height=height,  
            samples=1,  
            sampler=generation.SAMPLER_K_DPMPP_2M,  
        )  
  
        for resp in answers:  
            for artifact in resp.artifacts:  
                if artifact.finish_reason == generation.FILTER:  
                    warnings.warn("Your request activated the API's safety filters and could not be processed. Please modify the prompt and try again.")  
                if artifact.type == generation.ARTIFACT_IMAGE:  
                    img = Image.open(io.BytesIO(artifact.binary))  
                    img.save(image_file_path)  # Save the image using the correct directory and filename  
                    # Convert the path to URL-friendly format  
                    web_path = os.path.join('images', unique_filename).replace("\\", "/")  
                    return web_path  
    except Exception as e:  
        print(f"Error in generate_image: {e}")  
  
    # If an error occurs or the image is not generated, use a placeholder image  
    placeholder_image_path = os.path.join('images', 'sspec_default.png').replace("\\", "/")  
    return placeholder_image_path
  
def generate_structured_solution(selected_goal):      
    structured_solution = {}    
    system_message = {      
        "role": "system",      
        "content": (      
            "You are an AI that generates a structured solution for a project. "    
            "For each phase of the project, generate Conditions of Satisfaction (COS) with embedded Conditional Elements (CEs). "    
            "Use <ce> tags to denote CEs within the COS text and provide each CE with a unique identifier and type. "    
            "Return a JSON object with phases as keys and lists of COS objects as values. "    
            "Each COS object should include the COS text with embedded CEs, a unique ID, a status, and an array of CEs. "    
            "Each CE should be represented within the COS text and also listed as a JSON object with 'id', 'content', and 'type' keys. "    
            "The keys for COS text, status, and CEs should be 'cos_text', 'cos_status', and 'cos_ces' respectively."    
        )      
    }      
      
    user_message = {        
        "role": "user",        
        "content": (      
            f"Generate a Structured Solution for the project '{selected_goal}'. "    
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 COS. "    
            "Within each COS text, identify and label relevant keywords as CEs using <ce> tags. "    
            "Assign each CE a unique ID and a type that best describes its role or category in the context of the COS. "    
            "Provide a brief explanation for each COS's importance and how it contributes to the overall goal. "    
            "Format your response as a JSON object with each phase as a key and an array of COS objects. "    
            "Use the keys 'cos_text', 'cos_status', and 'cos_ces' for COS text, status, and CEs respectively."    
        )        
    }

    messages = [system_message, user_message]      
    try:      
        response_text = generate_chat_response(      
            messages,       
            role='Structured Solution Generation',       
            task='Generate Structured Solution',       
            temperature=0.75,       
            retries=3,       
            backoff_factor=2      
        )      

        # Check if the response is complete and valid JSON before parsing  
        if response_text and response_text.strip().endswith('}'):  
            response_json = json.loads(response_text)      
        else:  
            raise ValueError("Incomplete JSON response received from AI.")  

        # Iterate over the phases and extract the COS and CEs directly from the list  
        structured_solution['phases'] = {  
    phase: [  
        {  
            'id': cos.get('id', str(uuid.uuid4())),  
            'status': 'Proposed',  
            'cos_text': cos['cos_text'],  # Corrected key  
            'ces': cos.get('CEs', [])  
        }  
        for cos in response_json.get(phase, [])  
    ]  
    for phase in ['Discovery', 'Engagement', 'Action', 'Completion', 'Legacy']  
}  

        
        return structured_solution  # Return the correctly structured solution    

    except json.JSONDecodeError as e:      
        current_app.logger.error(f"Error parsing JSON response: {e}", exc_info=True)      
        raise ValueError("Failed to parse JSON response.")      
    except ValueError as e:  
        current_app.logger.error(f"Error in generating structured solution: {e}", exc_info=True)      
        raise  
    except Exception as e:      
        current_app.logger.error(f"Unexpected error in generating structured solution: {e}", exc_info=True)      
        raise ValueError("Failed to generate structured solution.")


üü© goal_selection.html:
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
  <h1>What is your Commitment?</h1>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Your Input</th>
        <th class="text-end">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="user-input">{{ user_input }}</td>
        <td class="text-end">
          <button type="button" class="btn btn-primary btn-sm edit-user-input">Edit</button>
          <button type="button" class="btn btn-success btn-sm save-user-input d-none">Update</button>
          <button type="button" class="btn btn-danger btn-sm cancel-user-input d-none">Cancel</button>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    Based on your input, we have speculated three high-level outcomes.
    Please choose the one that is closest to your desired result, or click the "Speculate New Outcomes" button to generate a new set of possibilities.
  </p>
  <div class="row">
    {% for goal in goals %}
      <div class="col-md-4 mb-4">
        <div class="card retro-futuristic-card text-center {% if not goal.compliant %}non-compliant{% endif %}">
          <div class="card-body card-content">
            <i class="{{ goal.icon }} fa-2x mb-3"></i>
            <p class="domain domain-text">{{ goal.domain | title }}</p>
            <h5 class="card-title" data-text="{{ goal.title }}">{{ goal.title | safe }}</h5>
            {% if goal.compliant %}
            <form action="/outcome" method="post" class="goal-selection-form">
              <input type="hidden" name="selected_goal" value="{{ goal.title }}">
              <input type="hidden" name="domain" value="{{ goal.domain }}">
              <input type="hidden" name="domain_icon" value="{{ goal.icon }}">
              <input type="hidden" name="user_text" value="{{ user_input }}">
              <button type="submit" class="btn btn-primary">Select</button>
            </form>
            {% else %}
            <button type="button" class="btn btn-danger" onclick="window.location.href='/';">Start Over</button>
            {% endif %}
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
  <div class="text-center">
    <button type="button" class="btn btn-outline-primary" id="generate-new-goals">
      <span class="refresh-icon"><i class="fas fa-sync-alt"></i></span> Speculate New Outcomes</button>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module" src="{{ url_for('static', filename='js/goal_selection.js') }}"></script>
{% endblock %}



üü¶ outcome.html:
{% extends 'base.html' %}    
    
{% block content %}  
<div class="container">  
  <div class="row outcome-header">  
    <div class="col-md-4 text-center">  
      {% if ssol.generated_image_path %}  
      <img src="{{ url_for('static', filename=ssol.generated_image_path) }}" alt="Generated Image" class="rounded mb-3 generated-image" style="width: 100%; max-width: 300px;">  
      {% endif %}  
      <h2>Domain</h2>  
      <i class="{{ ssol.domain_icon }} fa-3x mb-3"></i>  
      <p class="domain domain-text text-center">{{ ssol.domain | title }}</p>  
      <h2>Fulfilled Goal</h2>  
      <p><strong>{{ ssol.selected_goal | safe }}</strong></p>  
      <div class="text-center mt-4">    
        <button id="save-as-pdf-button" data-ssol-id="{{ ssol_id }}" class="btn btn-info" title="Save as PDF">    
          <i class="fas fa-download me-2"></i>PDF    
        </button>    
      </div> 
  </div>       
    <div class="col-md-8">    
      <h1>Preliminary Structured Solution</h1>    
      <p id="ssol-summary">{{ ssol.ssol_summary | safe }}</p>    
    </div>    
  </div>    
  
  <div class="row">    
    <h1>Phases & Conditions of Satisfaction</h1>    
    <div class="col" id="cos-content-container">   
      <div class="accordion mt-4" id="phase-accordion">    
        {% for phase, cos_list in ssol.phases.items() %}    
        <div class="accordion-item">    
          <h2 class="accordion-header" id="heading-{{ phase }}">    
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-{{ phase }}" aria-expanded="false" aria-controls="collapse-{{ phase }}">    
              {{ phase | title }}    
            </button>    
          </h2>    
          <div id="collapse-{{ phase }}" class="accordion-collapse collapse" aria-labelledby="heading-{{ phase }}" data-bs-parent="#phase-accordion">    
            <div class="accordion-body">  
              {% for cos in cos_list %}  
                <div class="cos-item">  
                  <p>{{ cos.cosText | safe }}</p>  
                  <div>  
                    {% for ce in cos.CEs %}  
                    <span class="badge rounded-pill bg-info" title="{{ ce.type }}">  
                      {{ ce.content }} 
                    </span>   
                  {% endfor %}    
                </div>    
              </div>    
              {% endfor %}    
            </div>    
          </div>    
        </div>    
        {% endfor %}    
      </div>    
    </div>    
  </div>    
</div>    
  
<!-- Error Modal -->    
<div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">    
  <div class="modal-dialog">    
    <div class="modal-content">    
      <div class="modal-header">    
        <h5 class="modal-title" id="errorModalLabel">Error</h5>    
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>    
      </div>    
      <div class="modal-body">    
        {{ error_message }}    
      </div>    
      <div class="modal-footer">    
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>    
      </div>    
    </div>    
  </div>    
</div>    
  
<!-- CE Modal (Bootstrap) -->    
<div class="modal fade" id="ceModal" tabindex="-1" aria-labelledby="ceModalLabel" aria-hidden="true">    
  <div class="modal-dialog">    
    <div class="modal-content">    
      <div class="modal-header">    
        <h5 class="modal-title" id="ceModalLabel">Conditional Element Details</h5>    
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>    
      </div>    
      <div class="modal-body">    
        <!-- CE details will be dynamically inserted here -->    
      </div>    
    </div>    
  </div>    
</div>    
{% endblock %}      
      
{% block scripts %}          
<script src="{{ url_for('static', filename='js/cos_table.js') }}"></script>          
<script src="{{ url_for('static', filename='js/ce_table.js') }}"></script>          
<script src="{{ url_for('static', filename='js/ce_cards.js') }}"></script>          
<script>      
  document.addEventListener('DOMContentLoaded', () => {      
    // Initialize event listeners for COS table handling  
    initializePhaseTableEventListeners();      
    // Removed addEventListenersToCELabels call  
  });      
</script>       
{% endblock %}  




üü¶ cos_table.js:
function getBadgeClassFromStatus(status) {
  switch (status) {
    case 'Proposed': return 'bg-info';
    case 'In Progress': return 'bg-warning text-dark';
    case 'Completed': return 'bg-success';
    case 'Rejected': return 'bg-danger';
    default: return 'bg-secondary';
  }
}

// Function to add event listeners to the phase table  
function initializePhaseTableEventListeners() {  
  const phaseTables = document.querySelectorAll('.phase-table');  
  phaseTables.forEach(table => {  
      table.addEventListener('click', handlePhaseTableClick);  
  });  
}  

// Handles clicks within the phase table  
function handlePhaseTableClick(event) {  
  const target = event.target;  
  const row = target.closest('tr.cos-row');  
  if (!row) return;  

  const cosId = row.dataset.cosId;  

  if (target.matches('.edit-cos-button')) {  
      turnRowToEditMode(row);  
  } else if (target.matches('.update-cos-button')) {  
      handleUpdate(row, cosId);  
  } else if (target.matches('.cancel-cos-button')) {  
      cancelEditMode(row);  
  } else if (target.matches('.delete-cos-button')) {  
      deleteCOS(cosId, row);  
  }  
}   
  
function toggleEditMode(row, editing) {  
  const editButton = row.querySelector('.edit-cos-button');  
  const updateButton = row.querySelector('.update-cos-button');  
  const cancelButton = row.querySelector('.cancel-cos-button');  
  
  if (editing) {  
    editButton.classList.add('d-none');  
    updateButton.classList.remove('d-none');  
    cancelButton.classList.remove('d-none');  
  } else {  
    editButton.classList.remove('d-none');  
    updateButton.classList.add('d-none');  
    cancelButton.classList.add('d-none');  
  }  
}  
  
function turnRowToEditMode(row) {  
  storeOriginalValues(row);  
  
  const statusCell = row.querySelector('.status-cell');  
  const contentCell = row.querySelector('.cos-content-cell');  
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');  
  const completionDateCell = row.querySelector('.cos-completion-date-cell');  
  
  const currentStatus = statusCell.textContent.trim();  
  const currentContent = contentCell.textContent.trim();  
  const currentAccountableParty = accountablePartyCell.textContent.trim();  
  const currentCompletionDate = completionDateCell.textContent.trim();  
  
  statusCell.innerHTML = createStatusDropdown(currentStatus);  
  contentCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentContent}">`;  
  accountablePartyCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentAccountableParty}">`;  
  completionDateCell.innerHTML = `<input type="date" class="form-control form-control-sm" value="${currentCompletionDate}">`;  
  
  toggleEditMode(row, true);  
}  
  
function handleUpdate(row, cosId, ssolId) {  
  const contentInput = row.querySelector('.cos-content-cell input').value;  
  const statusSelect = row.querySelector('.status-cell select');  
  const statusInput = statusSelect.options[statusSelect.selectedIndex].value;  
  const accountablePartyInput = row.querySelector('.cos-accountable-party-cell input').value;  
  const completionDateInput = row.querySelector('.cos-completion-date-cell input').value;  
  
  const payload = {  
    content: contentInput,  
    status: statusInput,  
    accountable_party: accountablePartyInput,  
    completion_date: completionDateInput,  
    ssol_id: ssolId  
  };  
  
  console.log(`Sending update for COS ID: ${cosId}`, payload); // Added log  
  
  fetch(`/update_cos/${cosId}`, {  
    method: 'PUT',  
    headers: {  
      'Content-Type': 'application/json',  
      'Accept': 'application/json',  
      'X-Requested-With': 'XMLHttpRequest'  
    },  
    body: JSON.stringify(payload)  
  })  
  .then(response => {  
    if (!response.ok) {  
      return response.json().then(errorData => {  
        throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);  
      });  
    }  
    return response.json();  
  })  
  .then(data => {  
    console.log(`Received response for COS ID: ${cosId}`, data); // Added log  
    if (data.success) {  
      console.log(`Updating row with new values for COS ID: ${cosId}`); // Added log  
      updateRowWithNewValues(row, data.cos);  
      toggleEditMode(row, false);  
    } else {  
      throw new Error(data.error || 'An error occurred while updating the entry.');  
    }  
  })  
  .catch(error => {  
    console.error(`Error updating COS ID: ${cosId}:`, error); // Updated log  
    alert(`An error occurred while updating the entry: ${error.message}`);  
  });  
}  
  
function createStatusDropdown(selectedStatus) {  
  const statuses = ['Proposed', 'In Progress', 'Completed', 'Rejected'];  
  return `<select class="form-select form-select-sm">${statuses.map(status => `<option value="${status}"${status === selectedStatus ? ' selected' : ''}>${status}</option>`).join('')}</select>`;  
}  
  
function cancelEditMode(row) {  
  revertToOriginalValues(row);  
  toggleEditMode(row, false);  
}  
  
function deleteCOS(cosId, row) {  
  // Get the COS content to display in the confirmation dialog  
  const cosContent = row.querySelector('.cos-content-cell').textContent;  
  
  // Display a confirmation dialog  
  if (confirm(`Really delete Condition of Satisfaction "${cosContent}"?`)) {  
    fetch(`/delete_cos/${cosId}`, {  
      method: 'DELETE',  
      headers: {  
        'Content-Type': 'application/json',  
        'Accept': 'application/json'  
      }  
    })  
    .then(response => response.json())  
    .then(data => {  
      if (data.success) {  
        row.remove();  
      } else {  
        console.error('Error deleting COS:', data.error);  
      }  
    })  
    .catch(error => {  
      console.error('Error deleting COS:', error);  
    });  
  }  
}  

  
function storeOriginalValues(row) {  
  const statusCell = row.querySelector('.status-cell');  
  const contentCell = row.querySelector('.cos-content-cell');  
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');  
  const completionDateCell = row.querySelector('.cos-completion-date-cell');  
  
  row.dataset.originalValues = JSON.stringify({  
    status: statusCell.textContent.trim(),  
    content: contentCell.textContent.trim(),  
    accountableParty: accountablePartyCell.textContent.trim(),  
    completionDate: completionDateCell.textContent.trim()  
  });  
}  
  
function revertToOriginalValues(row) {  
  const originalValues = JSON.parse(row.dataset.originalValues);  
  row.querySelector('.status-cell').innerHTML = `<span class="badge badge-pill ${getBadgeClassFromStatus(originalValues.status)}">${originalValues.status}</span>`;  
  row.querySelector('.cos-content-cell').textContent = originalValues.content;  
  row.querySelector('.cos-accountable-party-cell').textContent = originalValues.accountableParty;  
  row.querySelector('.cos-completion-date-cell').textContent = originalValues.completionDate;  
}  
  
function updateRowWithNewValues(row, cos) {    
  // Check if the cos object and its properties are defined    
  if (cos && cos.status && cos.content) {    
    row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(cos.status)}">${cos.status}</span>`;    
    row.querySelector('.cos-content-cell').textContent = cos.content;    
    row.querySelector('.cos-accountable-party-cell').textContent = cos.accountable_party || '';    
    row.querySelector('.cos-completion-date-cell').textContent = cos.completion_date || '';    
  } else {    
    // If cos or any required property is undefined, log an error or handle appropriately    
    console.error('Error: COS data is undefined or missing required properties', cos);    
    alert('An error occurred while updating the entry. Please try again.');    
  }    
}    

// cos_table.js  
  
// Function to add event listeners to the phase table  
function initializePhaseTableEventListeners() {  
  const phaseTables = document.querySelectorAll('.phase-table');  
  phaseTables.forEach(table => {  
      table.addEventListener('click', handlePhaseTableClick);  
  });  
}  

// Handles clicks within the phase table  
function handlePhaseTableClick(event) {  
  const target = event.target;  
  const row = target.closest('tr.cos-row');  
  if (!row) return;  

  const cosId = row.dataset.cosId;  

  if (target.matches('.edit-cos-button')) {  
      turnRowToEditMode(row);  
  } else if (target.matches('.update-cos-button')) {  
      handleUpdate(row, cosId);  
  } else if (target.matches('.cancel-cos-button')) {  
      cancelEditMode(row);  
  } else if (target.matches('.delete-cos-button')) {  
      deleteCOS(cosId, row);  
  }  
}  

// Function to fetch and display analyzed COS for a given COS ID  
function fetchAndDisplayAnalyzedCOS(cosId) {  
  fetch(`/analyze_cos/${cosId}`)  
      .then(handleResponse)  
      .then(data => {  
          updateCOSContent(data.content_with_ce);  
      })  
      .catch(error => {  
          displayError(`Failed to analyze COS: ${error}`);  
      });  
}  

  
// Event listener to fetch and display analyzed COS content after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {  
  const analyzeButtons = document.querySelectorAll('.analyze-cos-button');  
  analyzeButtons.forEach(button => {  
    button.addEventListener('click', function () {  
      const cosId = this.getAttribute('data-cos-id');  
      fetchAndDisplayAnalyzedCOS(cosId);  
    });  
  });  
});  


// Function to add event listeners to CE pills  
function initializeCEPillEventListeners() {  
  const cePills = document.querySelectorAll('.ce-pill');  
  cePills.forEach(pill => {  
      pill.addEventListener('click', handleCEPillClick);  
  });  
}  

function handleCEPillClick(event) {  
  const ceId = event.target.dataset.ceId;  
  console.log(`CE Pill with ID ${ceId} clicked`);  

  // Example logic to fetch CE details and display in a modal or another UI element  
  fetch(`/get_ce_by_id/${ceId}`)  
      .then(response => response.json())  
      .then(data => {  
          if (data && data.ce) {  
              displayCEDetails(data.ce); // Function to display CE details  
          } else {  
              console.error('CE details not found or error in response:', data);  
          }  
      })  
      .catch(error => {  
          console.error('Error fetching CE details:', error);  
      });  
} 



// Event listener to initialize phase table event listeners after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {  
  initializePhaseTableEventListeners();  
  document.querySelectorAll('.analyze-cos-button').forEach(button => {  
      button.addEventListener('click', (event) => {  
          const cosId = event.target.getAttribute('data-cos-id');  
          if (cosId) {  
              fetchAndDisplayAnalyzedCOS(cosId);  
          }  
      });  
  });  
});  

// Function to add event listeners to CE pills  
function initializeCEPillEventListeners() {  
  const cePills = document.querySelectorAll('.ce-pill');  
  cePills.forEach(pill => {  
      pill.addEventListener('click', handleCEPillClick);  
  });  
} 

// Event listener to initialize phase table event listeners after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      if (cosId) {
        fetchAndDisplayAnalyzedCOS(cosId);
      }
    });
  });
  
  // Add event listener to the Analyze button  
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.analyze-cos-button').forEach(button => {
      button.addEventListener('click', (event) => {
        const cosId = event.target.getAttribute('data-cos-id');
        if (cosId) {
          fetchAndDisplayAnalyzedCOS(cosId);
        }
      });
    });
  });

  function extractCosContentForEditing(cosContentCell) {
    const badgeElements = cosContentCell.querySelectorAll('.badge');
    badgeElements.forEach((badge) => {
      const ceContent = badge.textContent;
      // Replace the badge HTML with a placeholder or markup that includes the CE content  
      badge.outerHTML = `[CE]${ceContent}[/CE]`;
    });
    return cosContentCell.innerHTML; // This now contains the editable content with [CE][/CE] placeholders  
  }

 
  document.addEventListener('DOMContentLoaded', () => {
    // Get all COS content cells  
    const cosContentCells = document.querySelectorAll('.cos-content-cell');
  
    // Loop over each cell and replace CE tags with pills  
    cosContentCells.forEach(cell => {
      const content = cell.textContent;
      const newContent = replaceCETagsWithPills(content); // This is your existing JS function  
      cell.innerHTML = newContent;
    });
  
    // Now that the DOM has been updated, add event listeners to the new pill elements  
    addEventListenersToCELabels();
  });
})

// Function to save the content as PDF  
function saveAsPDF(ssolId) {  
  const htmlContent = document.documentElement.outerHTML; // Get the entire HTML content of the page  
  fetch(`/save_as_pdf/${ssolId}`, {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify({ htmlContent: htmlContent })  
  })  
  .then(response => {  
    if (!response.ok) {  
      throw new Error(`Server responded with status ${response.status}`);  
    }  
    return response.blob();  
  })  
  .then(blob => {  
    const url = window.URL.createObjectURL(blob);  
    const a = document.createElement('a');  
    a.style.display = 'none';  
    a.href = url;  
    a.download = `${ssolId}.pdf`;  
    document.body.appendChild(a);  
    a.click();  
    window.URL.revokeObjectURL(url);  
    document.body.removeChild(a);  
  })  
  .catch((error) => {  
    console.error('Error saving PDF:', error);  
  });  
}  
  
// Event listener to initialize after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', function () {  
  const saveButton = document.getElementById('save-as-pdf-button');  
  if (saveButton) {  
    saveButton.addEventListener('click', function (event) {  
      event.preventDefault(); // Prevent the default button click action  
      const ssolId = saveButton.dataset.ssolId;  
      saveAsPDF(ssolId);  
    });  
  }  
});  



üü® speculate.py:
import re
import os
import json
import uuid
import logging
from uuid import UUID
from bs4 import BeautifulSoup 
from app import USE_DATABASE, db  
from ce_nodes import NODES
from models import session  
from sqlalchemy.exc import SQLAlchemyError
from utilities import generate_chat_response
from models import COS, CE, SSOL, COS_CE_Link  
from store import ssol_store, cos_store, ce_store  
from sqlalchemy.orm import relationship, sessionmaker
from flask import render_template, jsonify, current_app
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Date, ForeignKey, create_engine


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') 

def create_cos(ssol_id, content, status, accountable_party=None, completion_date=None):  
    try:  
        # Analyze the COS content to identify conditional elements  
        analyzed_content = analyze_cos(content)  
        content_with_ce = analyzed_content['content_with_ce']  
  
        if USE_DATABASE:  
            # Create a new COS instance  
            cos = COS(content=content_with_ce, status=status, accountable_party=accountable_party,  
                      completion_date=completion_date, ssol_id=ssol_id)  
            db.session.add(cos)  
  
            # Create and link CEs to the COS  
            for ce_data in analyzed_content['ces']:  
                ce = CE(content=ce_data['content'], node_type=ce_data['ce_type'])  
                db.session.add(ce)  
                cos.conditional_elements.append(ce)  
  
            # Commit the transaction to the database  
            db.session.commit()  
            logging.info(f"COS with ID {cos.id} created and committed to the database.")  
            return cos.id  
  
        else:  
            # Generate a unique ID for the in-memory COS  
            cos_id = str(uuid.uuid4())  
            cos = {'id': cos_id, 'content': content_with_ce, 'status': status, 'ssol_id': ssol_id}  
            cos_store[cos_id] = cos  
  
            # Store each CE in the in-memory store  
            for ce_data in analyzed_content['ces']:  
                ce_id = str(uuid.uuid4())  
                ce = {'id': ce_id, 'content': ce_data['content'], 'node_type': ce_data['ce_type']}  
                ce_store[ce_id] = ce  
                cos['conditional_elements'] = cos.get('conditional_elements', []) + [ce]  
  
            logging.info(f"COS with ID {cos_id} created in the in-memory store.")  
            return cos_id  
  
    except Exception as e:  
        logging.error(f"Error creating COS: {e}", exc_info=True)  
        if USE_DATABASE:  
            db.session.rollback()  # Rollback the session in case of an error when using the database  
        raise  # Reraise the exception to allow the caller to handle it  


def get_cos_by_id(cos_id):  
    from app import USE_DATABASE 
    if USE_DATABASE:  
        return COS.query.get(cos_id)  
    else:  
        return cos_store.get(str(cos_id))  
    
def analyze_cos(cos_content):  
    # Define the prompt for the AI to identify conditional elements        
    prompt = (  
        "Analyze the following condition of satisfaction (COS) and identify any conditional elements (CEs). "  
        "Return a JSON object with the COS text and an array of CEs, each with its text and type."  
        "\nCOS: '{}'"  
        "\nExpected response format:"  
        "{{"  
        "  'COS': 'The full text of the COS',"  
        "  'CEs': ["  
        "    {{'text': 'A conditional element', 'type': 'The type of CE'}},"  
        "    {{'text': 'Another conditional element', 'type': 'Another type of CE'}}"  
        "  ]"  
        "}}"  
    ).format(cos_content)  
      
    messages = [  
        {"role": "system", "content": "Return a JSON object with the analyzed COS and CEs."},  
        {"role": "user", "content": prompt},  
    ]  
      
    try:  
        # Send messages to the AI and get the response      
        response_text = generate_chat_response(messages)  
        response_json = json.loads(response_text)  
          
        # Extract the COS and CEs from the response  
        cos_text = response_json.get("COS", cos_content)  
        ces = response_json.get("CEs", [])  
          
        # Process the CEs, such as storing them in the database  
        stored_ces = []  
        for ce in ces:  
            new_ce = CE(content=ce["text"], node_type=ce["type"])  
            db.session.add(new_ce)  
            stored_ces.append(new_ce)  
        db.session.commit()  
          
        return {'COS': cos_text, 'CEs': [ce.to_dict() for ce in stored_ces]}  
          
    except Exception as e:  
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)  
        db.session.rollback()  
        return {'COS': cos_content, 'CEs': []}  
  

import html  
  
def extract_conditional_elements(response_text, original_content):    
    ces = []    
    try:  
        # Use regex to extract CEs from response_text  
        matches = re.findall(r'<ce>(.*?)</ce>', response_text, re.IGNORECASE)  
        content_with_ce = original_content    
  
        for match in matches:    
            ce_content = html.escape(match.strip())  # Escape HTML special characters  
            ce_uuid = str(uuid.uuid4())    
            # Replace only the first occurrence of the matched CE content  
            content_with_ce = re.sub(rf'<ce>\s*{re.escape(match.strip())}\s*</ce>', f'<span class="ce-pill" data-ce-id="{ce_uuid}">{ce_content}</span>', content_with_ce, count=1)  
            ces.append({'id': ce_uuid, 'content': ce_content, 'ce_type': 'Unknown'})  
    
        return {'content_with_ce': content_with_ce, 'ces': ces}  
    except Exception as e:  
        # Handle any errors that occur during the extraction process  
        logging.error(f"Error extracting conditional elements: {e}", exc_info=True)  
        return {'content_with_ce': original_content, 'ces': []}  


def update_cos_by_id(cos_id, updated_data):        
    from app import db, USE_DATABASE 
    try:        
        # If using database, convert UUID to string for query  
        cos_id_str = str(cos_id) if isinstance(cos_id, UUID) else cos_id    
            
        # Update the COS entry with new data  
        if USE_DATABASE:  
            # Database operation  
            cos = session.query(COS).filter_by(id=cos_id).first()  
            if cos:  
                for key, value in updated_data.items():  
                    setattr(cos, key, value)  
                session.commit()  
                return {'success': True, 'cos': cos.to_dict()}  # Return the updated COS for client-side use  
            else:  
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}  
        else:  
            # In-memory operation  
            cos = cos_store.get(cos_id_str)  # Attempt to retrieve the COS entry  
            if not cos:  
                # COS not found, log a warning  
                current_app.logger.warning(f"COS with ID {cos_id_str} not found in the in-memory store.")  
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}  
              
            for key, value in updated_data.items():  
                cos[key] = value  
            cos_store[cos_id_str] = cos  # Store the updated COS back in the store  
                
            # Log the successful update and return the updated COS  
            current_app.logger.info(f"COS with ID {cos_id_str} successfully updated.")  
            return {'success': True, 'cos': cos}  # Return the updated COS for client-side use  
        
    except Exception as e:        
        # Log the error and return an error message  
        current_app.logger.error(f"Unexpected error during COS update: {e}", exc_info=True)  
        return {'success': False, 'message': f"Unexpected error occurred: {e}"}  

def delete_cos_by_id(cos_id, ssol_id=None):    
    from app import USE_DATABASE 
    if USE_DATABASE:    
        # Database operation    
        cos = session.query(COS).filter_by(id=cos_id).first()    
        if cos and (ssol_id is None or cos.ssol_id == ssol_id):    
            session.delete(cos)    
            session.commit()    
            return True  # COS was deleted successfully    
        else:    
            return False  # COS did not exist or did not match the provided SSOL_ID    
    else:    
        # In-memory operation    
        cos = cos_store.get(cos_id)    
        if cos and (ssol_id is None or cos['ssol_id'] == ssol_id):    
            del cos_store[cos_id]    
            return True  # COS was deleted successfully    
        return False  # COS did not exist or did not match the provided SSOL_ID 


# Function to analyze the COS content and extract the CE type(s)
def analyze_ce_type(request):
    try:
        ce_content = request.get_json()['ce_content']
        ce_type = None

        # Iterate through the ce_types in ce_nodes.py and check if it appears in the ce_content
        for ce_type, values in NODES.items():
            if ce_type in ce_content:
                break
        
        return jsonify(ce_type=ce_type)
    except Exception as e:
        return jsonify(error=str(e))

def get_ce_type(ce_content):
    messages = [
        {"role": "system", "content": "You are responsible for identifying the appropriate card type for the given conditional element."},
        {"role": "user", "content": ce_content},
    ]
    response_text = generate_chat_response(messages, role='Conditional Element (CE) Node Type Identification', task='Identify CE Type', temperature=0.6)

    ce_type_match = re.search(r'\[CE\] (.*?)$', response_text)
    if ce_type_match:
        ce_type = ce_type_match.group(1).strip()
        return ce_type
    else:
        return ""
    
# CRUD operations for SSOL  
def create_ssol(goal, summary):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = SSOL(goal=goal, summary=summary)  
        db.session.add(ssol)  
        db.session.commit()  
        return ssol.id  
    else:  
        ssol_id = str(uuid.uuid4())  
        ssol_store[ssol_id] = {'id': ssol_id, 'goal': goal, 'summary': summary}  
        return ssol_id 

def get_ssol_by_id(ssol_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        return SSOL.query.get(ssol_id)  
    else:  
        return ssol_store.get(ssol_id) 
  
def update_ssol_by_id(ssol_id, updated_data):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()  
        for key, value in updated_data.items():  
            setattr(ssol, key, value)  
        session.commit()  
    else:  
        ssol = ssol_store.get(ssol_id)  
        if ssol:  
            ssol.update(updated_data)  
  
def delete_ssol_by_id(ssol_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()  
        session.delete(ssol)  
        session.commit()  
    else:  
        ssol = ssol_store.pop(ssol_id, None)  
        return bool(ssol)  # Returns True if an SSOL was deleted, False otherwise 


def create_ce(content, node_type):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ce = CE(content=content, node_type=node_type)  
        db.session.add(ce)  
        db.session.commit()  
        return ce.id  
    else:  
        ce_id = str(uuid.uuid4())  
        ce_store[ce_id] = {'id': ce_id, 'content': content, 'node_type': node_type}  
        return ce_id  
  
def get_ce_by_id(ce_id):  
    from app import USE_DATABASE 
    if USE_DATABASE:  
        return CE.query.get(ce_id)  
    else:  
        return ce_store.get(str(ce_id))  
  
def update_ce_by_id(ce_id, updated_data):  
    from app import USE_DATABASE 
    if USE_DATABASE:  
        ce = session.query(CE).filter_by(id=ce_id).first()  
        for key, value in updated_data.items():  
            setattr(ce, key, value)  
        session.commit()  
    else:  
        ce = ce_store.get(ce_id)  
        if ce:  
            ce.update(updated_data)  
  
def delete_ce_by_id(ce_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ce = session.query(CE).filter_by(id=ce_id).first()  
        session.delete(ce)  
        session.commit()  
    else:  
        if ce_id in ce_store:  
            del ce_store[ce_id]  
            return True  # CE was deleted successfully  
        return False  # CE did not exist in the store  
  
# Function to generate the appropriate card based on the CE type  
def generate_card(ce_type, ce_id):  
    from app import db, USE_DATABASE 
    if ce_type in NODES:  
        node = NODES[ce_type]  
        # If using a database, render a template with data fetched from the database  
        if USE_DATABASE:  
            template = render_template(  
                node["flask_template"], ce_id=ce_id  
            )  
        else:  
            # If using the in-memory store, pass the CE data directly to the template  
            ce_data = ce_store.get(ce_id)  
            template = render_template(  
                node["flask_template"], ce=ce_data  
            )  
        return template  
    else:  
        return ""

def parse_ai_response_and_generate_html(ai_response):  
    # Initialize an empty array to hold HTML strings for each COS  
    cos_html_list = []  
  
    for phase, details in ai_response.items():  
        cos_html = ""  
        for cos in details.get("Conditions_of_Satisfaction", []):  
            # Replace CEs in the COS string with HTML pills  
            for ce in details.get("Conditional_Elements", []):  
                ce_html = f'<span class="badge rounded-pill bg-info ce-pill" data-ce-id="{ce["id"]}" data-ce-type="{ce["type"]}">{ce["content"]}</span>'  
                cos = cos.replace(ce["content"], ce_html)  
            cos_html += f'<p>{cos}</p>'  
          
        cos_html_list.append({phase: cos_html})  
  
    return cos_html_list  
  
def analyze_cos(cos_content):    
    try:  
        # Assume cos_content is the JSON response from the AI  
        # Let's parse the JSON into a Python dictionary  
        cos_json = json.loads(cos_content)  
          
        # Use the parse_ai_response_and_generate_html function  
        # to convert the AI response into HTML  
        structured_solution_html = parse_ai_response_and_generate_html(cos_json)  
          
        # Return the structured HTML content  
        return structured_solution_html  
  
    except json.JSONDecodeError as e:  
        # If there's an error parsing the JSON, log it  
        logging.error(f"JSON decode error during COS analysis: {e}", exc_info=True)  
        return None  
  
    except Exception as e:    
        # If there's a different error, log it  
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)  
        return None  


def get_badge_class_from_status(status):    
    return {    
        'Proposed': 'bg-info',    
        'In Progress': 'bg-warning text-dark',  # Added text-dark for better contrast  
        'Completed': 'bg-success',    
        'Rejected': 'bg-danger'    
    }.get(status, 'bg-secondary')  # Default to 'bg-secondary' if status is not found 
 
    # Ensure database or in-memory store is initialized based on USE_DATABASE flag  
def initialize_data_store():
    from app import USE_DATABASE, Base, _engine   
    Base.metadata.create_all(_engine) if USE_DATABASE else None  

def check_data_store_contents(data_store_type='in_memory'):  
    if data_store_type == 'in_memory':  
        try:  
            # Print contents of the in-memory store  
            for cos_id_str, cos_data in cos_store.items():  
                logging.info(f"COS ID: {cos_id_str}, Data: {cos_data}")  
        except NameError:  
            logging.warning("In-memory store 'cos_store' not found.")  
    elif data_store_type == 'database' and USE_DATABASE:  
        try:  
            # Query all entries in the COS table and print them  
            cos_entries = COS.query.all()  
            for entry in cos_entries:  
                logging.info(f"COS ID: {entry.id}, Data: {entry}")  
        except Exception as e:  
            logging.error(f"Database query failed with error: {e}")  
    else:  
        logging.error(f"Unknown data store type: {data_store_type}") 

        if __name__ == '__main__':  
            logging.info("Checking initial data store contents...")  
            check_data_store_contents('database' if USE_DATABASE else 'in_memory')  


üü™ ce_table.js:
// Function to handle the click event on CE pills
function handleCEPillClick(event) {
  const ceId = event.target.dataset.ceId;
  fetch(`/get_ce_by_id?ce_id=${ceId}`)
    .then((response) => response.json())
    .then((data) => {
      if (!data.error && data.ce.ce_type) {
        showCEModal(data.ce);
      } else {
        analyzeCE(ceId, data.ce);
      }
    })
    .catch((error) => {
      console.log('Error:', error);
    });
}

// Function to analyze the CE and get the CE type
function analyzeCE(ceId, ceData) {
  fetch('/analyze_ce_type', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ cos_content: ceData.content }),
  })
    .then((response) => response.json())
    .then((data) => {
      updateCEwithAnalyzedCE(ceId, ceData, data.ce_type);
    })
    .catch((error) => {
      console.log('Error:', error);
    });
}

// Function to update the CE with the analyzed CE type
function updateCEwithAnalyzedCE(ceId, ceData, ceType) {
  fetch(`/update_ce_type?ce_id=${ceId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ ce_type: ceType }),
  })
    .then((response) => response.json())
    .then((data) => {
      if (data.ce && data.ce.ce_type) {
        showCEModal(data.ce);
      } else {
        showCEModal(ceData);
      }
    })
    .catch((error) => {
      console.log('Error:', error);
    });
}

// Function to create the CE modal content
function createCEModalContent(ceData) {
  const modalContent = document.createElement('div');
  modalContent.classList.add('modal-content');

  const modalHeader = document.createElement('div');
  modalHeader.classList.add('modal-header');
  modalHeader.innerHTML = `
    <h5 class="modal-title" id="ceModalLabel">Conditional Element Details</h5>
    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
      <span aria-hidden="true">&times;</span>
    </button>
  `;

  const modalBody = document.createElement('div');
  modalBody.classList.add('modal-body');

  if (ceData && ceData.content) {
    const ceContent = document.createElement('h2');
    ceContent.textContent = ceData.content;

    const ceType = document.createElement('p');
    ceType.textContent = `CE Type: ${ceData.ce_type}`;

    modalBody.appendChild(ceContent);
    modalBody.appendChild(ceType);
  } else {
    modalBody.innerHTML = '<p>Error: Unable to load CE details.</p>';
  }

  modalContent.appendChild(modalHeader);
  modalContent.appendChild(modalBody);

  return modalContent;
}

// Function to display the CE modal
function showCEModal(ceData) {
  const modal = document.createElement('div');
  modal.classList.add('modal', 'fade');
  modal.id = 'ceModal';
  modal.setAttribute('tabindex', '-1');
  modal.setAttribute('aria-labelledby', 'ceModalLabel');
  modal.setAttribute('aria-hidden', 'true');

  const modalDialog = document.createElement('div');
  modalDialog.classList.add('modal-dialog', 'modal-dialog-centered');
  modalDialog.setAttribute('role', 'document');

  const modalContent = createCEModalContent(ceData);
  modalDialog.appendChild(modalContent);
  modal.appendChild(modalDialog);

  document.body.appendChild(modal);

  $(modal).modal('show');

  $(modal).on('hidden.bs.modal', function () {
    modal.remove();
  });
}

// Function to handle the edit button click for CE
function handleCEEditButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentCell = row.querySelector('.ce-content-cell');
  const currentContent = ceContentCell.textContent.trim();
  
  // Replace the content cells with editable fields
  ceContentCell.innerHTML = `<input type="text" class="form-control form-control-sm ce-content-input" value="${currentContent}">`;
  
  // Show the update and cancel buttons, hide the edit and delete buttons
  row.querySelector('.edit-ce-button').classList.add('d-none');
  row.querySelector('.delete-ce-button').classList.add('d-none');
  row.querySelector('.update-ce-button').classList.remove('d-none');
  row.querySelector('.cancel-ce-button').classList.remove('d-none');
}

// Function to handle the update button click for CE
function handleCEUpdateButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentInput = row.querySelector('.ce-content-input');
  
  // If there is a valid input field, update the CE content
  if (ceContentInput) {
    const newContent = ceContentInput.value.trim();
    row.querySelector('.ce-content-cell').textContent = newContent;
  }

  // Hide the update and cancel buttons and show the edit button
  row.querySelector('.edit-ce-button').classList.remove('d-none');
  row.querySelector('.update-ce-button').classList.add('d-none');
  row.querySelector('.cancel-ce-button').classList.add('d-none');
}

// Function to handle the cancel button click for CE
function handleCECancelButtonClick(event) {
  const row = event.target.closest('tr');
  const ceContentCell = row.querySelector('.ce-content-cell');
  const originalContent = ceContentCell.dataset.originalContent;
  
  // Revert the content cell to its original value
  ceContentCell.textContent = originalContent;

  // Hide the update and cancel buttons and show the edit button
  row.querySelector('.edit-ce-button').classList.remove('d-none');
  row.querySelector('.update-ce-button').classList.add('d-none');
  row.querySelector('.cancel-ce-button').classList.add('d-none');
}

// Add event listeners to CE pills and buttons within the CE table
document.addEventListener('DOMContentLoaded', () => {  
  const cosTable = document.querySelector('#cos-table');  
    
  if (cosTable) {  
    cosTable.addEventListener('click', (event) => {  
      if (event.target.matches('.edit-ce-button')) {  
        handleEditButtonClick(event);  
      } else if (event.target.matches('.delete-ce-button')) {  
        handleDeleteButtonClick(event);  
      } else if (event.target.matches('.analyze-ce-button')) {  
        handleAnalyzeButtonClick(event);  
      }  
    });  
  }  
});  
  
function handleEditButtonClick(event) {  
  const row = event.target.closest('tr');  
  const ceContentCell = row.querySelector('.ce-content-cell');  
  const currentContent = ceContentCell.textContent.trim();  
  
  // Replace the content cell with an input field  
  ceContentCell.innerHTML = `<input type="text" class="form-control form-control-sm ce-content-input" value="${currentContent}">`;  
  
  // Change the "Edit" button to a "Save" button  
  event.target.classList.add('d-none');  
  const saveButton = row.querySelector('.save-ce-button');  
  if (saveButton) {  
    saveButton.classList.remove('d-none');  
  }  
  
  // Add click event for the save button  
  saveButton.addEventListener('click', (e) => handleSaveButtonClick(e, row));  
}  
  
function handleSaveButtonClick(event, row) {  
  const ceContentInput = row.querySelector('.ce-content-input');  
  const newContent = ceContentInput.value.trim();  
  const ceId = row.dataset.ceId;  
  // Send the updated content to the server  
  fetch(`/update_cos`, {  
    method: 'POST',  
    headers: {'Content-Type': 'application/json'},  
    body: JSON.stringify({cos_id: ceId, content: newContent}),  
  })  
  .then(response => response.json())  
  .then(data => {  
    // Check if the update was successful  
    if (data.success) {  
      // Update the UI to show the new content  
      const ceContentCell = row.querySelector('.ce-content-cell');  
      ceContentCell.textContent = newContent;  
      // Change the "Save" button back to an "Edit" button  
      const editButton = row.querySelector('.edit-ce-button');  
      editButton.classList.remove('d-none');  
      event.target.classList.add('d-none');  
    } else {  
      console.error('Error updating CE:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  
  
function handleDeleteButtonClick(event) {  
  const row = event.target.closest('tr');  
  const ceId = row.dataset.ceId;  
  // Send a delete request to the server  
  fetch(`/delete_cos`, {  
    method: 'POST',  
    headers: {'Content-Type': 'application/json'},  
    body: JSON.stringify({cos_id: ceId}),  
  })  
  .then(response => response.json())  
  .then(data => {  
    // Check if the delete was successful  
    if (data.success) {  
      // Remove the row from the table  
      row.remove();  
    } else {  
      console.error('Error deleting CE:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  
  
function handleAnalyzeButtonClick(event) {  
  const row = event.target.closest('tr');  
  const ceId = row.dataset.ceId;  
  // Send the COS/CE content to the server for analysis  
  fetch(`/analyze_cos/${ceId}`)  
  .then(response => response.json())  
  .then(data => {  
    // Display the analysis results  
    if (data.analyzed_cos) {  
      // Update the UI with the analyzed data  
      // This could be displaying a modal, updating a field, etc.  
      console.log('Analyzed COS:', data.analyzed_cos);  
    } else {  
      console.error('Error analyzing COS:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  


üè≥Ô∏è‚Äçüåà ce_nodes.py:
NODES = {
    "Location": {
        "definition": "This node allows the user to specify a geographic region relevant to the Conditional Element.",
        "icon": "fas fa-map-marker-alt"
    },
    "Research": {
        "definition": "This node aggregates resources and research related to the Conditional Element.",
        "icon": "fas fa-flask"
    },
    "Resource": {
        "definition": "This node provides a list of resources or assets related to the Conditional Element.",
        "icon": "fas fa-tools"
    },
    "Action": {
        "definition": "This node represents an action or task to be taken to fulfill the Conditional Element.",
        "icon": "fas fa-tasks"
    },
    "Time": {
        "definition": "This node specifies a time frame or deadline associated with the Conditional Element.",
        "icon": "fas fa-clock"
    },
   "Stakeholder": {
        "definition": "This node captures the stakeholders involved in the Conditional Element.",
        "icon": "fas fa-user-friends"
    },
    "Collaboration": {
        "definition": "This node focuses on collaboration efforts or partnerships needed for the Conditional Element.",
        "icon": "fas fa-handshake"
    },
    "Policy": {
        "definition": "This node addresses policy or regulatory aspects related to the Conditional Element.",
        "icon": "fas fa-gavel"
    },
    "Data": {
        "definition": "This node highlights data requirements or analytics related to the Conditional Element.",
        "icon": "fas fa-database"
    },
    "Technology": {
        "definition": "This node explores the use of technology or tools for the Conditional Element.",
        "icon": "fas fa-cogs"
    },
    "Communication": {
        "definition": "This node focuses on communication strategies or channels related to the Conditional Element.",
        "icon": "fas fa-comments"
    },
    "Skill": {
        "definition": "This node identifies specific skills or expertise required for the Conditional Element.",
        "icon": "fas fa-brain"
    },
    "Education": {
        "definition": "This node addresses educational requirements or training related to the Conditional Element.",
        "icon": "fas fa-graduation-cap"
    },
    "Evaluation": {
        "definition": "This node tracks evaluation methods or metrics for assessing the Conditional Element.",
        "icon": "fas fa-star-half-alt"
    },
    "Impact": {
        "definition": "This node explores the potential impact or outcomes of the Conditional Element.",
        "icon": "fas fa-chart-bar"
    },
    "Legal": {
        "definition": "This node covers legal considerations or requirements related to the Conditional Element.",
        "icon": "fas fa-balance-scale"
    },
    "Environmental": {
        "definition": "This node focuses on environmental factors or considerations for the Conditional Element.",
        "icon": "fas fa-leaf"
    },
    "Risk": {
        "definition": "This node addresses the potential risks or challenges associated with the Conditional Element.",
        "icon": "fas fa-exclamation-triangle"
    },
    "Compliance": {
        "definition": "This node focuses on compliance requirements or regulations for the Conditional Element.",
        "icon": "fas fa-file-alt"
    },
    "Performance": {
        "definition": "This node tracks performance indicators or benchmarks for the Conditional Element.",
        "icon": "fas fa-chart-line"
    },
    "Logistic": {
        "definition": "This node addresses logistical considerations or requirements for the Conditional Element.",
        "icon": "fas fa-truck"
    },
    "Infrastructure": {
        "definition": "This node covers infrastructure needs or considerations for the Conditional Element.",
        "icon": "fas fa-building"
    },
    "Health and Safety": {
        "definition": "This node focuses on health and safety considerations for the Conditional Element.",
        "icon": "fas fa-heartbeat"
    },
    "Scalability": {
        "definition": "This node addresses the scalability potential of the Conditional Element.",
        "icon": "fas fa-expand-arrows-alt"
    },
    "Ethical": {
        "definition": "This node explores ethical considerations or implications of the Conditional Element.",
        "icon": "fas fa-balance-scale-left"
    },
    "Cultural": {
        "definition": "This node addresses cultural factors or considerations for the Conditional Element.",
        "icon": "fas fa-globe"
    },
    "Innovation": {
        "definition": "This node focuses on innovative approaches or technologies for the Conditional Element.",
        "icon": "fas fa-lightbulb-on"
    },
    "Public Relations": {
        "definition": "This node covers public relations strategies or activities related to the Conditional Element.",
        "icon": "fas fa-megaphone"
    },
    "Governance": {
        "definition": "This node addresses governance structures or requirements for the Conditional Element.",
        "icon": "fas fa-users-cog"
    },
    "Monitoring": {
        "definition": "This node focuses on monitoring and tracking progress or performance related to the Conditional Element.",
        "icon": "fas fa-heartbeat"
    },
    "Compliance": {
        "definition": "This node addresses compliance requirements or regulations specific to the Conditional Element.",
        "icon": "fas fa-clipboard-check"
    },
    "Quality Assurance": {
        "definition": "This node ensures quality control and assurance processes and standards for the Conditional Element.",
        "icon": "fas fa-check-circle"
    },
    "Ethical AI": {
        "definition": "This node explores ethical considerations and guidelines related to the use of AI in the Conditional Element.",
        "icon": "fas fa-brain"
    },
    "Privacy and Data Security": {
        "definition": "This node addresses privacy and data security measures and guidelines for the Conditional Element.",
        "icon": "fas fa-lock"
    },
    "Regulatory Compliance": {
        "definition": "This node focuses specifically on regulatory compliance requirements for the Conditional Element.",
        "icon": "fas fa-balance-scale"
    },
    "Cost and Budgeting": {
        "definition": "This node addresses cost estimation, budgeting, and financial considerations for the Conditional Element.",
        "icon": "fas fa-dollar-sign"
    },
    "Scalability": {
        "definition": "This node addresses the scalability potential of the Conditional Element.",
        "icon": "fas fa-expand-arrows-alt"
    },
    "Ethical": {
        "definition": "This node explores ethical considerations or implications of the Conditional Element.",
        "icon": "fas fa-balance-scale-left"
    },
    "Cultural": {
        "definition": "This node addresses cultural factors or considerations for the Conditional Element.",
        "icon": "fas fa-globe"
    },
    "Innovation": {
        "definition": "This node focuses on innovative approaches or technologies for the Conditional Element.",
        "icon": "fas fa-lightbulb-on"
    },
    "Public Relations": {
        "definition": "This node covers public relations strategies or activities related to the Conditional Element.",
        "icon": "fas fa-megaphone"
    },
    "Governance": {
        "definition": "This node addresses governance structures or requirements for the Conditional Element.",
        "icon": "fas fa-users-cog"
    },
    "Monitoring": {
        "definition": "This node focuses on monitoring and tracking progress or performance related to the Conditional Element.",
        "icon": "fas fa-heartbeat"
    },
    "Compliance": {
        "definition": "This node focuses on compliance requirements or regulations for the Conditional Element.",
        "icon": "fas fa-clipboard-check"
    },
    "Quality Assurance": {
        "definition": "This node ensures quality control and assurance processes and standards for the Conditional Element.",
        "icon": "fas fa-check-circle"
    },
    "Ethical AI": {
        "definition": "This node explores ethical considerations and guidelines related to the use of AI in the Conditional Element.",
        "icon": "fas fa-brain"
    },
    "Privacy and Data Security": {
        "definition": "This node addresses privacy and data security measures and guidelines for the Conditional Element.",
        "icon": "fas fa-lock"
    },
    "Regulatory Compliance": {
        "definition": "This node focuses specifically on regulatory compliance requirements for the Conditional Element.",
        "icon": "fas fa-balance-scale"
    },
    "Cost and Budgeting": {
        "definition": "This node addresses cost estimation, budgeting, and financial considerations for the Conditional Element.",
        "icon": "fas fa-dollar-sign"
    },
    "Accessibility": {
        "definition": "This node emphasizes accessibility requirements and inclusive design principles for the Conditional Element.",
        "icon": "fas fa-wheelchair"
    },
    "Energy Efficiency": {
        "definition": "This node focuses on energy efficiency considerations and practices for the Conditional Element.",
        "icon": "fas fa-bolt"
    },
    "Social Impact": {
        "definition": "This node explores the social impact and community engagement aspects of the Conditional Element.",
        "icon": "fas fa-hands-helping"
    }
}       


üîµ ce_cards.js:
// ce_cards.js  
  
// Function to replace CE tags with interactive Bootstrap pills  
function replaceCETagsWithPills(content) {  
  // Define the pattern to match CE tags with their IDs  
  const ceTagPattern = /<ce id='(.*?)' type='(.*?)'>(.*?)<\/ce>/gi;  
  // Replace each CE tag with a Bootstrap pill element  
  return content.replace(ceTagPattern, (match, ceId, ceType, ceContent) => {  
    return `<span class="badge rounded-pill bg-secondary ce-pill" data-ce-id="${ceId}" data-ce-type="${ceType}">${ceContent}</span>`;  
  });  
}  
  
// Function to add event listeners to CE pills  
function addEventListenersToCEPills() {  
  // Select all elements with the 'ce-pill' class  
  const cePills = document.querySelectorAll('.ce-pill');  
  // Add a click event listener to each pill  
  cePills.forEach((pill) => {  
    pill.addEventListener('click', (event) => {  
      const ceId = event.target.dataset.ceId;  
      // Fetch and display the CE details when a pill is clicked  
      fetchCEDetails(ceId);  
    });  
  });  
}  
  
// Function to fetch and display CE details  
function fetchCEDetails(ceId) {  
  fetch(`/get_ce_by_id?ce_id=${ceId}`)  
    .then((response) => response.json())  
    .then((data) => {  
      if (data.ce) {  
        showCEModal(data.ce);  
      } else {  
        console.error('CE data not found:', data);  
      }  
    })  
    .catch((error) => {  
      console.error('Error fetching CE data:', error);  
    });  
}  
  
// Function to display the CE details in a modal using Bootstrap  
function showCEModal(ceData) {  
  // Get the modal elements  
  const modalBody = document.getElementById('ceModalBody');  
  
  if (modalBody) {  
    // Set the content  
    modalBody.innerHTML = `  
      <p><strong>ID:</strong> ${ceData.id}</p>  
      <p><strong>Content:</strong> ${ceData.content}</p>  
      <p><strong>Type:</strong> ${ceData.node_type || 'Unknown'}</p>  
    `;  
  
    // Show the modal using Bootstrap's modal method  
    const bootstrapModal = new bootstrap.Modal(document.getElementById('ceModal'));  
    bootstrapModal.show();  
  } else {  
    console.error('Modal body element not found');  
  }  
}  
  
// When the DOM is fully loaded, add event listeners to CE pills if they exist  
document.addEventListener('DOMContentLoaded', () => {  
  const cosContentContainer = document.getElementById('cos-content-container');  
  if (cosContentContainer) {  
    const contentWithCE = cosContentContainer.innerHTML;  
    cosContentContainer.innerHTML = replaceCETagsWithPills(contentWithCE);  
    addEventListenersToCEPills();  
  } else {  
    console.error('COS content container not found');  
  }  
});  

// When the DOM is fully loaded, add event listeners to CE pills if they exist  
document.addEventListener('DOMContentLoaded', () => {  
  // Select all elements that contain COS content  
  const cosItems = document.querySelectorAll('.cos-item');  
  cosItems.forEach((cosItem) => {  
    const content = cosItem.innerHTML;  
    cosItem.innerHTML = replaceCETagsWithPills(content);  
  });  
  // Add event listeners to the newly created CE pills  
  addEventListenersToCEPills();  
}); 


üìÜ models.py:
import os
from dotenv import load_dotenv
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine   
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker  
import uuid  

load_dotenv()  
  
db = SQLAlchemy()  
# Create the base class for declarative class definitions  
Base = declarative_base() 
  
# Create the engine, typically bound to a specific database URL  
_engine = create_engine(os.environ.get('SQLALCHEMY_DATABASE_URI'), echo=True)  

# Create a configured "Session" class  
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)  
  
# Create a scoped session to ensure unique sessions for each thread  
session = scoped_session(SessionLocal)  
  
class SSOL(db.Model):  
    __tablename__ = 'ssol'  
    id = db.Column(db.Integer, primary_key=True)  
    title = db.Column(db.String(255), nullable=False)  
    description = db.Column(db.Text, nullable=True)  
    cos = db.relationship('COS', back_populates='ssol')  
  
class COS(db.Model):  
    __tablename__ = 'cos'  
    id = db.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)  
    content = db.Column(db.String, nullable=False)  
    status = db.Column(db.String(50), nullable=False)  
    accountable_party = db.Column(db.String(255), nullable=True)  
    completion_date = db.Column(db.Date, nullable=True)  
    ssol_id = db.Column(db.Integer, db.ForeignKey('ssol.id'), nullable=False)  
    ssol = db.relationship('SSOL', back_populates='cos')  
    conditional_elements = db.relationship('CE', secondary='cos_ce_link', backref='cos')  
  
class CE(db.Model):  
    __tablename__ = 'ce'  
    id = db.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)  
    content = db.Column(db.String, nullable=False)  
    node_type = db.Column(db.String(50), nullable=True)  
    details = db.Column(db.Text, nullable=True)  
    cos = db.relationship(  
        'COS', secondary='cos_ce_link', back_populates='conditional_elements'  
    )  
  
class COS_CE_Link(db.Model):  
    __tablename__ = 'cos_ce_link'  
    cos_id = db.Column(UUID(as_uuid=True), db.ForeignKey('cos.id'), primary_key=True)  
    ce_id = db.Column(UUID(as_uuid=True), db.ForeignKey('ce.id'), primary_key=True)  



üì± app.py:
import os  
import logging  
from flask import Flask  
from flask_migrate import Migrate  
from dotenv import load_dotenv  
from models import db  # Import the db object from models.py  
  
# Load environment variables  
load_dotenv()  
  
# Flag to toggle database usage  
USE_DATABASE = os.environ.get('USE_DATABASE', 'False').lower() in ['true', '1', 't']  
  
# Initialize Flask app  
app = Flask(__name__)  
  
# Set the secret key from the environment variables  
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')  
  
if USE_DATABASE:  
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('SQLALCHEMY_DATABASE_URI')  
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  
    app.config['SQLALCHEMY_ECHO'] = True  
  
    # Initialize SQLAlchemy  
    db.init_app(app)  
  
    # Initialize Flask-Migrate  
    migrate = Migrate(app, db)  
  
# Import the functions from speculate after db has been initialized to avoid circular imports  
from speculate import get_badge_class_from_status  
  
# Register the custom Jinja filter function  
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status  
  
# Import the routes and register the Blueprint at the end of the file  
from routes import routes_bp  
app.register_blueprint(routes_bp)  
  
if __name__ == '__main__':  
    logging.info("Checking initial data store contents...")  
    # Import here to avoid circular imports  
    from speculate import check_data_store_contents  
    check_data_store_contents('database' if USE_DATABASE else 'in_memory')  
    app.run(debug=True)  



üè™ store.py:
# store.py  
ssol_store = {}  
cos_store = {}  
ce_store = {}  


