‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SSPEC PossPath Essential Files ‚ïë
‚ïë Date: 2024-11-25               ‚ïë
‚ïë Version: 0001                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
üåêStructured Speculation Possibility Pathfinder or "SSPEC PossPath" for short. Your task to develop the Flask Web App as an innovative tool for mass collaboration across divides. Essential app files:
üü• routes.py:
import os  
import json  
import uuid  
import pdfkit  
import openai  
from app import db  
import requests  
import logging  
from uuid import UUID
from bs4 import BeautifulSoup  
from ce_nodes import NODES  
from app import app, USE_DATABASE  
from uuid import uuid4  
from ce_templates import generate_dynamic_modal, generate_ai_data  
from sqlalchemy.exc import SQLAlchemyError  
from models import SSOL, COS, CE  
from store import ce_store, cos_store, ssol_store  
from flask import Blueprint, render_template, render_template_string, request, flash, redirect, url_for, jsonify, make_response, current_app, send_from_directory  
from werkzeug.exceptions import BadRequest, NotFound  
from utilities import generate_goal, get_domain_icon_and_name, generate_outcome_data, parse_goal_content  
from speculate import get_badge_class_from_status, delete_cos_by_id, update_ce_by_id, update_cos_by_id, create_cos, analyze_cos, get_cos_by_id, get_phase_index, get_ssol_by_id  
from dotenv import load_dotenv  
  
# Load environment variables  
load_dotenv()  
azure_openai_key = os.environ["AZURE_OPENAI_API_KEY"]  
azure_openai_endpoint = os.environ["AZURE_OPENAI_ENDPOINT"]  
azure_oai_model = os.getenv("AZURE_MODEL_NAME")  
  
# Initialize Azure OpenAI client  
openai.api_key = azure_openai_key  
openai.api_base = azure_openai_endpoint  
openai.api_type = 'azure'  
openai.api_version = '2024-03-15'  
  
# Set the secret key and database URI from the environment variables  
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')  
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('SQLALCHEMY_DATABASE_URI')  
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  
  
# Configure logging  
logging.basicConfig(level=logging.WARNING)  
  
# Register the custom Jinja filter function  
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status  
  
# Create the blueprint  
routes_bp = Blueprint('routes_bp', __name__)  
  
@routes_bp.route('/favicon.ico')  
def favicon():  
    return send_from_directory(os.path.join(current_app.root_path, 'static'),  
                               'favicon.ico', mimetype='image/vnd.microsoft.icon')  
  
@routes_bp.route('/')  
def index():  
    return render_template('input.html')  
  
@routes_bp.route('/about')  
def about():  
    return render_template('about.html')  
  
@routes_bp.route('/goal_selection', methods=['GET', 'POST'])  
def goal_selection():  
    if request.method == 'POST':  
        user_input = request.form['user_text'].strip()  
        try:  
            goal_options = generate_goal(user_input)  
            for goal in goal_options:  
                goal['icon'], goal['domain'] = get_domain_icon_and_name(goal['title'])  
                goal['title'] = parse_goal_content(goal['title'])  # Parse content  
  
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':  
                return jsonify(goals=goal_options, user_input=user_input)  
  
            return render_template('goal_selection.html', goals=goal_options, user_input=user_input)  
        except ValueError as e:  
            flash("An error occurred while processing your request. Please try again.", "error")  
    return redirect(url_for('routes_bp.index'))   


@routes_bp.route('/outcome', methods=['GET', 'POST'])  
def outcome():  
    if request.method == 'POST':  
        logging.info(f"Form data received: {request.form}")  
        selected_goal = request.form.get('selected_goal', '').strip()  
        domain = request.form.get('domain', '').strip()  
        domain_icon = request.form.get('domain_icon', '').strip()  
  
        try:  
            outcome_data = generate_outcome_data(request, 'POST', selected_goal, domain, domain_icon)  
            logging.info(f"Type of outcome_data: {type(outcome_data)}")  
            logging.info(f"Content of outcome_data: {outcome_data}")  
            return render_template('outcome.html', ssol=outcome_data, ssol_id=outcome_data['ssol_id'], nodes=NODES)  
        except Exception as e:  
            app.logger.error(f"An error occurred while generating the outcome data: {e}")  
            flash("An error occurred while generating the outcome data. Please try again.", "error")  
            return redirect(url_for('routes_bp.index'))  
  
    flash("Invalid request method.", "error")  
    return redirect(url_for('routes_bp.index'))  
  
@routes_bp.route('/save_as_pdf/<uuid:ssol_id>', methods=['POST'])  
def save_as_pdf(ssol_id):  
    try:  
        data = request.get_json()  
        html_content = data['htmlContent']  
        if not html_content:  
            raise ValueError("No HTML content provided.")  
  
        css_file_path = os.path.join(current_app.root_path, current_app.static_folder, 'styles.css')  
        html_content = html_content.replace('src="/static/', f'src="{url_for("static", filename="", _external=True)}')  
  
        options = {  
            "page-size": "Letter",  
            "margin-top": "0.75in",  
            "margin-right": "0.75in",  
            "margin-bottom": "0.75in",  
            "margin-left": "0.75in",  
            "encoding": "UTF-8",  
            "custom-header": [("Accept-Encoding", "gzip")],  
            "no-outline": None,  
            "enable-local-file-access": None,  
        }  
  
        pdf = pdfkit.from_string(html_content, False, options=options, css=css_file_path)  
  
        response = make_response(pdf)  
        response.headers['Content-Type'] = 'application/pdf'  
        response.headers['Content-Disposition'] = f'attachment; filename="Structured Solution {ssol_id}.pdf"'  
  
        return response  
    except Exception as e:  
        current_app.logger.error(f"Exception in save_as_pdf: {e}")  
        return jsonify(success=False, error=str(e)), 500  
  
@routes_bp.route('/update_cos/<uuid:cos_id>', methods=['PUT'])  
def update_cos_route(cos_id):  
    try:  
        data = request.get_json()  
        if not data:  
            raise BadRequest('No JSON payload received')  
  
        update_result = update_cos_by_id(cos_id, data)  
  
        if update_result['success']:  
            return jsonify(success=True, cos=update_result['cos']), 200  
        else:  
            return jsonify(success=False, error=update_result['message']), 404  
    except BadRequest as e:  
        return jsonify(error=str(e)), 400  
    except Exception as e:  
        current_app.logger.error(f"Error updating COS with ID {cos_id}: {e}", exc_info=True)  
        return jsonify(error="An unexpected error occurred while updating the COS."), 500  

  
@routes_bp.route('/delete_cos/<uuid:cos_id>', methods=['DELETE'])  
def delete_cos_route(cos_id):  
    try:  
        if delete_cos_by_id(cos_id):  
            return jsonify(success=True), 200  
        else:  
            raise NotFound('Condition of Satisfaction could not be found or deleted.')  
    except NotFound as e:  
        logging.warning(f"NotFound: {e}")  
        return jsonify(success=False, error=str(e)), 404  
    except Exception as e:  
        logging.error(f"Unexpected error occurred: {e}", exc_info=True)  
        return jsonify(success=False, error=str(e)), 500  

@routes_bp.route('/create_cos', methods=['POST'])  
def create_cos_route():  
    try:  
        data = request.get_json()  
        if not data:  
            raise BadRequest('No JSON payload received')  
  
        ssol_id = data.get('ssol_id')  
        content = data.get('content')  
        status = data.get('status')  
        accountable_party = data.get('accountable_party')  
        completion_date = data.get('completion_date')  
  
        cos_id = create_cos(ssol_id, content, status, accountable_party, completion_date)  
        if cos_id:  
            return jsonify(success=True, cos=get_cos_by_id(cos_id).to_dict()), 201  
        else:  
            raise Exception('Failed to create COS.')  
    except BadRequest as e:  
        return jsonify(error=str(e)), 400  
    except Exception as e:  
        current_app.logger.error(f"Error creating COS: {e}", exc_info=True)  
        return jsonify(error="An unexpected error occurred while creating the COS."), 500  
  
@routes_bp.route('/get_ce_modal/<string:ce_type>', methods=['POST'])  
def get_ce_modal_route(ce_type):  
    try:  
        data = request.get_json()  
        current_app.logger.debug(f"Received data: {data}")  
  
        if not isinstance(data, dict):  
            raise ValueError("Received data is not a dictionary")  
  
        required_keys = ['cos_content', 'ce_id', 'ssol_goal']  
        for key in required_keys:  
            if key not in data:  
                raise ValueError(f"Missing required key: {key}")  
  
        # Fetch AI-generated data  
        current_app.logger.info(f"Calling generate_ai_data with COS content: {data['cos_content']}, CE ID: {data['ce_id']}, CE Type: {ce_type}, SSOL Goal: {data['ssol_goal']}")  
        ai_generated_data = generate_ai_data(data['cos_content'], data['ce_id'], ce_type, data['ssol_goal'], existing_ces=[])  # Provide an empty list by default  
        current_app.logger.debug(f"AI Generated Data: {ai_generated_data}")  
  
        # Fetch CE data including table data  
        ce_data = fetch_ce_data(data['ce_id'])  
        current_app.logger.debug(f"Fetched CE data: {ce_data}")  
  
        # Get tabulator columns configuration  
        node_info = NODES.get(ce_type, NODES['Default'])  
        tabulator_columns = node_info.get('tabulator_config', {}).get('columns', [])  
  
        # Generate modal content with all the necessary data  
        modal_content = generate_dynamic_modal(ce_type, ce_data, data['cos_content'], ai_generated_data, data['phase_name'], data['phase_index'], ce_store)  
  
        return jsonify(  
            modal_html=modal_content,  
            table_data=ce_data.get('table_data', []),  
            tabulator_columns=tabulator_columns,  
            ai_generated_data=ai_generated_data  
        )  
    except ValueError as ve:  
        current_app.logger.error(f"ValueError in get_ce_modal_route: {str(ve)}", exc_info=True)  
        return jsonify(error=str(ve)), 400  
    except Exception as e:  
        current_app.logger.error(f"Error getting modal content for CE type {ce_type}: {e}", exc_info=True)  
        return jsonify(error=str(e)), 500  


  
@routes_bp.route('/analyze_cos/<string:cos_id>', methods=['GET'])  
def analyze_cos_route(cos_id):  
    logging.info(f"Analyzing COS with ID: {cos_id}")  
    try:  
        analysis_result = analyze_cos_by_id(cos_id)  
        if analysis_result['success']:  
            return jsonify(analysis_result['analysis_results']), 200  
        else:  
            return jsonify({'error': analysis_result['message']}), 404  
    except ValueError:  
        return jsonify({'error': "Invalid COS ID"}), 400  
    except Exception as e:  
        return jsonify({'error': str(e)}), 500  
  
def analyze_cos_by_id(cos_id_str):  
    try:  
        cos = COS.query.get(cos_id_str) if USE_DATABASE else cos_store.get(cos_id_str)  
        if not cos:  
            return {'success': False, 'message': "COS not found."}  
  
        analysis_results = analyze_cos(cos.content if USE_DATABASE else cos['content'])  
        return {'success': True, 'analysis_results': analysis_results}  
    except Exception as e:  
        return {'success': False, 'message': f"An unexpected error occurred: {str(e)}"}  
  
@routes_bp.route('/update_ce/<uuid:ce_id>', methods=['PUT'])  
def update_ce(ce_id: UUID):  
    ce_data = request.get_json()  
    try:  
        # Log the CE ID and data for debugging  
        current_app.logger.info(f"Attempting to update CE with ID: {ce_id}")  
        current_app.logger.info(f"CE Data: {ce_data}")  

        success = update_ce_by_id(ce_id, ce_data)  
        if success:  
            return jsonify(success=True), 200  
        else:  
            return jsonify(success=False, error="Conditional Element not found."), 404  
    except Exception as e:  
        return jsonify(success=False, error=str(e)), 500  

  
@routes_bp.route('/ai-query-endpoint', methods=['POST'])  
def ai_query_endpoint():  
    try:  
        data = request.get_json()  
        current_app.logger.info(f"AI Query Request Data: {data}")  # Add logging for request data  
        if not data:  
            raise BadRequest('No JSON payload received.')  
  
        cos_text = data.get('cos_content')  # Updated to match the front-end key  
        ce_id = data.get('ce_id')  
        ce_type = data.get('ce_type')  
        ssol_goal = data.get('ssol_goal')  
        existing_ces = data.get('existing_ces', [])  # Include existing CEs  
  
        if not all([cos_text, ce_id, ce_type, ssol_goal]):  
            raise BadRequest('Missing required fields in JSON payload.')  
  
        # Generate AI data  
        ai_response = generate_ai_data(cos_text, ce_id, ce_type, ssol_goal, existing_ces)  
        current_app.logger.info(f"AI Response Data: {ai_response}")  # Add logging for AI response data  
        return jsonify(ai_response=ai_response), 200  
    except BadRequest as e:  
        current_app.logger.error(f"BadRequest in AI query endpoint: {e}")  
        return jsonify(success=False, error=str(e)), 400  
    except Exception as e:  
        current_app.logger.error(f"Exception in AI query endpoint: {e}")  
        return jsonify(success=False, error=str(e)), 500  

  
# Function to fetch actual CE data  
def fetch_ce_data(ce_type):  
    try:  
        if USE_DATABASE:  
            ce_data = CE.query.filter_by(node_type=ce_type).first()  
            if ce_data:  
                current_app.logger.debug(f"Fetched CE data from database for type '{ce_type}': {ce_data}")  
            else:  
                current_app.logger.warning(f"CE data for type '{ce_type}' not found in the database.")  
        else:  
            ce_data = next((ce for ce in ce_store.values() if ce.get('node_type') == ce_type), None)  
            if ce_data:  
                current_app.logger.debug(f"Fetched CE data from in-memory store for type '{ce_type}': {ce_data}")  
            else:  
                current_app.logger.warning(f"CE data for type '{ce_type}' not found in the in-memory store.")  
  
        if not ce_data:  
            current_app.logger.warning(f"CE data for type '{ce_type}' not found. Falling back to Default node type.")  
            ce_data = NODES.get('Default')  
            ce_data = {  
                'id': 'default_id',  
                'content': '',  
                'node_type': 'Default',  
                'details': ''  
            }  
  
        return ce_data  
    except Exception as e:  
        current_app.logger.error(f"Error fetching CE data for type '{ce_type}': {e}", exc_info=True)  
        return None  
  
# Debug routes for logging CE entries  
@routes_bp.route('/debug/log_ce_entries', methods=['GET'])  
def debug_log_ce_entries():  
    log_ce_entries()  
    return jsonify({"message": "Logged CE entries"}), 200  
  
@routes_bp.route('/debug/log_in_memory_ce_entries', methods=['GET'])  
def debug_log_in_memory_ce_entries():  
    try:  
        from store import ce_store  
        for ce_id, ce in ce_store.items():  
            current_app.logger.debug(f"CE ID: {ce_id}, Type: {ce.get('node_type')}, Content: {ce.get('content')}")  
        return jsonify({"message": "Logged in-memory CE entries"}), 200  
    except Exception as e:  
        current_app.logger.error(f"Error logging in-memory CE entries: {e}", exc_info=True)  
        return jsonify({"message": "Error logging in-memory CE entries", "error": str(e)}), 500  
  
# Other utility functions  
@routes_bp.route('/api/ce_store', methods=['GET'])  
def get_ce_store():  
    return jsonify(ce_store)  

def log_ce_entries():  
    ce_entries = CE.query.all()  
    for ce in ce_entries:  
        current_app.logger.debug(f"CE ID: {ce.id}, Type: {ce.node_type}, Content: {ce.content}")  
  
def log_in_memory_ce_entries():  
    for ce_id, ce in ce_store.items():  
        current_app.logger.debug(f"CE ID: {ce_id}, Type: {ce.get('node_type')}, Content: {ce.get('content')}")  
  
@routes_bp.route('/fetch_ce_data/<uuid:ce_id>', methods=['GET'])  
def fetch_ce_data(ce_id):  
    try:  
        if USE_DATABASE:  
            ce = CE.query.get(ce_id)  
            if ce:  
                return ce.to_dict()  
            else:  
                raise ValueError(f"CE with ID {ce_id} not found in the database.")  
        else:  
            ce_dict = ce_store.get(str(ce_id))  
            if ce_dict:  
                return ce_dict  
            else:  
                raise ValueError(f"CE with ID {ce_id} not found in the in-memory store.")  
    except ValueError as e:  
        logging.error(f"Error retrieving CE by ID {ce_id}: {e}")  
        raise e  
    except SQLAlchemyError as e:  
        logging.error(f"Database error retrieving CE by ID {ce_id}: {e}", exc_info=True)  
        raise e  
    except Exception as e:  
        logging.error(f"Unexpected error retrieving CE by ID {ce_id}: {e}", exc_info=True)  
        raise e  
  
@routes_bp.route('/update_ce_data/<uuid:ce_id>', methods=['POST'])  
def update_ce_data(ce_id):  
    try:  
        data = request.get_json()  
        success = update_ce_by_id(ce_id, data)  
        if success:  
            return jsonify(success=True), 200  
        else:  
            return jsonify(success=False, error="Failed to update CE data."), 500  
    except Exception as e:  
        return jsonify(success=False, error=str(e)), 500  
  
@routes_bp.route('/save_ce_data', methods=['POST'])  
def save_ce_data():  
    try:  
        data = request.get_json()  
        for ce in data:  
            if USE_DATABASE:  
                ce_instance = CE.query.get(ce['id']) or CE(id=uuid.uuid4())  
                ce_instance.content = ce['field1']  
                ce_instance.node_type = ce['field2']  
                ce_instance.details = ce['field3']  
                db.session.add(ce_instance)  
            else:  
                ce_id = ce.get('id') or str(uuid.uuid4())  
                ce_store[ce_id] = {  
                    'id': ce_id,  
                    'content': ce['field1'],  
                    'node_type': ce['field2'],  
                    'details': ce['field3']  
                }  
        if USE_DATABASE:  
            db.session.commit()  
        return jsonify(success=True)  
    except Exception as e:  
        current_app.logger.error(f"Error saving CE data: {e}")  
        return jsonify(success=False, error=str(e)), 500  
  


üü® utilities.py:
import io  
import os  
import re  
import html  
import json  
import time  
import uuid  
import logging  
from uuid import uuid4  
import warnings  
from PIL import Image  
from bs4 import BeautifulSoup  
from dotenv import load_dotenv  
from openai import AzureOpenAI  
from app import USE_DATABASE, db  
from ce_nodes import get_valid_node_types  
from models import COS, CE, SSOL, COS_CE_Link  
from store import ssol_store, cos_store, ce_store  
from stability_sdk import client as stability_client  
from flask import current_app, flash, render_template  
import stability_sdk.interfaces.gooseai.generation.generation_pb2 as generation  
  
# Load environment variables  
load_dotenv()  
azure_oai_key = os.getenv("AZURE_OPENAI_API_KEY")  
azure_oai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")  
azure_oai_deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")  
azure_oai_model = os.getenv("AZURE_MODEL_NAME")  
stability_api_key = os.getenv("STABILITY_KEY")  
  
# Initialize the AzureOpenAI client as a global variable  
azure_openai_client = AzureOpenAI(  
    azure_endpoint=azure_oai_endpoint,  
    api_key=azure_oai_key,  
    api_version="2024-08-01-preview"  
)  
  
class Logger:  
    HEADER = '\033[95m'  
    OKBLUE = '\033[94m'  
    OKCYAN = '\033[96m'  
    OKGREEN = '\033[92m'  
    WARNING = '\033[93m'  
    FAIL = '\033[91m'  
    ENDC = '\033[0m'  
    BOLD = '\033[1m'  
    UNDERLINE = '\033[4m'  
  
    @staticmethod  
    def log_message(message, level='info'):  
        if level == 'info':  
            formatted_message = f"{Logger.OKCYAN}{message}{Logger.ENDC}"  
        elif level == 'warning':  
            formatted_message = f"{Logger.WARNING}{message}{Logger.ENDC}"  
        elif level == 'error':  
            formatted_message = f"{Logger.FAIL}{message}{Logger.ENDC}"  
        elif level == 'debug':  
            formatted_message = f"{Logger.OKBLUE}{message}{Logger.ENDC}"  
        else:  
            formatted_message = message  
  
        print(formatted_message)  
  
def generate_chat_response(messages, role, task, temperature=0.75, retries=3, backoff_factor=2):  
    last_exception = None  
    for retry_attempt in range(retries):  
        try:  
            # Ensure the system message indicates JSON response format  
            system_message = {  
                "role": "system",  
                "content": "You are a helpful assistant. Please respond with information in JSON format."  
            }  
            messages_with_json = [system_message] + messages  
  
            # Log the constructed messages for debugging  
            current_app.logger.debug(f"Constructed Messages for generate_chat_response: {json.dumps(messages_with_json, indent=2)}")  
  
            current_app.logger.debug(f"Sending request to Azure OpenAI: {messages_with_json}")  
  
            # Send request to Azure OpenAI model using JSON mode  
            response = azure_openai_client.chat.completions.create(  
                model=azure_oai_model,  
                response_format={"type": "json_object"},  
                messages=messages_with_json,  
                temperature=temperature,  
                max_tokens=1800  
            )  
            response_content = response.choices[0].message.content  
            current_app.logger.debug(f"Received response from AI: {response_content}")  
            return response_content  
        except Exception as e:  
            last_exception = e  
            if retry_attempt < retries - 1:  
                sleep_time = backoff_factor ** (retry_attempt + 1)  
                current_app.logger.error(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.")  
                time.sleep(sleep_time)  
            else:  
                current_app.logger.error(f"Error in generate_chat_response: {e}. All retries exhausted.")  
  
    # Raise the last exception if all retries fail  
    raise last_exception  
  
def parse_ai_response_and_generate_html(response_json):  
    structured_solution = {}  
    expected_phases = ["Discovery", "Engagement", "Action", "Completion", "Legacy"]  
  
    for phase in expected_phases:  
        structured_solution[phase] = []  
        for cos in response_json.get(phase, []):  
            cos_id = str(uuid.uuid4())  
            cos_html = cos['content']  
            ces = []  
  
            soup = BeautifulSoup(cos_html, 'html.parser')  
            for ce_tag in soup.find_all('ce'):  
                ce_uuid = str(uuid.uuid4())  
                new_tag = soup.new_tag('span', attrs={  
                    'class': 'badge rounded-pill bg-secondary ce-pill',  
                    'data-ce-id': ce_uuid,  
                    'data-ce-type': ce_tag['type']  
                })  
                new_tag.string = ce_tag.string  
                ce_tag.replace_with(new_tag)  
  
                ce_data = {  
                    'id': ce_uuid,  
                    'content': ce_tag.string,  
                    'status': 'Proposed',  
                    'type': ce_tag['type']  
                }  
                ces.append(ce_data)  
  
                # Store the CEs  
                if USE_DATABASE:  
                    ce_instance = CE(id=ce_uuid, content=ce_tag.string, node_type=ce_tag['type'])  
                    db.session.add(ce_instance)  
                else:  
                    ce_store[ce_uuid] = ce_data  
  
            if USE_DATABASE:  
                db.session.commit()  
  
            structured_solution[phase].append({  
                'id': cos_id,  
                'content': str(soup),  
                'status': 'Proposed',  
                'ces': ces  
            })  
  
    return structured_solution  
  
def generate_outcome_data(request, method, selected_goal=None, domain=None, domain_icon=None):  
    # Initialize outcome_data with default keys and values  
    outcome_data = {  
        'user_input': '',  
        'selected_goal': selected_goal,  
        'domain_icon': domain_icon,  
        'domain': domain,  
        'ssol_id': None,  
        'ssol_summary': "An error occurred while processing the summary data.",  
        'phases': {},  
        'generated_image_path': 'images/sspec_default.png'  
    }  
  
    user_input = request.form.get('user_text', '').strip() if method == 'POST' else request.args.get('user_text', '').strip()  
    outcome_data['user_input'] = user_input  
  
    # Generate or retrieve an SSOL instance and get the id  
    if USE_DATABASE:  
        ssol_instance = SSOL.query.filter_by(title=selected_goal).first()  
        if not ssol_instance:  
            ssol_instance = SSOL(title=selected_goal, description='')  
            db.session.add(ssol_instance)  
            db.session.commit()  
        ssol_id = ssol_instance.id  
    else:  
        ssol_instance = next((ssol for ssol in ssol_store.values() if ssol['title'] == selected_goal), None)  
        if not ssol_instance:  
            ssol_id = str(uuid4())  
            ssol_instance = {'id': ssol_id, 'title': selected_goal, 'description': ''}  
            ssol_store[ssol_id] = ssol_instance  
        ssol_id = ssol_instance['id']  
  
    outcome_data['ssol_id'] = ssol_id  
  
    # Generate the high-level summary  
    summary_messages = [  
    {  
        "role": "system",  
        "content": (  
            "Assume it is possible to fulfill any outcome, generate a high-level summary "  
            "(key name: summary) of everything required for the goal working backwards from fulfilled by some point in the future, "  
            "includle any existing or potential legal, scientific, logistic or other barriers which needed to be addressed for completion."  
        )  
    },  
    {  
        "role": "user",  
        "content": (  
            f"Generate a high-level, elegantly-formatted summary for the goal: '{selected_goal}'. "  
            "Please format the summary using Bootstrap-safe HTML, including tags such as <br> for line breaks "  
            "and ordered lists."  
        )  
    }  
]  
  
    try:  
        summary_response = generate_chat_response(summary_messages, role='Outcome Generation', task='Generate High-Level Summary')  
        summary_data = json.loads(summary_response)  
        outcome_data['ssol_summary'] = summary_data.get('summary', "Summary not available.")  
    except Exception as e:  
        current_app.logger.error(f"Error in generate_outcome_data (summary): {e}", exc_info=True)  
  
    # Generate the structured solution  
    structured_solution_messages = [  
    {  
        "role": "system",  
        "content": "You are a helpful assistant. Generate detailed Conditions of Satisfaction (COS) and multiple Conditional Elements (CE) for each COS of a project, including specific attributes for each CE."  
    },  
    {  
        "role": "user",  
        "content": (  
            f"Generate a concise Structured Solution for the project '{selected_goal}'. "  
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 targeted Conditions of Satisfaction (COS). "  
            "For each COS, identify and list 2 to 4 specific and succinct Conditional Elements (CE) with unique IDs. "  
            "Focus on essential contributors such as resources, legislation, research, stakeholders, and timelines. "  
            "Select the most specific type from CE_nodes.py for each CE, denoted with <ce> tags. "  
            "Account for interdependencies and their impacts across project phases. "  
            "Format your response as a JSON object with each phase as a key and an array of COS objects as values. "  
            "Each COS object should include brief COS text, a unique ID, a status (Proposed), and an array of CEs. "  
            "Each CE should be a JSON object with 'id', 'content' (2-4 sentences), 'status', 'type', and additional details as needed. "  
  
            "Here is an example for the Discovery phase: "  
            "'Discovery': ["  
            "    {"  
            "      'id': 'COS-001',"  
            "      'content': '<ce id=\"CE-001\" type=\"Research\">Market research</ce> to assess <ce id=\"CE-002\" type=\"Demand\">consumer interest</ce> in a <ce id=\"CE-003\" type=\"Product\">new product</ce>.' ,"  
            "      'status': 'Proposed',"  
            "      'ces': ["  
            "        {'id': 'CE-001', 'content': 'Conduct market analysis', 'status': 'Proposed', 'type': 'Research'},"  
            "        {'id': 'CE-002', 'content': 'Evaluate consumer demand', 'status': 'Proposed', 'type': 'Demand'},"  
            "        {'id': 'CE-003', 'content': 'Define product concept', 'status': 'Proposed', 'type': 'Product'}"  
            "      ]"  
            "    }"  
            "]"  
        )  
    }  
]  
  
    try:  
        structured_solution_response = generate_chat_response(structured_solution_messages, role='Structured Solution Generation', task='Generate Structured Solution')  
        structured_solution_json = json.loads(structured_solution_response)  
  
        # Ensure the structured_solution_json is a dictionary before processing  
        if isinstance(structured_solution_json, dict):  
            outcome_data['phases'] = parse_ai_response_and_generate_html(structured_solution_json)  
        else:  
            logging.error("Expected a dictionary for the structured solution JSON response.")  
            outcome_data['phases'] = {}  
    except json.JSONDecodeError as e:  
        logging.error(f"JSON decoding error: {e}")  
        outcome_data['phases'] = {}  
    except Exception as e:  
        logging.error(f"Error in generate_outcome_data (structured solution): {e}", exc_info=True)  
        outcome_data['phases'] = {}  
  
    # Generate an image using Stability AI  
    try:  
        image_prompt = f"A colorful, visually stunning photograph of a retro-futuristic tableau depicting '{selected_goal}' as a fulfilled goal, diverse,It's a Small World, 1962, photo-realistic, isometric, tiltshift "  
        web_image_path = generate_image(image_prompt, selected_goal)  
        outcome_data['generated_image_path'] = web_image_path  
    except Exception as e:  
        current_app.logger.error(f"Error generating image: {e}", exc_info=True)  
        outcome_data['generated_image_path'] = 'images/sspec_default.png'  
  
    # Return the outcome_data for rendering in the template  
    return outcome_data  
  
def parse_goal_content(content):  
    try:  
        parsed_content = json.loads(content)  
        # Convert JSON to a displayable string format  
        if isinstance(parsed_content, dict):  
            return '<br>'.join(f"<strong>{key.title()}:</strong> {value}" for key, value in parsed_content.items())  
        elif isinstance(parsed_content, list):  
            return '<ul>' + ''.join(f"<li>{item}</li>" for item in parsed_content) + '</ul>'  
    except (json.JSONDecodeError, TypeError):  
        return content  # Return the original content if it's not JSON   
  
def analyze_user_input(text):  
    messages = [  
        {"role": "system", "content": "You are an AI that analyzes user inputs and extracts keywords."},  
        {"role": "user", "content": text},  
    ]  
  
    response_text = generate_chat_response(messages, role='Keyword Extraction', task='Extract Keywords', temperature=0.75)  
    keywords = response_text.split(', ')  
    print(f"Keywords: {keywords}")  
    return keywords  
  
def generate_sentiment_analysis(text, temperature=0.7):  
    messages = [  
        {"role": "system", "content": "You are an AI trained to analyze sentiment and return POSITIVE, NEGATIVE, or NEUTRAL"},  
        {"role": "user", "content": f"What sentiment is expressed in the following text: '{text}'?"},  
    ]  
  
    # Use the generate_chat_response function  
    response_text = generate_chat_response(messages, role='Sentiment Analysis', task='Analyze Sentiment', temperature=temperature)  
  
    # Parse the response to extract the sentiment  
    sentiment = "NEUTRAL"  # Default to NEUTRAL if parsing fails or no clear sentiment is found  
    if "positive" in response_text.lower():  
        sentiment = "POSITIVE"  
    elif "negative" in response_text.lower():  
        sentiment = "NEGATIVE"  
    elif "neutral" in response_text.lower():  
        sentiment = "NEUTRAL"  
  
    return sentiment  
  
def generate_goal(user_input):  
    goal_options = []  
    temperatures = [0.6, 0.8, 1.0]  
  
    while len(goal_options) < 3:  
        for i, temp in enumerate(temperatures):  
            messages = [  
                {"role": "system", "content": "You are an AI that generates innovative and unique goal outcomes or intentions based on the user's input. Structure your response in JSON format with a 'goal' key."},  
                {"role": "user", "content": user_input},  
            ]  
  
            try:  
                response = generate_chat_response(messages, role='Goal Generation', task=f'Generate Goal (Variation {i + 1})', temperature=temp).strip()  
                goal_option_data = json.loads(response)  
                goal_option = goal_option_data['goal']  # Expecting the response to have a 'goal' key  
  
                # Parse the goal content for display  
                parsed_goal_content = parse_goal_content(goal_option)  
  
                goal_compliant, non_compliance_reason = is_goal_compliant(goal_option)  
                if goal_compliant and parsed_goal_content not in [g['title'] for g in goal_options]:  
                    goal_options.append({'title': parsed_goal_content, 'compliant': goal_compliant, 'reason': non_compliance_reason})  
                elif not goal_compliant:  
                    goal_options.append({'title': parsed_goal_content, 'compliant': False, 'reason': non_compliance_reason})  
  
                if len(goal_options) == 3:  
                    break  
  
            except json.JSONDecodeError as e:  
                print(f"Error parsing JSON in generate_goal (Variation {i + 1}): {e}")  
                raise e  
            except Exception as e:  
                print(f"Error in generate_goal (Variation {i + 1}): {e}")  
                raise e  
  
    if len(goal_options) < 3:  
        raise ValueError("Failed to generate unique goals. Please try again.")  
  
    return goal_options   
  
def is_goal_compliant(selected_goal):  
    sentiment_counts = {'POSITIVE': 0, 'NEGATIVE': 0, 'NEUTRAL': 0}  
  
    for _ in range(5):  
        try:  
            sentiment_label = generate_sentiment_analysis(selected_goal)  
            # Ensure the label is uppercase to match dictionary keys  
            sentiment_counts[sentiment_label.upper()] += 1  
        except ValueError as e:  
            print(f"Error in sentiment analysis: {e}")  
            continue  
  
    # Determine compliance based on the sentiment counts  
    if sentiment_counts['POSITIVE'] >= 3:  
        return True, ''  
    elif sentiment_counts['NEGATIVE'] >= 3:  
        return False, 'The goal does not comply with the safety protocol.'  
    else:  
        return True, 'The goal has a neutral sentiment and is allowed.'  
  
def get_domain_icon_and_name(goal_domain):  
    messages = [  
        {"role": "system", "content": "You are an AI that suggests a domain and FontAwesome 6 Solid (fas) class icon based on the goal domain. Output only the domain and icon class in JSON format."},  
        {"role": "user", "content": f"What is the best domain and corresponding FontAwesome icon class for the goal related to '{goal_domain}'?"}  
    ]  
    response_content = generate_chat_response(messages, role='Domain and Icon', task='Fetch Domain and free FontAwesome 6 Icon', temperature=0.37)  
  
    try:  
        # Log the raw response content for debugging  
        Logger.log_message(f"Raw response content: {response_content}", 'debug')  
  
        # Parse the JSON string into a dictionary  
        response_data = json.loads(response_content)  
        # Make sure to match the keys exactly with the response content  
        domain = response_data.get("domain")  
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"  
  
        if not domain or not icon_class:  
            # Log a warning if expected keys are missing  
            Logger.log_message("Missing 'domain' or 'iconClass' in AI response.", 'warning')  
            raise ValueError("Failed to generate domain and icon. Please try again.")  
  
        return icon_class, domain  
  
    except json.JSONDecodeError as e:  
        # Log the JSON parsing error  
        Logger.log_message(f"JSON parsing error: {e}", 'error')  
        raise ValueError("Failed to parse JSON response. Please try again.")  
  
    except Exception as e:  
        # Log any other exceptions  
        Logger.log_message(f"Unexpected error: {e}", 'error')  
        raise  
  
def get_cos_by_guid(ssol, cos_guid):  
    for phase in ssol['phases'].values():  
        for cos in phase:  
            if cos['id'] == cos_guid:  
                return cos  
    return None  
  
def update_cos_content_by_guid(ssol, cos_guid, new_content):  
    cos = get_cos_by_guid(ssol, cos_guid)  
    if cos:  
        cos['content'] = new_content  
        return True  
    return False  
  
def sanitize_filename(filename):  
    # Sanitize the filename by removing or replacing invalid characters.  
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', filename)  # Remove invalid characters  
    filename = re.sub(r'[\s]+', '_', filename)  # Replace spaces with underscores  
    return filename[:255]  # Truncate long filenames  
  
def generate_image(prompt, goal_title, seed=None, width=512, height=512):  
    if not azure_oai_key or not stability_api_key:  
        raise ValueError("API keys are not provided for Azure OpenAI or Stability SDK.")  
  
    stability_api = stability_client.StabilityInference(  
        key=stability_api_key,  
        verbose=True,  
        engine="stable-diffusion-xl-beta-v2-2-2",  
    )  
  
    # Generate a unique filename for the image  
    unique_filename = f"generated_image_{uuid.uuid4().hex}.png"  
  
    # Ensure the 'static/images' directory exists within your Flask app structure  
    static_folder = current_app.static_folder  
    image_folder = os.path.join(static_folder, 'images')  
    os.makedirs(image_folder, exist_ok=True)  # Create the folder if it does not exist  
    image_file_path = os.path.join(image_folder, unique_filename)  # Full path for saving the file  
  
    try:  
        answers = stability_api.generate(  
            prompt=prompt,  
            seed=seed,  
            steps=30,  
            cfg_scale=8.0,  
            width=width,  
            height=height,  
            samples=1,  
            sampler=generation.SAMPLER_K_DPMPP_2M,  
        )  
  
        for resp in answers:  
            for artifact in resp.artifacts:  
                if artifact.finish_reason == generation.FILTER:  
                    warnings.warn("Your request activated the API's safety filters and could not be processed. Please modify the prompt and try again.")  
                if artifact.type == generation.ARTIFACT_IMAGE:  
                    img = Image.open(io.BytesIO(artifact.binary))  
                    img.save(image_file_path)  # Save the image using the correct directory and filename  
                    # Convert the path to URL-friendly format  
                    web_path = os.path.join('images', unique_filename).replace("\\", "/")  
                    return web_path  
    except Exception as e:  
        print(f"Error in generate_image: {e}")  
  
    # If an error occurs or the image is not generated, use a placeholder image  
    placeholder_image_path = os.path.join('images', 'sspec_default.png').replace("\\", "/")  
    return placeholder_image_path  
  
def generate_structured_solution(selected_goal):  
    structured_solution = {}  
    system_message = {  
        "role": "system",  
        "content": (  
            "You are an AI that generates a structured solution for a project. "  
            "For each phase of the project, generate Conditions of Satisfaction (COS) with embedded Conditional Elements (CEs). "  
            "Use <ce> tags to denote CEs within the COS text and provide each CE with a unique identifier and type. "  
            "Return a JSON object with phases as keys and lists of COS objects as values. "  
            "Each COS object should include the COS text with embedded CEs, a unique ID, a status, and an array of CEs. "  
            "Each CE should be represented within the COS text and also listed as a JSON object with 'id', 'content', and 'type' keys. "  
            "The keys for COS text, status, and CEs should be 'cos_text', 'cos_status', and 'cos_ces' respectively."  
        )  
    }  
  
    user_message = {  
        "role": "user",  
        "content": (  
            f"Generate a Structured Solution for the project '{selected_goal}'. "  
            "For each phase (Discovery, Engagement, Action, Completion, Legacy), provide 2 to 5 specific and succinct COS. "  
            "Within each COS text, identify and label relevant keywords as CEs using <ce> tags. "  
            "Assign each CE a unique ID and a type that best describes its role or category in the context of the COS. "  
            "Provide a brief explanation for each COS's importance and how it contributes to the overall goal. "  
            "Format your response as a JSON object with each phase as a key and an array of COS objects. "  
            "Use the keys 'cos_text', 'cos_status', and 'cos_ces' for COS text, status, and CEs respectively."  
        )  
    }  
  
    messages = [system_message, user_message]  
    try:  
        response_text = generate_chat_response(  
            messages,  
            role='Structured Solution Generation',  
            task='Generate Structured Solution',  
            temperature=0.75,  
            retries=3,  
            backoff_factor=2  
        )  
  
        # Check if the response is complete and valid JSON before parsing  
        if response_text and response_text.strip().endswith('}'):  
            response_json = json.loads(response_text)  
        else:  
            raise ValueError("Incomplete JSON response received from AI.")  
  
        # Iterate over the phases and extract the COS and CEs directly from the list  
        structured_solution['phases'] = {  
            phase: [  
                {  
                    'id': cos.get('id', str(uuid.uuid4())),  
                    'status': 'Proposed',  
                    'cos_text': cos['cos_text'],  # Corrected key  
                    'ces': cos.get('CEs', [])  
                }  
                for cos in response_json.get(phase, [])  
            ]  
            for phase in ['Discovery', 'Engagement', 'Action', 'Completion', 'Legacy']  
        }  
  
        return structured_solution  # Return the correctly structured solution  
  
    except json.JSONDecodeError as e:  
        current_app.logger.error(f"Error parsing JSON response: {e}", exc_info=True)  
        raise ValueError("Failed to parse JSON response.")  
    except ValueError as e:  
        current_app.logger.error(f"Error in generating structured solution: {e}", exc_info=True)  
        raise  
    except Exception as e:  
        current_app.logger.error(f"Unexpected error in generating structured solution: {e}", exc_info=True)  
        raise ValueError("Failed to generate structured solution.")  
  
def generate_chat_response_with_node_types(messages, role, task, temperature=0.75, retries=3, backoff_factor=2):  
    last_exception = None  
    for retry_attempt in range(retries):  
        try:  
            node_types = get_valid_node_types()  # Fetch valid node types  
            node_types_str = ', '.join(node_types)  
  
            # Ensure the system message indicates JSON response format  
            system_message = {  
                "role": "system",  
                "content": "You are a helpful assistant. Please respond with information in JSON format. Valid Node Types: " + node_types_str  
            }  
            messages_with_json = [system_message] + messages  
  
            # Send request to Azure OpenAI model using JSON mode  
            response = azure_openai_client.chat.completions.create(  
                model=azure_oai_model,  
                response_format={"type": "json_object"},  
                messages=messages_with_json,  
                temperature=temperature,  
                max_tokens=1800  
            )  
            response_content = response.choices[0].message.content  
            Logger.log_message(f"SSPEC Response ({role} - {task}): {response_content}", 'debug')  
            return response_content  
        except Exception as e:  
            last_exception = e  
            if retry_attempt < retries - 1:  
                sleep_time = backoff_factor ** (retry_attempt + 1)  
                Logger.log_message(f"Error in generate_chat_response: {e}. Retrying in {sleep_time} seconds.", 'error')  
                time.sleep(sleep_time)  
            else:  
                Logger.log_message(f"Error in generate_chat_response: {e}. All retries exhausted.", 'error')  
  
    # Raise the last exception if all retries fail  
    raise last_exception  


üü© goal_selection.html:
{% extends 'base.html' %}  
  
{% block content %}  
<div class="container mt-4">  
  <h1>What is your Commitment?</h1>  
  <table class="table table-bordered">  
    <thead>  
      <tr>  
        <th>Your Input</th>  
        <th class="text-end">Actions</th>  
      </tr>  
    </thead>  
    <tbody>  
      <tr>  
        <td class="user-input">{{ user_input }}</td>  
        <td class="text-end">  
          <button type="button" class="btn btn-primary btn-sm edit-user-input">Edit</button>  
          <button type="button" class="btn btn-success btn-sm save-user-input d-none">Update</button>  
          <button type="button" class="btn btn-danger btn-sm cancel-user-input d-none">Cancel</button>  
        </td>  
      </tr>  
    </tbody>  
  </table>  
  <p>  
    Based on your input, we have speculated three high-level outcomes.  
    Please choose the one that is closest to your desired result, or click the "Speculate New Outcomes" button to generate a new set of possibilities.  
  </p>  
  <!-- Add the class 'card-container' to the div below -->  
  <div class="row card-container">  
    {% for goal in goals %}  
      <div class="col-md-4 mb-4">  
        <div class="card retro-futuristic-card text-center {% if not goal.compliant %}non-compliant{% endif %}">  
          <div class="card-body card-content">  
            <i class="{{ goal.icon }} fa-2x mb-3"></i>  
            <p class="domain domain-text">{{ goal.domain | title }}</p>  
            <div class="card-title" style="text-align: left;">{{ goal.title | safe }}</div> <!-- Display parsed content -->  
            {% if goal.compliant %}  
            <form action="/outcome" method="post" class="goal-selection-form">  
              <input type="hidden" name="selected_goal" value="{{ goal.title }}">  
              <input type="hidden" name="domain" value="{{ goal.domain }}">  
              <input type="hidden" name="domain_icon" value="{{ goal.icon }}">  
              <input type="hidden" name="user_text" value="{{ user_input }}">  
              <button type="submit" class="btn btn-primary">Select</button>  
            </form>  
            {% else %}  
            <button type="button" class="btn btn-danger" onclick="window.location.href='/';">Start Over</button>  
            {% endif %}  
          </div>  
        </div>  
      </div>  
    {% endfor %}   
 
  </div>  
  <div class="text-center">  
    <button type="button" class="btn btn-outline-primary" id="generate-new-goals">  
      <span class="refresh-icon"><i class="fas fa-sync-alt"></i></span> Speculate New Outcomes</button>  
  </div>  
</div>  
{% endblock %}  
  
{% block scripts %}  
<script type="module" src="{{ url_for('static', filename='js/goal_selection.js') }}"></script>  
{% endblock %}  



üü¶ outcome.html:
{% extends 'base.html' %}  
  
{% block content %}  
<div class="container">  
    <div class="row outcome-header">  
        <div class="col-md-4 text-center">  
            {% if ssol.generated_image_path %}  
                <img src="{{ url_for('static', filename=ssol.generated_image_path) }}" alt="Generated Image" class="rounded mb-3 generated-image" style="width: 100%; max-width: 300px;">  
            {% endif %}  
            <h2>Domain</h2>  
            <i class="{{ ssol.domain_icon }} fa-3x mb-3"></i>  
            <p class="domain domain-text text-center">{{ ssol.domain | title }}</p>  
            <h2>Fulfilled Goal</h2>  
            <p><strong>{{ ssol.selected_goal | safe }}</strong></p>  
            <div id="ssol-goal" style="display: none;">{{ ssol.selected_goal | safe }}</div>  
            <div class="text-center mt-4">  
                <button id="save-as-pdf-button" data-ssol-id="{{ ssol_id }}" class="btn btn-info" title="Save as PDF">  
                    <i class="fas fa-download me-2"></i>PDF  
                </button>  
            </div>  
        </div>  
        <div class="col-md-8">  
            <h1>Preliminary Structured Solution</h1>  
            <p id="ssol-summary">{{ ssol.ssol_summary | safe }}</p>  
        </div>  
    </div>  
  
    <div class="row">  
        <h1>Phases & Conditions of Satisfaction</h1>  
        <div class="col">  
            <div class="accordion mt-4" id="phase-accordion">  
                {% for phase_name, cos_list in ssol.phases.items() %}  
                <div class="accordion-item">  
                    <h2 class="accordion-header phase-colors" id="heading-{{ phase_name | replace(' ', '_') }}">  
                        <button  
                            class="accordion-button"  
                            type="button"  
                            data-bs-toggle="collapse"  
                            data-bs-target="#collapse-{{ phase_name | replace(' ', '_') }}"  
                            aria-expanded="true"  
                            aria-controls="collapse-{{ phase_name | replace(' ', '_') }}"  
                            style="background-color: var(--phase-{{ loop.index0 }});">  
                            {{ phase_name | title }} PHASE  
                        </button>  
                    </h2>  
                    <div  
                        id="collapse-{{ phase_name | replace(' ', '_') }}"  
                        class="accordion-collapse collapse show"  
                        aria-labelledby="heading-{{ phase_name | replace(' ', '_') }}"  
                        data-bs-parent="#phase-accordion">  
                        <div class="accordion-body" data-ssol-id="{{ ssol_id }}" style="border: 2px solid var(--phase-{{ loop.index0 }});">  
                            {% if cos_list %}  
                            <table class="table table-striped phase-table" id="{{ phase_name | replace(' ', '_') }}-table">  
                                <thead>  
                                    <tr>  
                                        <th scope="col">Status</th>  
                                        <th scope="col">Condition of Satisfaction</th>  
                                        <th scope="col">Accountable Party</th>  
                                        <th scope="col">Completion Date</th>  
                                        <th scope="col" class="text-end actions-header">Actions</th>  
                                    </tr>  
                                </thead>  
                                <tbody>  
                                    {% for cos in cos_list %}  
                                    <tr class="cos-row" data-cos-id="{{ cos.id }}" data-editing="false">  
                                        <td class="status-cell">  
                                            <span class="status-pill {{ cos.status | get_badge_class_from_status }}">{{ cos.status | upper }}</span>  
                                        </td>  
                                        <td class="cos-content-cell">{{ cos.content | safe }}</td>  
                                        <td class="cos-accountable-party-cell">{{ cos.accountable_party }}</td>  
                                        <td class="cos-completion-date-cell">{{ cos.completion_date }}</td>  
                                        <td class="text-end actions-cell">  
                                            <div class="cos-actions">  
                                                <button class="btn btn-sm btn-primary edit-cos-button">Edit</button>  
                                                <button class="btn btn-sm btn-success update-cos-button d-none">Update</button>  
                                                <button class="btn btn-sm btn-secondary cancel-cos-button d-none">Cancel</button>  
                                                <button class="btn btn-sm btn-danger delete-cos-button">Delete</button>  
                                                <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="{{ cos.id }}">Analyze</button>  
                                            </div>  
                                        </td>  
                                    </tr>  
                                    {% endfor %}  
                                </tbody>  
                            </table>  
                            <button class="btn btn-success btn-sm add-cos" data-bs-toggle="modal" data-bs-target="#addCOSModal" data-phase="{{ phase_name | replace(' ', '_') }}">Add Condition of Satisfaction</button>  
                            {% else %}  
                            <p>No Conditions of Satisfaction found for this phase.</p>  
                            {% endif %}  
                        </div>  
                    </div>  
                </div>  
                {% endfor %}  
            </div>  
        </div>  
    </div>  
  
    <!-- Error Modal -->  
    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">  
        <div class="modal-dialog">  
            <div class="modal-content">  
                <div class="modal-header">  
                    <h5 class="modal-title" id="errorModalLabel">Error</h5>  
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>  
                </div>  
                <div class="modal-body">{{ error_message }}</div>  
                <div class="modal-footer">  
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>  
                </div>  
            </div>  
        </div>  
    </div>  
  
    <!-- Placeholder for dynamic modals -->  
    <div id="dynamicModalContainer"></div>  
</div>  
{% endblock %}  
  
{% block scripts %}  
<!-- Necessary JS files -->  
<script type="module">  
  import { showLoadingSpinner, hideLoadingSpinner } from './static/js/base_functions.js';  
    
  document.addEventListener('DOMContentLoaded', () => {  
    showLoadingSpinner('Loading data...'); // Show spinner when the page is loading  
  
    window.addEventListener('load', () => {  
      hideLoadingSpinner(); // Hide spinner when the page is fully loaded  
    });  
  });  
</script>  
<script src="{{ url_for('static', filename='js/cos_table.js') }}"></script>  
<script src="{{ url_for('static', filename='js/ce_table.js') }}"></script>  
<script src="{{ url_for('static', filename='js/ce_cards.js') }}" type="module"></script>  
  
<!-- Include Tabulator CSS and JS -->  
<link href="https://unpkg.com/tabulator-tables@4.9.3/dist/css/tabulator.min.css" rel="stylesheet">  
<script src="https://unpkg.com/tabulator-tables@4.9.3/dist/js/tabulator.min.js"></script>  
  
<!-- Initialize event listeners for COS table handling -->  
<script>  
    document.addEventListener('DOMContentLoaded', () => {  
        initializePhaseTableEventListeners();  
    });  
</script>  
  
<!-- Pass necessary data to JavaScript -->  
<script>  
    const NODES = {{ nodes|tojson }};  
    const tableData = {};  // Define tableData here. Update this with actual data if needed.  
</script>  
{% endblock %}  



üü¶ cos_table.js:
function getBadgeClassFromStatus(status) {
  switch (status) {
    case 'Proposed': return 'bg-info';
    case 'In Progress': return 'bg-warning text-dark';
    case 'Completed': return 'bg-success';
    case 'Rejected': return 'bg-danger';
    default: return 'bg-secondary';
  }
}

// Function to add event listeners to the phase table  
function initializePhaseTableEventListeners() {  
  const phaseTables = document.querySelectorAll('.phase-table');  
  phaseTables.forEach(table => {  
      table.addEventListener('click', handlePhaseTableClick);  
  });  
}  

// Handles clicks within the phase table  
function handlePhaseTableClick(event) {  
  const target = event.target;  
  const row = target.closest('tr.cos-row');  
  if (!row) return;  

  const cosId = row.dataset.cosId;  

  if (target.matches('.edit-cos-button')) {  
      turnRowToEditMode(row);  
  } else if (target.matches('.update-cos-button')) {  
      handleUpdate(row, cosId);  
  } else if (target.matches('.cancel-cos-button')) {  
      cancelEditMode(row);  
  } else if (target.matches('.delete-cos-button')) {  
      deleteCOS(cosId, row);  
  }  
}   
  
function toggleEditMode(row, editing) {  
  const editButton = row.querySelector('.edit-cos-button');  
  const updateButton = row.querySelector('.update-cos-button');  
  const cancelButton = row.querySelector('.cancel-cos-button');  
  
  if (editing) {  
    editButton.classList.add('d-none');  
    updateButton.classList.remove('d-none');  
    cancelButton.classList.remove('d-none');  
  } else {  
    editButton.classList.remove('d-none');  
    updateButton.classList.add('d-none');  
    cancelButton.classList.add('d-none');  
  }  
}  
  
function turnRowToEditMode(row) {  
  storeOriginalValues(row);  
  
  const statusCell = row.querySelector('.status-cell');  
  const contentCell = row.querySelector('.cos-content-cell');  
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');  
  const completionDateCell = row.querySelector('.cos-completion-date-cell');  
  
  const currentStatus = statusCell.textContent.trim();  
  const currentContent = contentCell.textContent.trim();  
  const currentAccountableParty = accountablePartyCell.textContent.trim();  
  const currentCompletionDate = completionDateCell.textContent.trim();  
  
  statusCell.innerHTML = createStatusDropdown(currentStatus);  
  contentCell.innerHTML = `<textarea class="form-control form-control-sm" rows="3">${currentContent}</textarea>`;  
  accountablePartyCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentAccountableParty}">`;  
  completionDateCell.innerHTML = `<input type="date" class="form-control form-control-sm" value="${currentCompletionDate}">`;  
  
  toggleEditMode(row, true);  
}  
    
function handleUpdate(row, cosId) {  
  const contentInput = row.querySelector('.cos-content-cell textarea');  
  const newContent = contentInput ? contentInput.value.trim() : '';  
  const statusSelect = row.querySelector('.status-cell select');  
  const statusInput = statusSelect.options[statusSelect.selectedIndex].value;  
  const accountablePartyInput = row.querySelector('.cos-accountable-party-cell input').value.trim();  
  const completionDateInput = row.querySelector('.cos-completion-date-cell input').value;  
  
  const payload = {  
    content: newContent,  
    status: statusInput,  
    accountable_party: accountablePartyInput,  
    completion_date: completionDateInput  
  };  
  
  fetch(`/update_cos/${cosId}`, {  
    method: 'PUT',  
    headers: {  
      'Content-Type': 'application/json',  
      'Accept': 'application/json',  
      'X-Requested-With': 'XMLHttpRequest'  
    },  
    body: JSON.stringify(payload)  
  })  
  .then(response => {  
    if (!response.ok) {  
      return response.json().then(errorData => {  
        throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);  
      });  
    }  
    return response.json();  
  })  
  .then(data => {  
    if (data.success) {  
      updateRowWithNewValues(row, data.cos);  
      toggleEditMode(row, false);  
    } else {  
      throw new Error(data.error || 'An error occurred while updating the entry.');  
    }  
  })  
  .catch(error => {  
    console.error('Error updating COS:', error);  
    alert(`An error occurred while updating the entry: ${error.message}`);  
  });  
}  
  
function createStatusDropdown(selectedStatus) {  
  const statuses = ['Proposed', 'In Progress', 'Completed', 'Rejected'];  
  return `<select class="form-select form-select-sm">${statuses.map(status => `<option value="${status}"${status === selectedStatus ? ' selected' : ''}>${status}</option>`).join('')}</select>`;  
}  
  
function cancelEditMode(row) {  
  revertToOriginalValues(row);  
  toggleEditMode(row, false);  
}  

function addCOS(phaseName, ssolId) {  
  const payload = {  
    content: 'New Condition of Satisfaction',  
    status: 'Proposed',  
    accountable_party: '',  
    completion_date: '',  
    ssol_id: ssolId  
  };  
  
  fetch(`/create_cos`, {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json',  
      'Accept': 'application/json',  
      'X-Requested-With': 'XMLHttpRequest'  
    },  
    body: JSON.stringify(payload)  
  })  
  .then(response => response.json())  
  .then(data => {  
    if (data.success) {  
      const phaseTable = document.querySelector(`#${phaseName.replace(' ', '_')}-table tbody`);  
      const newRow = document.createElement('tr');  
      newRow.classList.add('cos-row');  
      newRow.setAttribute('data-cos-id', data.cos.id);  
      newRow.innerHTML = `  
        <td class="status-cell"><span class="status-pill bg-info ${getBadgeClassFromStatus('Proposed')}">Proposed</span></td>  
        <td class="cos-content-cell">${data.cos.content}</td>  
        <td class="cos-accountable-party-cell">${data.cos.accountable_party}</td>  
        <td class="cos-completion-date-cell">${data.cos.completion_date}</td>  
        <td class="text-end actions-cell">  
          <div class="cos-actions">  
            <button class="btn btn-sm btn-primary edit-cos-button">Edit</button>  
            <button class="btn btn-sm btn-success update-cos-button d-none">Update</button>  
            <button class="btn btn-sm btn-secondary cancel-cos-button d-none">Cancel</button>  
            <button class="btn btn-sm btn-danger delete-cos-button">Delete</button>  
            <button class="btn btn-sm btn-info analyze-cos-button" data-cos-id="${data.cos.id}">Analyze</button>  
          </div>  
        </td>  
      `;  
      phaseTable.appendChild(newRow);  
      initializePhaseTableEventListeners();  
    } else {  
      throw new Error(data.error || 'An error occurred while creating the entry.');  
    }  
  })  
  .catch(error => {  
    console.error('Error creating COS:', error);  
    alert(`An error occurred while creating the entry: ${error.message}`);  
  });  
}  
  
document.addEventListener('DOMContentLoaded', () => {  
  document.querySelectorAll('.add-cos').forEach(button => {  
    button.addEventListener('click', (event) => {  
      const phaseName = event.target.getAttribute('data-phase');  
      const ssolId = document.querySelector('#ssol-goal').getAttribute('data-ssol-id');  
      addCOS(phaseName, ssolId);  
    });  
  });  
});  

function deleteCOS(cosId, row) {  
  if (confirm(`Really delete Condition of Satisfaction?`)) {  
    fetch(`/delete_cos/${cosId}`, {  
      method: 'DELETE',  
      headers: {  
        'Content-Type': 'application/json',  
        'Accept': 'application/json'  
      }  
    })  
    .then(response => {  
      if (!response.ok) {  
        return response.json().then(errorData => {  
          throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);  
        });  
      }  
      return response.json();  
    })  
    .then(data => {  
      if (data.success) {  
        row.remove();  
      } else {  
        throw new Error(data.error || 'An error occurred while deleting the entry.');  
      }  
    })  
    .catch(error => {  
      console.error('Error deleting COS:', error);  
      alert(`An error occurred while deleting the entry: ${error.message}`);  
    });  
  }  
}  

function analyzeCOS(cosId) {  
  fetch(`/analyze_cos/${cosId}`)  
    .then(response => response.json())  
    .then(data => {  
      if (data.success) {  
        const cosRow = document.querySelector(`tr[data-cos-id="${cosId}"] .cos-content-cell`);  
        const newContent = data.analyzed_cos;  
        cosRow.innerHTML = replaceCETagsWithPills(newContent);  
        initializeCEPillEventListeners();  
      } else {  
        throw new Error(data.error || 'An error occurred while analyzing the entry.');  
      }  
    })  
    .catch(error => {  
      console.error('Error analyzing COS:', error);  
      alert(`An error occurred while analyzing the entry: ${error.message}`);  
    });  
}  
  
document.addEventListener('DOMContentLoaded', () => {  
  document.querySelectorAll('.analyze-cos-button').forEach(button => {  
    button.addEventListener('click', (event) => {  
      const cosId = event.target.getAttribute('data-cos-id');  
      analyzeCOS(cosId);  
    });  
  });  
});  
  
function storeOriginalValues(row) {  
  const statusCell = row.querySelector('.status-cell');  
  const contentCell = row.querySelector('.cos-content-cell');  
  const accountablePartyCell = row.querySelector('.cos-accountable-party-cell');  
  const completionDateCell = row.querySelector('.cos-completion-date-cell');  
  
  // Store original values including CE pills  
  row.dataset.originalValues = JSON.stringify({  
    status: statusCell.textContent.trim(),  
    contentWithPills: contentCell.innerHTML.trim(),  // Store the HTML content with CE pills  
    accountableParty: accountablePartyCell.textContent.trim(),  
    completionDate: completionDateCell.textContent.trim()  
  });  
}  
  
function revertToOriginalValues(row) {  
  const originalValues = JSON.parse(row.dataset.originalValues);  
  row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(originalValues.status)}">${originalValues.status}</span>`;  
  row.querySelector('.cos-content-cell').innerHTML = originalValues.contentWithPills;  
  row.querySelector('.cos-accountable-party-cell').textContent = originalValues.accountableParty;  
  row.querySelector('.cos-completion-date-cell').textContent = originalValues.completionDate;  
}  
  
function updateRowWithNewValues(row, cos) {    
  // Check if the cos object and its properties are defined    
  if (cos && cos.status && cos.content) {    
    row.querySelector('.status-cell').innerHTML = `<span class="status-pill ${getBadgeClassFromStatus(cos.status)}">${cos.status}</span>`;    
    row.querySelector('.cos-content-cell').textContent = cos.content;    
    row.querySelector('.cos-accountable-party-cell').textContent = cos.accountable_party || '';    
    row.querySelector('.cos-completion-date-cell').textContent = cos.completion_date || '';    
  } else {    
    // If cos or any required property is undefined, log an error or handle appropriately    
    console.error('Error: COS data is undefined or missing required properties', cos);    
    alert('An error occurred while updating the entry. Please try again.');    
  }    
}      

// Function to add event listeners to the phase table  
function initializePhaseTableEventListeners() {  
  const phaseTables = document.querySelectorAll('.phase-table');  
  phaseTables.forEach(table => {  
      table.addEventListener('click', handlePhaseTableClick);  
  });  
}  

function handleResponse(response) {  
  if (!response.ok) {  
    return response.json().then(errorData => {  
      throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);  
    });  
  }  
  return response.json();  
}  


// Handles clicks within the phase table  
function handlePhaseTableClick(event) {  
  const target = event.target;  
  const row = target.closest('tr.cos-row');  
  if (!row) return;  

  const cosId = row.dataset.cosId;  

  if (target.matches('.edit-cos-button')) {  
      turnRowToEditMode(row);  
  } else if (target.matches('.update-cos-button')) {  
      handleUpdate(row, cosId);  
  } else if (target.matches('.cancel-cos-button')) {  
      cancelEditMode(row);  
  } else if (target.matches('.delete-cos-button')) {  
      deleteCOS(cosId, row);  
  }  
}  

// Function to fetch and display analyzed COS for a given COS ID  
function fetchAndDisplayAnalyzedCOS(cosId) {  
  fetch(`/analyze_cos/${cosId}`)  
    .then(response => {  
      if (!response.ok) {  
        return response.json().then(errorData => {  
          throw new Error(`Server responded with ${response.status}: ${JSON.stringify(errorData)}`);  
        });  
      }  
      return response.json();  
    })  
    .then(data => {  
      if (data.success) {  
        const cosRow = document.querySelector(`tr[data-cos-id="${cosId}"] .cos-content-cell`);  
        if (cosRow) {  
          const newContent = data.analyzed_cos;  
          cosRow.innerHTML = replaceCETagsWithPills(newContent);  
        }  
      } else {  
        throw new Error(data.error || 'An error occurred while analyzing the entry.');  
      }  
    })  
    .catch(error => {  
      console.error('Error analyzing COS:', error);  
      alert(`An error occurred while analyzing the entry: ${error.message}`);  
    });  
}  

  
// Event listener to fetch and display analyzed COS content after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {  
  const analyzeButtons = document.querySelectorAll('.analyze-cos-button');  
  analyzeButtons.forEach(button => {  
    button.addEventListener('click', function () {  
      const cosId = this.getAttribute('data-cos-id');  
      fetchAndDisplayAnalyzedCOS(cosId);  
    });  
  });  
});  


// Function to add event listeners to CE pills  
function initializeCEPillEventListeners() {  
  const cePills = document.querySelectorAll('.ce-pill');  
  cePills.forEach(pill => {  
      pill.addEventListener('click', handleCEPillClick);  
  });  
}  

function handleCEPillClick(event) {  
  const ceId = event.target.dataset.ceId; 
  console.log(`CE Pill with ID ${ceId} clicked`);  

  // Example logic to fetch CE details and display in a modal or another UI element  
  fetch(`/get_ce_by_id/${ceId}`)  
      .then(response => response.json())  
      .then(data => {  
          if (data && data.ce) {  
              displayCEDetails(data.ce); // Function to display CE details  
          } else {  
              console.error('CE details not found or error in response:', data);  
          }  
      })  
      .catch(error => {  
          console.error('Error fetching CE details:', error);  
      });  
} 



// Event listener to initialize phase table event listeners after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {  
  initializePhaseTableEventListeners();  
  document.querySelectorAll('.add-cos').forEach(button => {  
    button.addEventListener('click', (event) => {  
      const phaseName = event.target.getAttribute('data-phase');  
      const ssolId = document.querySelector('#ssol-goal').getAttribute('data-ssol-id');  
      addCOS(phaseName, ssolId);  
    });  
  });  
  document.querySelectorAll('.analyze-cos-button').forEach(button => {  
    button.addEventListener('click', (event) => {  
      const cosId = event.target.getAttribute('data-cos-id');  
      analyzeCOS(cosId);  
    });  
  });  
});  

// Function to add event listeners to CE pills  
function initializeCEPillEventListeners() {  
  const cePills = document.querySelectorAll('.ce-pill');  
  cePills.forEach(pill => {  
      pill.addEventListener('click', handleCEPillClick);  
  });  
} 

// Event listener to initialize phase table event listeners after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', () => {
  initializePhaseTableEventListeners();
  document.querySelectorAll('.analyze-cos-button').forEach(button => {
    button.addEventListener('click', (event) => {
      const cosId = event.target.getAttribute('data-cos-id');
      if (cosId) {
        fetchAndDisplayAnalyzedCOS(cosId);
      }
    });
  });
  
  // Add event listener to the Analyze button  
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.analyze-cos-button').forEach(button => {
      button.addEventListener('click', (event) => {
        const cosId = event.target.getAttribute('data-cos-id');
        if (cosId) {
          fetchAndDisplayAnalyzedCOS(cosId);
        }
      });
    });
  });

  function extractCosContentForEditing(cosContentCell) {
    const badgeElements = cosContentCell.querySelectorAll('.badge');
    badgeElements.forEach((badge) => {
      const ceContent = badge.textContent;
      // Replace the badge HTML with a placeholder or markup that includes the CE content  
      badge.outerHTML = `[CE]${ceContent}[/CE]`;
    });
    return cosContentCell.innerHTML; // This now contains the editable content with [CE][/CE] placeholders  
  }

 
  document.addEventListener('DOMContentLoaded', () => {
    // Get all COS content cells  
    const cosContentCells = document.querySelectorAll('.cos-content-cell');
  
    // Loop over each cell and replace CE tags with pills  
    cosContentCells.forEach(cell => {
      const content = cell.textContent;
      const newContent = replaceCETagsWithPills(content); // This is your existing JS function  
      cell.innerHTML = newContent;
    });
  
    // Now that the DOM has been updated, add event listeners to the new pill elements  
    addEventListenersToCELabels();
  });
})

// Function to save the content as PDF  
function saveAsPDF(ssolId) {  
  const htmlContent = document.documentElement.outerHTML; // Get the entire HTML content of the page  
  fetch(`/save_as_pdf/${ssolId}`, {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify({ htmlContent: htmlContent })  
  })  
  .then(response => {  
    if (!response.ok) {  
      throw new Error(`Server responded with status ${response.status}`);  
    }  
    return response.blob();  
  })  
  .then(blob => {  
    const url = window.URL.createObjectURL(blob);  
    const a = document.createElement('a');  
    a.style.display = 'none';  
    a.href = url;  
    a.download = `${ssolId}.pdf`;  
    document.body.appendChild(a);  
    a.click();  
    window.URL.revokeObjectURL(url);  
    document.body.removeChild(a);  
  })  
  .catch((error) => {  
    console.error('Error saving PDF:', error);  
  });  
}  
  
// Event listener to initialize after DOM content is fully loaded  
document.addEventListener('DOMContentLoaded', function () {  
  const saveButton = document.getElementById('save-as-pdf-button');  
  if (saveButton) {  
    saveButton.addEventListener('click', function (event) {  
      event.preventDefault(); // Prevent the default button click action  
      const ssolId = saveButton.dataset.ssolId;  
      saveAsPDF(ssolId);  
    });  
  }  
});  



üü® speculate.py:
import re
import os
import html
import json
import uuid
from uuid import UUID
import logging
from bs4 import BeautifulSoup 
from app import USE_DATABASE, db  
from ce_nodes import NODES
from ce_templates import replace_ce_tags_with_pills
from models import session  
from sqlalchemy.inspection import inspect
from sqlalchemy.exc import SQLAlchemyError
from utilities import generate_chat_response, get_valid_node_types, generate_chat_response_with_node_types
from models import COS, CE, SSOL, COS_CE_Link  
from store import ssol_store, cos_store, ce_store  
from sqlalchemy.orm import relationship, sessionmaker
from flask import render_template, jsonify, current_app
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Date, ForeignKey, create_engine


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') 

def create_cos(ssol_id, content, status, accountable_party=None, completion_date=None):  
    try:  
        analyzed_content = analyze_cos(content)  

        # Ensure 'ces' key exists  
        content_with_ce = analyzed_content['content_with_ce']  
        ces = analyzed_content.get('ces', [])  

        if USE_DATABASE:  
            cos = COS(content=content_with_ce, status=status, accountable_party=accountable_party,  
                      completion_date=completion_date, ssol_id=ssol_id)  
            db.session.add(cos)  
            for ce_data in ces:  
                ce = CE(content=ce_data['content'], node_type=ce_data['ce_type'])  
                db.session.add(ce)  
                cos.conditional_elements.append(ce)  
            db.session.commit()  
            return cos.id  
        else:  
            cos_id = str(uuid.uuid4())  
            cos = {'id': cos_id, 'content': content_with_ce, 'status': status, 'ssol_id': ssol_id}  
            cos_store[cos_id] = cos  
            for ce_data in ces:  
                ce_id = str(uuid.uuid4())  
                ce = {'id': ce_id, 'content': ce_data['content'], 'node_type': ce_data['ce_type']}  
                ce_store[ce_id] = ce  
                cos['conditional_elements'] = cos.get('conditional_elements', []) + [ce]  
            return cos_id  
    except KeyError as e:  
        logging.error(f"Error creating COS: {e}")  
        raise  
    except Exception as e:  
        logging.error(f"Error creating COS: {e}", exc_info=True)  
        if USE_DATABASE:  
            db.session.rollback()  
        raise  

def get_cos_by_id(cos_id):  
    from app import USE_DATABASE 
    if USE_DATABASE:  
        return COS.query.get(cos_id)  
    else:  
        return cos_store.get(str(cos_id))  

def get_ce_by_id(ce_id: UUID):  
    try:  
        if USE_DATABASE:  
            ce = session.query(CE).get(ce_id)  
            if not ce:  
                current_app.logger.error(f"CE with ID {ce_id} not found in database.")  
                raise ValueError(f"CE with ID {ce_id} not found in the database.")  
        else:  
            ce_id_str = str(ce_id)  
            ce_dict = ce_store.get(ce_id_str)  
            if not ce_dict:  
                current_app.logger.error(f"CE with ID {ce_id_str} not found in in-memory store.")  
                raise ValueError(f"CE with ID {ce_id_str} not found in the in-memory store.")  

            ce_fields = {c.name for c in CE.__table__.columns}  
            ce_dict_filtered = {key: value for key, value in ce_dict.items() if key in ce_fields}  
            ce = CE(**ce_dict_filtered)  

        return ce  

    except ValueError as e:  
        logging.error(f"Error retrieving CE by ID {ce_id}: {e}")  
        raise e  
    except SQLAlchemyError as e:  
        logging.error(f"Database error retrieving CE by ID {ce_id}: {e}", exc_info=True)  
        raise e  
    except Exception as e:  
        logging.error(f"Unexpected error retrieving CE by ID {ce_id}: {e}", exc_info=True)  
        raise e  
    
def analyze_cos(cos_content):  
    prompt = (  
        "Analyze the following condition of satisfaction (COS) and identify any conditional elements (CEs). "  
        "Return a JSON object with the COS text and an array of CEs, each with its text and type."  
        "\nCOS: '{}'"  
        "\nExpected response format:"  
        "{{"  
        "  'COS': 'The full text of the COS',"  
        "  'CEs': ["  
        "    {{'text': 'A conditional element', 'type': 'The type of CE (must be one of the valid node types)'}}"  
        "  ]"  
        "}}"  
    ).format(cos_content)  

    messages = [  
        {"role": "system", "content": "Return a JSON object with the analyzed COS and CEs."},  
        {"role": "user", "content": prompt},  
    ]  

    try:  
        response_text = generate_chat_response_with_node_types(messages, role='COS Analysis', task='Analyze COS')  
        response_json = json.loads(response_text)  

        cos_text = response_json.get("COS", cos_content)  
        ces = response_json.get("CEs", [])  

        valid_ces = [  
            {'content': ce["text"], 'ce_type': ce["type"]}  
            for ce in ces if ce["type"] in get_valid_node_types()  
        ]  

        content_with_ce = replace_ce_tags_with_pills(cos_text, valid_ces)  

        return {  
            'content_with_ce': content_with_ce,  
            'ces': valid_ces  # Ensure 'ces' is always returned  
        }  

    except Exception as e:  
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)  
        return {  
            'content_with_ce': cos_content,  
            'ces': []  # Default to an empty list if there's an error  
        }  

  
def extract_conditional_elements(response_text, original_content):    
    ces = []    
    try:  
        # Use regex to extract CEs from response_text  
        matches = re.findall(r'<ce>(.*?)</ce>', response_text, re.IGNORECASE)  
        content_with_ce = original_content    
  
        for match in matches:    
            ce_content = html.escape(match.strip())  # Escape HTML special characters  
            ce_uuid = str(uuid.uuid4())    
            # Replace only the first occurrence of the matched CE content  
            content_with_ce = re.sub(rf'<ce>\s*{re.escape(match.strip())}\s*</ce>', f'<span class="ce-pill" data-ce-id="{ce_uuid}">{ce_content}</span>', content_with_ce, count=1)  
            ces.append({'id': ce_uuid, 'content': ce_content, 'ce_type': 'Unknown'})  
    
        return {'content_with_ce': content_with_ce, 'ces': ces}  
    except Exception as e:  
        # Handle any errors that occur during the extraction process  
        logging.error(f"Error extracting conditional elements: {e}", exc_info=True)  
        return {'content_with_ce': original_content, 'ces': []}  


def update_cos_by_id(cos_id, updated_data):  
    from app import db, USE_DATABASE  
    try:  
        # If using database, convert UUID to string for query  
        cos_id_str = str(cos_id) if isinstance(cos_id, UUID) else cos_id  
  
        # Update the COS entry with new data  
        if USE_DATABASE:  
            # Database operation  
            cos = session.query(COS).filter_by(id=cos_id).first()  
            if cos:  
                for key, value in updated_data.items():  
                    setattr(cos, key, value)  
                session.commit()  
                return {'success': True, 'cos': cos.to_dict()}  # Return the updated COS for client-side use  
            else:  
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}  
        else:  
            # In-memory operation  
            cos = cos_store.get(cos_id_str)  # Attempt to retrieve the COS entry  
            if not cos:  
                # COS not found, log a warning  
                current_app.logger.warning(f"COS with ID {cos_id_str} not found in the in-memory store.")  
                return {'success': False, 'message': f"COS with ID {cos_id_str} not found."}  
  
            for key, value in updated_data.items():  
                cos[key] = value  
            cos_store[cos_id_str] = cos  # Store the updated COS back in the store  
  
            # Log the successful update and return the updated COS  
            current_app.logger.info(f"COS with ID {cos_id_str} successfully updated.")  
            return {'success': True, 'cos': cos}  # Return the updated COS for client-side use  
  
    except Exception as e:  
        # Log the error and return an error message  
        current_app.logger.error(f"Unexpected error during COS update: {e}", exc_info=True)  
        return {'success': False, 'message': f"Unexpected error occurred: {e}"}  


def delete_cos_by_id(cos_id, ssol_id=None):    
    from app import USE_DATABASE 
    if USE_DATABASE:    
        # Database operation    
        cos = session.query(COS).filter_by(id=cos_id).first()    
        if cos and (ssol_id is None or cos.ssol_id == ssol_id):    
            session.delete(cos)    
            session.commit()    
            return True  # COS was deleted successfully    
        else:    
            return False  # COS did not exist or did not match the provided SSOL_ID    
    else:    
        # In-memory operation    
        cos = cos_store.get(cos_id)    
        if cos and (ssol_id is None or cos['ssol_id'] == ssol_id):    
            del cos_store[cos_id]    
            return True  # COS was deleted successfully    
        return False  # COS did not exist or did not match the provided SSOL_ID 


# Function to analyze the COS content and extract the CE type(s)
def analyze_ce_type(request):
    try:
        ce_content = request.get_json()['ce_content']
        ce_type = None

        # Iterate through the ce_types in ce_nodes.py and check if it appears in the ce_content
        for ce_type, values in NODES.items():
            if ce_type in ce_content:
                break
        
        return jsonify(ce_type=ce_type)
    except Exception as e:
        return jsonify(error=str(e))

def get_ce_type(ce_content):  
    messages = [  
        {"role": "system", "content": "You are responsible for identifying the appropriate card type for the given conditional element."},  
        {"role": "user", "content": ce_content},  
    ]  
    response_text = generate_chat_response(messages, role='Conditional Element (CE) Node Type Identification', task='Identify CE Type', temperature=0.8)  
  
    try:  
        response_data = json.loads(response_text)  
        ce_type = response_data.get('type', '')  # Assuming the key for the CE type in the response is 'type'  
        return ce_type  
    except json.JSONDecodeError:  
        logging.error(f"Error parsing JSON response: {response_text}")  
        return ""  
    
# CRUD operations for SSOL  
def create_ssol(goal, summary):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = SSOL(goal=goal, summary=summary)  
        db.session.add(ssol)  
        db.session.commit()  
        return ssol.id  
    else:  
        ssol_id = str(uuid.uuid4())  
        ssol_store[ssol_id] = {'id': ssol_id, 'goal': goal, 'summary': summary}  
        return ssol_id 

def get_ssol_by_id(ssol_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        return SSOL.query.get(ssol_id)  
    else:  
        return ssol_store.get(ssol_id) 
  
def update_ssol_by_id(ssol_id, updated_data):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()  
        for key, value in updated_data.items():  
            setattr(ssol, key, value)  
        session.commit()  
    else:  
        ssol = ssol_store.get(ssol_id)  
        if ssol:  
            ssol.update(updated_data)  
  
def delete_ssol_by_id(ssol_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ssol = session.query(SSOL).filter_by(id=ssol_id).first()  
        session.delete(ssol)  
        session.commit()  
    else:  
        ssol = ssol_store.pop(ssol_id, None)  
        return bool(ssol)  # Returns True if an SSOL was deleted, False otherwise 


def create_ce(content, node_type, cos_id):  
    ce_id = str(uuid.uuid4())  
    ce_data = {  
        'id': ce_id,  
        'content': content,  
        'node_type': node_type,  
        'cos_id': cos_id  
    }  

    if USE_DATABASE:  
        ce = CE(id=ce_id, content=content, node_type=node_type, cos_id=cos_id)  
        db.session.add(ce)  
        db.session.commit()  
        current_app.logger.debug(f"Created CE in database: {ce}")  
    else:  
        ce_store[ce_id] = ce_data  
        current_app.logger.debug(f"Created CE in in-memory store: {ce_store[ce_id]}")  

    return ce_id  



def update_ce_by_id(ce_id: UUID, ce_data):  
    if USE_DATABASE:  
        ce = CE.query.get(ce_id)  
        if ce:  
            for key, value in ce_data.items():  
                setattr(ce, key, value)  
            db.session.commit()  
            return True  
        else:  
            current_app.logger.error(f"CE with ID {ce_id} not found in database.")  
            return False  
    else:  
        ce_id_str = str(ce_id)  
        if ce_id_str in ce_store:  
            ce_store[ce_id_str].update(ce_data)  
            return True  
        else:  
            current_app.logger.error(f"CE with ID {ce_id_str} not found in in-memory store.")  
            return False  

  
def delete_ce_by_id(ce_id):  
    from app import db, USE_DATABASE 
    if USE_DATABASE:  
        ce = session.query(CE).filter_by(id=ce_id).first()  
        session.delete(ce)  
        session.commit()  
    else:  
        if ce_id in ce_store:  
            del ce_store[ce_id]  
            return True  # CE was deleted successfully  
        return False  # CE did not exist in the store  
  
# Function to generate the appropriate card based on the CE type  
def generate_card(ce_type, ce_id):  
    from app import db, USE_DATABASE 
    if ce_type in NODES:  
        node = NODES[ce_type]  
        # If using a database, render a template with data fetched from the database  
        if USE_DATABASE:  
            template = render_template(  
                node["flask_template"], ce_id=ce_id  
            )  
        else:  
            # If using the in-memory store, pass the CE data directly to the template  
            ce_data = ce_store.get(ce_id)  
            template = render_template(  
                node["flask_template"], ce=ce_data  
            )  
        return template  
    else:  
        return ""

  
def analyze_cos(cos_content):  
    prompt = (  
        "Analyze the following condition of satisfaction (COS) and identify any conditional elements (CEs). "  
        "Return a JSON object with the COS text and an array of CEs, each with its text and type."  
        "\nCOS: '{}'"  
        "\nExpected response format:"  
        "{{"  
        "  'COS': 'The full text of the COS',"  
        "  'CEs': ["  
        "    {{'text': 'A conditional element', 'type': 'The type of CE (must be one of the valid node types)'}}"  
        "  ]"  
        "}}"  
    ).format(cos_content)  
  
    messages = [  
        {"role": "system", "content": "Return a JSON object with the analyzed COS and CEs."},  
        {"role": "user", "content": prompt},  
    ]  
  
    try:  
        # Send messages to the AI and get the response  
        response_text = generate_chat_response_with_node_types(messages, role='COS Analysis', task='Analyze COS')  
        response_json = json.loads(response_text)  
  
        # Extract the COS and CEs from the response  
        cos_text = response_json.get("COS", cos_content)  
        ces = response_json.get("CEs", [])  
  
        valid_node_types = get_valid_node_types()  
  
        # Validate and process the CEs  
        valid_ces = []  
        for ce in ces:  
            if ce["type"] in valid_node_types:  
                new_ce = CE(content=ce["text"], node_type=ce["type"])  
                db.session.add(new_ce)  
                valid_ces.append(new_ce)  
  
        db.session.commit()  
  
        return {'COS': cos_text, 'CEs': [ce.to_dict() for ce in valid_ces]}  
  
    except Exception as e:  
        logging.error(f"Exception occurred during COS analysis: {e}", exc_info=True)  
        db.session.rollback()  
        return {'COS': cos_content, 'CEs': []}  

def get_badge_class_from_status(status):    
    return {    
        'Proposed': 'bg-info',    
        'In Progress': 'bg-warning text-dark',  # Added text-dark for better contrast  
        'Completed': 'bg-success',    
        'Rejected': 'bg-danger'    
    }.get(status, 'bg-secondary')  # Default to 'bg-secondary' if status is not found 
 
    # Ensure database or in-memory store is initialized based on USE_DATABASE flag  
def initialize_data_store():
    from app import USE_DATABASE, Base, _engine   
    Base.metadata.create_all(_engine) if USE_DATABASE else None  

def check_data_store_contents(data_store_type='in_memory'):  
    if data_store_type == 'in_memory':  
        try:  
            # Print contents of the in-memory store  
            for cos_id_str, cos_data in cos_store.items():  
                logging.info(f"COS ID: {cos_id_str}, Data: {cos_data}")  
        except NameError:  
            logging.warning("In-memory store 'cos_store' not found.")  
    elif data_store_type == 'database' and USE_DATABASE:  
        try:  
            # Query all entries in the COS table and print them  
            cos_entries = COS.query.all()  
            for entry in cos_entries:  
                logging.info(f"COS ID: {entry.id}, Data: {entry}")  
        except Exception as e:  
            logging.error(f"Database query failed with error: {e}")  
    else:  
        logging.error(f"Unknown data store type: {data_store_type}") 

        if __name__ == '__main__':  
            logging.info("Checking initial data store contents...")  
            check_data_store_contents('database' if USE_DATABASE else 'in_memory')  

def get_phase_index(cos):  
    # Determine the phase index based on the COS content or other criteria  
    phase_mapping = {  
        'Discovery': 0,  
        'Engagement': 1,  
        'Action': 2,  
        'Completion': 3,  
        'Legacy': 4,  
    }  
    # Example logic to determine the phase index  
    phase_name = cos.get('phase', 'SSPEC')  # Default to 'SSPEC Time Mapper' if phase not found  
    return phase_mapping.get(phase_name, 0)  # Default to 0 if phase not found in mapping  



üü™ ce_table.js:
function handleCEPillClick(event) {  
  const ceId = event.target.dataset.ceId;  
  const ceType = event.target.dataset.ceType || "Default";  
  const cosContent = event.target.closest('tr').querySelector('.cos-content-cell').textContent.trim();  
  const phaseElement = event.target.closest('.accordion-item');  
  const phaseName = phaseElement.querySelector('.accordion-header button').innerText.trim();  
  const phaseIndex = Array.from(phaseElement.parentElement.children).indexOf(phaseElement);  
  
  const requestData = {  
    ce_id: ceId,  
    cos_content: cosContent,  
    phase_name: phaseName,  
    phase_index: phaseIndex,  
    ssol_goal: document.querySelector('#ssol-goal').textContent.trim()  
  };  
  
  fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify(requestData)  
  })  
  .then(response => response.json())  
  .then(data => {  
    if (data && data.modal_html) {  
      displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, data.ai_context);  
    } else {  
      throw new Error('Modal HTML content not found or error in response');  
    }  
  })  
  .catch(error => console.error('Error fetching modal content:', error));  
}  


// Function to display the CE modal
function showCEModal(ceData) {
  const modal = document.createElement('div');
  modal.classList.add('modal', 'fade');
  modal.id = 'ceModal';
  modal.setAttribute('tabindex', '-1');
  modal.setAttribute('aria-labelledby', 'ceModalLabel');
  modal.setAttribute('aria-hidden', 'true');

  const modalDialog = document.createElement('div');
  modalDialog.classList.add('modal-dialog', 'modal-dialog-centered');
  modalDialog.setAttribute('role', 'document');

  const modalContent = createCEModalContent(ceData);
  modalDialog.appendChild(modalContent);
  modal.appendChild(modalDialog);

  document.body.appendChild(modal);

  $(modal).modal('show');

  $(modal).on('hidden.bs.modal', function () {
    modal.remove();
  });
}
  
function handleSaveButtonClick(event, row) {  
  const ceContentInput = row.querySelector('.ce-content-input');  
  const newContent = ceContentInput.value.trim();  
  const ceId = row.dataset.ceId;  
  // Send the updated content to the server  
  fetch(`/update_cos`, {  
    method: 'POST',  
    headers: {'Content-Type': 'application/json'},  
    body: JSON.stringify({cos_id: ceId, content: newContent}),  
  })  
  .then(response => response.json())  
  .then(data => {  
    // Check if the update was successful  
    if (data.success) {  
      // Update the UI to show the new content  
      const ceContentCell = row.querySelector('.ce-content-cell');  
      ceContentCell.textContent = newContent;  
      // Change the "Save" button back to an "Edit" button  
      const editButton = row.querySelector('.edit-ce-button');  
      editButton.classList.remove('d-none');  
      event.target.classList.add('d-none');  
    } else {  
      console.error('Error updating CE:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  
  
function handleDeleteButtonClick(event) {  
  const row = event.target.closest('tr');  
  const ceId = row.dataset.ceId;  
  // Send a delete request to the server  
  fetch(`/delete_cos`, {  
    method: 'POST',  
    headers: {'Content-Type': 'application/json'},  
    body: JSON.stringify({cos_id: ceId}),  
  })  
  .then(response => response.json())  
  .then(data => {  
    // Check if the delete was successful  
    if (data.success) {  
      // Remove the row from the table  
      row.remove();  
    } else {  
      console.error('Error deleting CE:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  
  
function handleAnalyzeButtonClick(event) {  
  const row = event.target.closest('tr');  
  const ceId = row.dataset.ceId;  
  // Send the COS/CE content to the server for analysis  
  fetch(`/analyze_cos/${ceId}`)  
  .then(response => response.json())  
  .then(data => {  
    // Display the analysis results  
    if (data.analyzed_cos) {  
      // Update the UI with the analyzed data  
      // This could be displaying a modal, updating a field, etc.  
      console.log('Analyzed COS:', data.analyzed_cos);  
    } else {  
      console.error('Error analyzing COS:', data.error);  
    }  
  })  
  .catch(error => console.error('Error:', error));  
}  


üè≥Ô∏è‚Äçüåà ce_nodes.py:
NODES = {  
    "Default": {  
        "definition": "This node is a default research mode for undefined node types.",  
        "icon": "fa-solid fa-icons",  
        "modal_config": {  
            "fields": [  
                {"type": "text", "name": "subject", "placeholder": "Subject"},  
                {"type": "textarea", "name": "details", "placeholder": "Details"},  
                {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}  
            ],  
            "explanation": "Default Resource Node.",  
            "ai_context": "Provide general information and suggestions to help achieve the Condition of Satisfaction (COS)."  
        },  
        "tabulator_config": {  
            "columns": [  
                {"title": "Subject", "field": "subject", "editor": "input"},  
                {"title": "Details", "field": "details", "editor": "input"},  
                {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}  
            ]  
        }  
    },  
    "Research": {  
        "definition": "Aggregates and summarizes research materials and resources pertinent to the COS.",  
        "icon": "fa-solid fa-flask",  
        "modal_config": {  
            "fields": [  
                {"type": "text", "name": "research_topic", "placeholder": "Research Topic"},  
                {"type": "textarea", "name": "research_summary", "placeholder": "Research Summary"},  
                {"type": "text", "name": "research_website", "placeholder": "Research Website"}  
            ],  
            "explanation": "Capture relevant research aspects of the node.",  
            "ai_context": "Provide detailed research information, studies, and academic resources relevant to the COS."  
        },  
        "tabulator_config": {  
            "columns": [  
                {"title": "Research Topic", "field": "research_topic", "editor": "input"},  
                {"title": "Research Summary", "field": "research_summary", "editor": "textarea"},  
                {"title": "Research Website", "field": "research_website", "editor": "input"}  
            ]  
        }  
    },  
    "Stakeholder": {
        "definition": "Captures details of stakeholders involved in the COS.",
        "icon": "fa-solid fa-user-friends",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "stakeholder_name", "placeholder": "Stakeholder Name"},
                {"type": "textarea", "name": "stakeholder_role", "placeholder": "Stakeholder Role"},
                {"type": "email", "name": "stakeholder_email", "placeholder": "Stakeholder Email"},
                {"type": "text", "name": "stakeholder_phone", "placeholder": "Stakeholder Phone"},
            ],
            "explanation": "Detail the roles and contact information of stakeholders related to the COS.",
            "ai_context": "Identify and provide details of stakeholders involved in the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Stakeholder Name", "field": "stakeholder_name", "editor": "input"},
                {"title": "Stakeholder Role", "field": "stakeholder_role", "editor": "textarea"},
                {"title": "Stakeholder Email", "field": "stakeholder_email", "editor": "input"},
                {"title": "Stakeholder Phone", "field": "stakeholder_phone", "editor": "input"},
            ]
        }
    },
    "Advocacy": {  
    "definition": "Focuses on efforts to influence public policy and resource allocation decisions.",  
    "icon": "fa-solid fa-bullhorn",  
    "modal_config": {  
        "fields": [  
            {"type": "text", "name": "campaign_name", "placeholder": "Campaign Name"},  
            {"type": "textarea", "name": "campaign_objective", "placeholder": "Campaign Objective"},  
            {"type": "text", "name": "target_audience", "placeholder": "Target Audience"}  
        ],  
        "explanation": "Detail the advocacy campaign's objectives and target audience.",  
        "ai_context": "Provide information on advocacy efforts and campaign strategies pertinent to the COS."  
    },  
    "tabulator_config": {  
        "columns": [  
            {"title": "Campaign Name", "field": "campaign_name", "editor": "input"},  
            {"title": "Campaign Objective", "field": "campaign_objective", "editor": "textarea"},  
            {"title": "Target Audience", "field": "target_audience", "editor": "input"}  
        ]  
    }
    },

    "Resource": {
        "definition": "Lists resources or assets essential for achieving the COS.",
        "icon": "fa-solid fa-tools",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "resource_name", "placeholder": "Resource Name"},
                {"type": "textarea", "name": "resource_details", "placeholder": "Resource Details"},
                {"type": "text", "name": "resource_type", "placeholder": "Resource Type"}
            ],
            "explanation": "Provide details about resources or assets required for the COS.",
            "ai_context": "List and detail resources or assets essential for achieving the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Resource Name", "field": "resource_name", "editor": "input"},
                {"title": "Resource Details", "field": "resource_details", "editor": "textarea"},
                {"title": "Resource Type", "field": "resource_type", "editor": "input"}
            ]
        }
    },
    "Praxis": {
        "definition": "Defines actions or tasks necessary to meet the COS.",
        "icon": "fa-solid fa-tasks",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "action_name", "placeholder": "Action Name"},
                {"type": "textarea", "name": "action_description", "placeholder": "Action Description"},
                {"type": "text", "name": "responsible_person", "placeholder": "Responsible Person"}
            ],
            "explanation": "Specify tasks or actions required to fulfill the COS.",
            "ai_context": "Detail actions or tasks necessary to meet the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Action Name", "field": "action_name", "editor": "input"},
                {"title": "Action Description", "field": "action_description", "editor": "textarea"},
                {"title": "Responsible Person", "field": "responsible_person", "editor": "input"}
            ]
        }
    },
    "Timeline": {
        "definition": "Specifies time frames or deadlines associated with the COS.",
        "icon": "fa-solid fa-clock",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "time_frame", "placeholder": "Time Frame"},
                {"type": "date", "name": "start_date", "placeholder": "Start Date"},
                {"type": "date", "name": "end_date", "placeholder": "End Date"}
            ],
            "explanation": "Provide time-related information such as deadlines and schedules for the COS.",
            "ai_context": "Detail time frames or deadlines associated with the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Time Frame", "field": "time_frame", "editor": "input"},
                {"title": "Start Date", "field": "start_date", "editor": "input"},
                {"title": "End Date", "field": "end_date", "editor": "input"}
            ]
        }
    },
    "Collaboration": {
        "definition": "Focuses on partnerships or collaboration efforts necessary for the COS.",
        "icon": "fa-solid fa-handshake",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "partner_name", "placeholder": "Partner Name"},
                {"type": "textarea", "name": "collaboration_details", "placeholder": "Collaboration Details"},
                {"type": "text", "name": "contact_person", "placeholder": "Contact Person"}
            ],
            "explanation": "Outline collaboration efforts and partnerships related to the COS.",
            "ai_context": "Detail partnerships or collaboration efforts necessary for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Partner Name", "field": "partner_name", "editor": "input"},
                {"title": "Collaboration Details", "field": "collaboration_details", "editor": "textarea"},
                {"title": "Contact Person", "field": "contact_person", "editor": "input"}
            ]
        }
    },
    "Policy": {
        "definition": "Addresses policy or regulatory aspects pertinent to the COS.",
        "icon": "fa-solid fa-gavel",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "policy_name", "placeholder": "Policy Name"},
                {"type": "textarea", "name": "policy_details", "placeholder": "Policy Details"},
                {"type": "text", "name": "regulatory_body", "placeholder": "Regulatory Body"}
            ],
            "explanation": "Detail policies or regulations impacting the COS.",
            "ai_context": "Provide information on policies or regulatory aspects pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Policy Name", "field": "policy_name", "editor": "input"},
                {"title": "Policy Details", "field": "policy_details", "editor": "textarea"},
                {"title": "Regulatory Body", "field": "regulatory_body", "editor": "input"}
            ]
        }
    },
    "Legislation": {
        "definition": "Covers legal considerations or requirements pertinent to the COS.",
        "icon": "fa-solid fa-balance-scale",
        "modal_config": {
            "fields": [
                {"type": "textarea", "name": "legal_requirements", "placeholder": "Legal Requirements"},
                {"type": "text", "name": "relevant_legislation", "placeholder": "Relevant Legislation"},
                {"type": "text", "name": "compliance_officer", "placeholder": "Compliance Officer"}
            ],
            "explanation": "Detail legal considerations and requirements for the COS.",
            "ai_context": "Provide information on legal considerations or requirements pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Legal Requirements", "field": "legal_requirements", "editor": "textarea"},
                {"title": "Relevant Legislation", "field": "relevant_legislation", "editor": "input"},
                {"title": "Compliance Officer", "field": "compliance_officer", "editor": "input"}
            ]
        }
    },
    "Environment": {
        "definition": "Addresses environmental factors related to the COS.",
        "icon": "fa-solid fa-leaf",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "environmental_factor", "placeholder": "Environmental Factor"},
                {"type": "textarea", "name": "impact_assessment", "placeholder": "Impact Assessment"},
                {"type": "text", "name": "mitigation_strategy", "placeholder": "Mitigation Strategy"}
            ],
            "explanation": "Detail environmental factors and their impact on the COS.",
            "ai_context": "Provide information on environmental factors and impact assessments pertinent to the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Environmental Factor", "field": "environmental_factor", "editor": "input"},
                {"title": "Impact Assessment", "field": "impact_assessment", "editor": "textarea"},
                {"title": "Mitigation Strategy", "field": "mitigation_strategy", "editor": "input"}
            ]
        }
    },
    "Risk": {
        "definition": "Identifies potential risks and mitigation strategies for the COS.",
        "icon": "fa-solid fa-exclamation-triangle",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "risk_name", "placeholder": "Risk Name"},
                {"type": "textarea", "name": "risk_description", "placeholder": "Risk Description"},
                {"type": "text", "name": "mitigation_plan", "placeholder": "Mitigation Plan"}
            ],
            "explanation": "Detail potential risks and strategies to mitigate them for the COS.",
            "ai_context": "Identify potential risks and provide mitigation strategies for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Risk Name", "field": "risk_name", "editor": "input"},
                {"title": "Risk Description", "field": "risk_description", "editor": "textarea"},
                {"title": "Mitigation Plan", "field": "mitigation_plan", "editor": "input"}
            ]
        }
    },
    "Opportunity": {
        "definition": "Identifies opportunities that can enhance the COS.",
        "icon": "fa-solid fa-lightbulb",
        "modal_config": {
            "fields": [
                {"type": "text", "name": "opportunity_name", "placeholder": "Opportunity Name"},
                {"type": "textarea", "name": "opportunity_description", "placeholder": "Opportunity Description"},
                {"type": "text", "name": "exploitation_plan", "placeholder": "Exploitation Plan"}
            ],
            "explanation": "Detail opportunities and strategies to capitalize on them for the COS.",
            "ai_context": "Identify opportunities and provide strategies to exploit them for the COS."
        },
        "tabulator_config": {
            "columns": [
                {"title": "Opportunity Name", "field": "opportunity_name", "editor": "input"},
                {"title": "Opportunity Description", "field": "opportunity_description", "editor": "textarea"},
                {"title": "Exploitation Plan", "field": "exploitation_plan", "editor": "input"}
            ]
        }
    }
}

def get_valid_node_types():  
    return list(NODES.keys()) 


üîµ ce_cards.js:
// ce_cards.js  
  
import { showLoadingSpinner, hideLoadingSpinner } from './base_functions.js';  
let hasUnsavedChanges = false;  
  
// Initialize ce_store if not already defined  
if (typeof ce_store === 'undefined') {  
  var ce_store = {};  
}  
  
document.addEventListener('DOMContentLoaded', function () {  
  setupEventListeners();  
});  
  
function setupEventListeners() {  
  document.querySelectorAll('.ce-pill').forEach(pill => {  
    pill.removeEventListener('click', handleCEPillClick); // Remove any existing event listeners  
    pill.addEventListener('click', handleCEPillClick);  
    pill.addEventListener('dblclick', handleCEPillDoubleClick); // Add double-click event listener  
    pill.setAttribute('title', 'Double-tap to open Conditional Element'); // Add tooltip  
  });  
}  
  
function handleCEPillClick(event) {  
  event.preventDefault();  
  event.stopPropagation();  
  
  const existingModal = document.querySelector('.modal.fade.show');  
  if (existingModal) {  
    existingModal.remove();  
  }  
  
  const ceId = event.target.dataset.ceId;  
  const ceType = event.target.dataset.ceType || "Default";  
  const iconClass = NODES[ceType]?.icon || 'fa-spinner'; // Get the appropriate icon class or default to fa-spinner  
  const cosContentCell = event.target.closest('tr').querySelector('.cos-content-cell');  
  const cosContent = cosContentCell ? cosContentCell.innerHTML : ''; // Use innerHTML instead of textContent  
  const phaseElement = event.target.closest('.accordion-item');  
  const phaseName = phaseElement.querySelector('.accordion-header button').innerText.trim();  
  const phaseIndex = Array.from(phaseElement.parentElement.children).indexOf(phaseElement);  
  const ssolGoal = document.querySelector('#ssol-goal').textContent.trim();  
  
  const requestData = {  
    ce_id: ceId,  
    cos_content: cosContent,  
    phase_name: phaseName,  
    phase_index: phaseIndex,  
    ssol_goal: ssolGoal  
  };  
  
  showLoadingSpinner(`Loading ${ceType} data...`, iconClass); // Pass the icon class here  
  fetch(`/get_ce_modal/${encodeURIComponent(ceType)}`, {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify(requestData)  
  })  
    .then(response => response.json())  
    .then(data => {  
      hideLoadingSpinner();  
      if (data && data.modal_html) {  
        const aiGeneratedData = data.ai_generated_data || { fields: {} };  
        displayCEModal(data.modal_html, ceId, ceType, cosContent, phaseName, phaseIndex, aiGeneratedData, data.table_data, data.tabulator_columns, ssolGoal);  
      } else {  
        console.error(`CE type "${ceType}" not found in response`);  
      }  
    })  
    .catch(error => {  
      hideLoadingSpinner();  
      console.error('Error fetching modal content:', error);  
    });  
}  
  
function handleCEPillDoubleClick(event) {  
  handleCEPillClick(event); // Reuse the click handler for double-click  
}  
  
const DEFAULT_FIELDS_CONFIG = [  
  { type: 'text', name: 'subject', placeholder: 'Subject' },  
  { type: 'textarea', name: 'details', placeholder: 'Details' },  
  { type: 'text', name: 'stakeholders', placeholder: 'Stakeholders' }  
];  
  
const DEFAULT_TABULATOR_CONFIG = {  
  columns: [  
    { title: 'Subject', field: 'subject', editor: 'input' },  
    { title: 'Details', field: 'details', editor: 'input' },  
    { title: 'Stakeholders', field: 'stakeholders', editor: 'input' }  
  ]  
};  
  
function displayCEModal(modalHtml, ceId, ceType, cosContent, phaseName, phaseIndex, aiGeneratedData = { fields: {} }, tableData, tabulatorColumns, ssolGoal) {  
  const modalContainer = document.getElementById('dynamicModalContainer');  
  if (!modalContainer) {  
      console.error('Modal container element not found in the DOM');  
      return;  
  }  

  const phaseColors = ["#e91e63", "#00bcd4", "#9c27b0", "#ffc107", "#66bd0e"];  
  const phaseColor = phaseColors[phaseIndex % phaseColors.length];  

  const fieldsConfig = NODES[ceType]?.modal_config.fields || DEFAULT_FIELDS_CONFIG;  
  const tabulatorConfig = NODES[ceType]?.tabulator_config.columns || DEFAULT_TABULATOR_CONFIG.columns;  
  const cosContentWithPills = replace_ce_tags_with_pills(cosContent, ce_store);  

  const iconClass = NODES[ceType]?.icon || 'fa-solid fa-icons'; // Use default icon if not found  

  const wrappedModalHtml = `  
      <div class="modal fade" id="ceModal-${ceId}" tabindex="-1" aria-labelledby="ceModalLabel-${ceId}" aria-hidden="true">  
          <div class="modal-dialog modal-lg" role="document">  
              <div class="modal-content">  
                  <div class="modal-header" style="background-color: ${phaseColor};">  
                      <div class="filled-box"></div>  
                      <h5 class="modal-title" id="ceModalLabel-${ceId}">  
                          <span class="node-icon me-2" style="color: ${phaseColor};">  
                              <i class="${iconClass}"></i>  
                          </span>  
                          <span class="modal-header-title">${ceType.replace('_', ' ').toUpperCase()} // ${phaseName.toUpperCase()}</span>  
                      </h5>  
                      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>  
                  </div>  
                  <div class="modal-body">  
                      <p><span class="context-label">Source COS:</span>${cosContentWithPills}</p>  
                      <p><span class="context-label">${ceType}:</span><span class="context-text">${aiGeneratedData.contextual_description || 'No contextual description available.'}</span></p>  
                      <div id="dynamicTable-${ceId}" class="tabulator-table mb-3"></div>  
                      <div class="row justify-content-start mb-3">  
                          <div class="col-auto">  
                              <button type="button" class="btn btn-sm btn-danger" id="deleteSelectedRowsButton-${ceId}">Delete</button>  
                              <button type="button" class="btn btn-sm btn-secondary" id="duplicateSelectedRowsButton-${ceId}">Duplicate</button>  
                          </div>  
                      </div>  
                      <form id="ceForm-${ceId}">  
                          ${generateFormFields(fieldsConfig, aiGeneratedData.fields)}  
                      </form>  
                      <div class="row mt-2">  
                          <div class="col">  
                              <button type="button" class="btn btn-success w-100" id="addRowButton-${ceId}" style="padding-top: 10px;">Add ${ceType}</button>  
                          </div>  
                          <div class="col">  
                              <button type="button" class="btn btn-primary w-100" id="generateRowButton-${ceId}" style="padding-top: 10px;">Generate ${ceType}</button>  
                          </div>  
                      </div>  
                  </div>  
                  <div class="modal-footer">  
                      <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>  
                      <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="${ceId}">Save changes</button>  
                  </div>  
              </div>  
          </div>  
      </div>  
  `;  

  modalContainer.innerHTML = wrappedModalHtml;  

  const modalElement = modalContainer.querySelector(`#ceModal-${ceId}`);  
  if (modalElement) {  
      const modal = new bootstrap.Modal(modalElement);  
      modal.show();  

      modalElement.addEventListener('shown.bs.modal', function () {  
          const tableElementId = `#dynamicTable-${ceId}`;  
          const table = initializeTabulatorTable(tableElementId, tableData, tabulatorConfig, ceType);  
          modalElement._tabulator = table;  
      });  

      modalElement.addEventListener('hidden.bs.modal', function () {  
          if (hasUnsavedChanges && !confirm('You have unsaved changes. Do you really want to close?')) {  
              const modal = new bootstrap.Modal(modalElement);  
              modal.show();  
          } else {  
              setupEventListeners();  
          }  
      });  

      setupModalEventListeners(modalElement, ceId, ceType, cosContent, phaseName, phaseIndex, ssolGoal);  
  } else {  
      console.error(`Modal element not found in the DOM for CE ID: ${ceId}`);  
  }  
}  

  
function replace_ce_tags_with_pills(content, ce_store) {  
  const parser = new DOMParser();  
  const doc = parser.parseFromString(content, 'text/html');  
  const ceTags = doc.querySelectorAll('ce');  
  
  ceTags.forEach(ceTag => {  
    const ceId = ceTag.getAttribute('id');  
    const ceType = ceTag.getAttribute('type');  
    const ceText = ceTag.textContent;  
    const ceData = ce_store[ceId] || {};  
  
    const pill = document.createElement('span');  
    pill.className = 'badge rounded-pill bg-secondary ce-pill position-relative';  
    pill.dataset.ceId = ceId;  
    pill.dataset.ceType = ceType;  
    pill.textContent = ceText;  
    pill.title = "Double-tap to open Conditional Element";  
  
    if (ceData.is_new) {  
      const greenDot = document.createElement('span');  
      greenDot.className = 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle';  
      const visuallyHiddenText = document.createElement('span');  
      visuallyHiddenText.className = 'visually-hidden';  
      visuallyHiddenText.textContent = 'New CE';  
      greenDot.appendChild(visuallyHiddenText);  
      pill.appendChild(greenDot);  
    }  
  
    const nonNullRows = ceData.table_data ? ceData.table_data.filter(row => Object.values(row).some(value => value !== null && value !== '')) : [];  
    const resourceCount = nonNullRows.length;  
    if (resourceCount > 0) {  
      const tally = document.createElement('span');  
      tally.className = 'badge rounded-pill bg-light text-dark ms-2 ce-pill counter';  
      tally.textContent = resourceCount.toString();  
      pill.appendChild(tally);  
    }  
  
    ceTag.replaceWith(pill);  
  });  
  
  return doc.body.innerHTML;  
}  
  
function generateFormFields(fieldsConfig, aiData) {  
  console.log("generateFormFields called with fieldsConfig:", fieldsConfig);  
  console.log("generateFormFields called with aiData:", aiData);  
  
  if (!fieldsConfig) {  
    console.error("No fieldsConfig provided.");  
    return 'No form fields available.';  
  }  
  
  return fieldsConfig.map(field => {  
    console.log("Generating field:", field);  
  
    const fieldValue = aiData[field.name] || '';  
    const placeholder = field.placeholder || '';  
  
    if (field.type === 'textarea') {  
      return `  
        <div class="form-group">  
          <label for="${field.name}">${placeholder}</label>  
          <textarea class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}">${fieldValue}</textarea>  
        </div>  
      `;  
    } else {  
      return `  
        <div class="form-group">  
          <label for="${field.name}">${placeholder}</label>  
          <input type="${field.type}" class="form-control" id="${field.name}" name="${field.name}" placeholder="${placeholder}" value="${fieldValue}">  
        </div>  
      `;  
    }  
  }).join('');  
}  
  
function initializeTabulatorTable(tableSelector, tableData, tabulatorColumns, ceType) {  
  const tableElement = document.querySelector(tableSelector);  
  if (!tableElement) {  
      console.error('Table element not found:', tableSelector);  
      return;  
  }  

  const initialData = tableData.length ? tableData : [];  

  try {  
    const table = new Tabulator(tableSelector, {  
      data: initialData,  
      layout: "fitColumns",  
      movableColumns: true,  
      resizableRows: true,  
      selectable: true,  
      reactiveData: true,  
      placeholder: `Add or Generate ${ceType}`,  
      rowHeight: 40,  // Ensure this is the correct option  
      columns: [  
          {  
              title: "",  
              width: 30,  
              rowHandle: true,  
              formatter: "handle",  
              headerSort: false,  
              resizable: false,  
              hozAlign: "center"  
          },  
          {  
              formatter: "rowSelection",  
              titleFormatter: "rowSelection",  
              hozAlign: "center",  
              headerSort: false,  
              width: 40,  
              resizable: false,  
              cellClick: function (e, cell) {  
                  cell.getRow().toggleSelect();  
              }  
          },  
          ...tabulatorColumns,  
      ],  
  });  

      return table;  
  } catch (error) {  
      console.error('Error initializing Tabulator table:', error);  
  }  
}  

  
function clearFormFields(formSelector) {  
  const form = document.querySelector(formSelector);  
  if (form) {  
    form.querySelectorAll('input, textarea, select').forEach(field => {  
      field.value = '';  // Clear the field value  
      field.placeholder = field.getAttribute('data-placeholder') || field.placeholder;  // Reset the placeholder text  
    });  
  }  
}  
  
function populateFormFields(ceId, aiData) {  
  const form = document.querySelector(`#ceForm-${ceId}`);  
  if (form) {  
    Object.keys(aiData).forEach(fieldName => {  
      const input = form.querySelector(`[name="${fieldName}"]`);  
      if (input) {  
        input.value = aiData[fieldName];  
      }  
    });  
  }  
}  
  
function generateFieldsFromAI(ceId, ceType, existingCEs) {  
  const form = document.querySelector(`#ceForm-${ceId}`);  
  const cosContent = document.querySelector('.cos-content-cell').textContent.trim();  
  const ssolGoal = document.querySelector('#ssol-goal').textContent.trim();  
  
  const requestData = {  
    ce_id: ceId,  
    ce_type: ceType,  
    cos_content: cosContent,  
    ssol_goal: ssolGoal,  
    existing_ces: existingCEs  // Include existing CEs  
  };  
  
  console.log("Sending AI query request data:", requestData); // Add logging  
  
  showLoadingSpinner(`Generating ${ceType}...`);  
  fetch('/ai-query-endpoint', {  
    method: 'POST',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify(requestData)  
  })  
    .then(response => {  
      console.log("AI query response status:", response.status); // Add logging  
      return response.json();  
    })  
    .then(data => {  
      hideLoadingSpinner();  
      console.log("AI query response data:", data); // Add logging  
      if (data && data.ai_response) {  
        populateFormFields(ceId, data.ai_response.fields);  
      } else {  
        throw new Error('AI response not found or error in response');  
      }  
    })  
    .catch(error => {  
      hideLoadingSpinner();  
      console.error('Error generating fields from AI:', error);  
    });  
}  
  
function extractCosContentForEditing(cosContentCell) {  
  const badgeElements = cosContentCell.querySelectorAll('.badge, .position-absolute');  
  badgeElements.forEach((badge) => {  
    const ceContent = badge.previousSibling.textContent;  
    badge.previousSibling.textContent = ceContent;  // Restore original text without badge  
    badge.remove();  // Remove the badge element  
  });  
  return cosContentCell.innerHTML;  // This now contains the editable content with original CE text  
}  
  
function setupModalEventListeners(modalElement, ceId, ceType, cosContent, phaseName, phaseIndex, ssolGoal) {  
  // Define buttons and elements within the modal  
  const addRowButton = modalElement.querySelector(`#addRowButton-${ceId}`);  
  const generateRowButton = modalElement.querySelector(`#generateRowButton-${ceId}`);  
  const saveChangesButton = modalElement.querySelector('.btn-save-changes');  
  const deleteSelectedRowsButton = modalElement.querySelector(`#deleteSelectedRowsButton-${ceId}`);  
  const duplicateSelectedRowsButton = modalElement.querySelector(`#duplicateSelectedRowsButton-${ceId}`);  

  // Handle changes in the modal  
  modalElement.addEventListener('change', () => {  
      hasUnsavedChanges = true;  
  });  

  // Handle modal close event  
  modalElement.addEventListener('hidden.bs.modal', function () {  
      if (hasUnsavedChanges) {  
          // Handle unsaved changes, e.g., prompt user  
          if (confirm('You have unsaved changes. Do you really want to close?')) {  
              hasUnsavedChanges = false; // Reset after handling  
          } else {  
              const modal = new bootstrap.Modal(modalElement);  
              modal.show(); // Reopen the modal  
          }  
      }  
  });  

  // Add event listener to Add Row button  
  if (addRowButton) {  
      addRowButton.addEventListener('click', () => {  
          const table = modalElement._tabulator;  
          const form = modalElement.querySelector(`#ceForm-${ceId}`);  
          const formData = new FormData(form);  
          const rowData = {};  
          let isAnyFieldFilled = false;  

          formData.forEach((value, key) => {  
              if (value.trim()) {  
                  isAnyFieldFilled = true;  
              }  
              rowData[key] = value || '';  
          });  

          if (!isAnyFieldFilled) {  
              alert('Please fill in at least one field before adding a row.');  
              return;  
          }  

          const rows = table.getRows();  
          let emptyRow = rows.find(row => Object.values(row.getData()).every(val => val === ''));  

          if (emptyRow) {  
              emptyRow.update(rowData);  
          } else {  
              table.addRow(rowData, true);  
          }  

          clearFormFields(`#ceForm-${ceId}`);  
          hasUnsavedChanges = true;  
      });  
  }   
  
  if (saveChangesButton) {  
    saveChangesButton.addEventListener('click', () => {  
      saveCEChanges(ceId);  
      hasUnsavedChanges = false;  
    });  
  }  
  
  if (deleteSelectedRowsButton) {  
    deleteSelectedRowsButton.addEventListener('click', () => {  
      const table = modalElement._tabulator;  
      const selectedRows = table.getSelectedRows();  
      selectedRows.forEach(row => row.delete());  
      hasUnsavedChanges = true;  
    });  
  }  
  
  if (duplicateSelectedRowsButton) {  
    duplicateSelectedRowsButton.addEventListener('click', () => {  
      const table = modalElement._tabulator;  
      const selectedRows = table.getSelectedRows();  
      selectedRows.forEach(row => {  
        const rowData = row.getData();  
        table.addRow(rowData, true);  
      });  
      hasUnsavedChanges = true;  
    });  
  }  
  
  modalElement.addEventListener('hidden.bs.modal', function () {  
    if (hasUnsavedChanges && !confirm('You have unsaved changes. Do you really want to close?')) {  
      const modal = new bootstrap.Modal(modalElement);  
      modal.show();  
    } else {  
      setupEventListeners(); // Reattach event listeners when modal is closed  
    }  
  });  
}  
  
function saveCEChanges(ceId) {  
  const modalElement = document.querySelector(`#ceModal-${ceId}`);  
  const table = modalElement._tabulator;  
  const tableData = table ? table.getData() : [];  
  
  // Filter out rows with all null or empty values  
  const nonNullRows = tableData.filter(row =>  
    Object.values(row).some(value => value !== null &&  
      (typeof value === 'string' ? value.trim() !== '' : value !== ''))  
  );  
  
  const updatedData = {  
    table_data: nonNullRows,  
    form_data: getFormData(modalElement.querySelector(`#ceForm-${ceId}`))  
  };  
  
  fetch(`/update_ce/${encodeURIComponent(ceId)}`, {  
    method: 'PUT',  
    headers: {  
      'Content-Type': 'application/json'  
    },  
    body: JSON.stringify(updatedData)  
  })  
    .then(response => response.json())  
    .then(data => {  
      if (data.success) {  
        console.log(`CE ID ${ceId} updated successfully`);  
        bootstrap.Modal.getInstance(modalElement).hide();  
        updateCEPills(ceId, nonNullRows.length); // Update all CE pills with the same ID  
        setupEventListeners(); // Reattach event listeners to CE pills  
      } else {  
        throw new Error(data.error || 'An error occurred while updating the CE.');  
      }  
    })  
    .catch(error => {  
      console.error('Error updating CE:', error);  
      alert('An error occurred while updating the CE. Please try again.');  
    });  
}  


function getFormData(form) {  
  const formData = new FormData(form);  
  const data = {};  
  formData.forEach((value, key) => {  
    data[key] = value || '';  // Ensure value is not null  
  });  
  return data;  
}  
  
function updateCEPills(ceId, resourceCount) {  
  const cePills = document.querySelectorAll(`.ce-pill[data-ce-id="${ceId}"]`);  
  cePills.forEach(cePill => {  
    const ceText = cePill.textContent.replace(/\(\d+\)$/, '').trim();  
    cePill.innerHTML = ''; // Clear existing content  
  
    // Add the CE text  
    const textNode = document.createTextNode(ceText);  
    cePill.appendChild(textNode);  
  
    if (resourceCount > 0) {  
      const tally = document.createElement('span');  
      tally.className = 'badge rounded-pill bg-light text-dark ms-2 counter';  
      tally.textContent = resourceCount.toString();  
      cePill.appendChild(tally);  
    }  
  
    // Add the green dot for new CEs  
    const ceData = ce_store[ceId];  
    if (ceData && ceData.is_new) {  
      const greenDot = document.createElement('span');  
      greenDot.className = 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle';  
      const visuallyHiddenText = document.createElement('span');  
      visuallyHiddenText.className = 'visually-hidden';  
      visuallyHiddenText.textContent = 'New CE';  
      greenDot.appendChild(visuallyHiddenText);  
      cePill.appendChild(greenDot);  
    }  
  
    // Reattach click event listener  
    cePill.addEventListener('click', (event) => handleCEPillClick(event));  
  });  
}  
  
// Ensure this function is called after any changes to CE data  
function refreshAllCEPills() {  
  Object.entries(ce_store).forEach(([ceId, ceData]) => {  
    const nonBlankRows = ceData.table_data ? ceData.table_data.filter(row => Object.values(row).some(value => value !== null && value.trim() !== '')) : [];  
    updateCEPills(ceId, nonBlankRows.length);  
  });  
}  
  
// Call this function after initializing the page and after any bulk updates to CE data  
document.addEventListener('DOMContentLoaded', function () {  
  setupEventListeners();  
  refreshAllCEPills();  
});  



üìÜ models.py:
import os  
import uuid  
from dotenv import load_dotenv  
from flask_sqlalchemy import SQLAlchemy  
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, Date  
from sqlalchemy.dialects.postgresql import UUID  
from sqlalchemy.ext.declarative import declarative_base  
from sqlalchemy.orm import scoped_session, sessionmaker, relationship  
  
load_dotenv()  
  
db = SQLAlchemy()  
Base = declarative_base()  
_engine = create_engine(os.environ.get('SQLALCHEMY_DATABASE_URI'), echo=True)  
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)  
session = scoped_session(SessionLocal)  
  
class SSOL(db.Model):  
    __tablename__ = 'ssol'  
    id = Column(Integer, primary_key=True)  
    title = Column(String(255), nullable=False)  
    description = Column(Text, nullable=True)  
    cos = relationship('COS', back_populates='ssol')  
  
    def to_dict(self):  
        return {  
            'id': self.id,  
            'title': self.title,  
            'description': self.description,  
            'cos': [cos.to_dict() for cos in self.cos]  
        }  
  
class COS(db.Model):  
    __tablename__ = 'cos'  
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)  
    content = Column(String, nullable=False)  
    status = Column(String(50), nullable=False)  
    accountable_party = Column(String(255), nullable=True)  
    completion_date = Column(Date, nullable=True)  
    ssol_id = Column(Integer, ForeignKey('ssol.id'), nullable=False)  
    ssol = relationship('SSOL', back_populates='cos')  
    conditional_elements = relationship('CE', back_populates='cos')    
  
    def to_dict(self):  
        return {  
            'id': str(self.id),  
            'content': self.content,  
            'status': self.status,  
            'accountable_party': self.accountable_party,  
            'completion_date': self.completion_date.isoformat() if self.completion_date else None,  
            'ssol_id': self.ssol_id,  
            'conditional_elements': [ce.to_dict() for ce in self.conditional_elements]  
        }  
  
class CE(db.Model):  
    __tablename__ = 'ce'  
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)  
    content = Column(String, nullable=False)  
    node_type = Column(String(50), nullable=True)  
    details = Column(Text, nullable=True)  
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), nullable=False)  # Add this line  
    cos = relationship('COS', back_populates='conditional_elements')  
  
    def to_dict(self):  
        return {  
            'id': str(self.id),  
            'content': self.content,  
            'node_type': self.node_type,  
            'details': self.details,  
            'cos_id': str(self.cos_id)  # Include the cos_id in the dictionary  
        } 
  
class COS_CE_Link(db.Model):  
    __tablename__ = 'cos_ce_link'  
    cos_id = Column(UUID(as_uuid=True), ForeignKey('cos.id'), primary_key=True)  
    ce_id = Column(UUID(as_uuid=True), ForeignKey('ce.id'), primary_key=True) 
      
Base.metadata.create_all(_engine)  



üì± app.py:
import os  
import logging  
from flask import Flask  
from flask_migrate import Migrate  
from dotenv import load_dotenv  
from models import db  # Import the db object from models.py  
  
# Load environment variables  
load_dotenv()  
  
# Flag to toggle database usage  
USE_DATABASE = os.environ.get('USE_DATABASE', 'False').lower() in ['true', '1', 't']  
  
# Initialize Flask app  
app = Flask(__name__)  
  
# Set the secret key from the environment variables  
app.secret_key = os.environ.get('SECRET_KEY', 'your_secret_key')  
  
if USE_DATABASE:  
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('SQLALCHEMY_DATABASE_URI')  
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  
    app.config['SQLALCHEMY_ECHO'] = True  
  
    # Initialize SQLAlchemy  
    db.init_app(app)  
  
    # Initialize Flask-Migrate  
    migrate = Migrate(app, db)  
  
# Import the functions from speculate after db has been initialized to avoid circular imports  
from speculate import get_badge_class_from_status  
  
# Register the custom Jinja filter function  
app.jinja_env.filters['get_badge_class_from_status'] = get_badge_class_from_status  
  
# Import the routes and register the Blueprint at the end of the file  
from routes import routes_bp  
app.register_blueprint(routes_bp)  
  
if __name__ == '__main__':  
    logging.basicConfig(level=logging.DEBUG)  # Set the logging level to DEBUG  
    logging.info("Checking initial data store contents...")  
    from speculate import check_data_store_contents  
    check_data_store_contents('database' if USE_DATABASE else 'in_memory')  
    app.run(debug=True)  



üè™ store.py:
# store.py  
ssol_store = {}  
cos_store = {}  
ce_store = {}  


üß© ce_templates.py:
# ce_templates.py  

import json
import logging  
import uuid
from uuid import UUID 
from store import ce_store  
from bs4 import BeautifulSoup  
from flask import render_template_string, current_app  
from utilities import generate_chat_response  
from ce_nodes import NODES, get_valid_node_types  

BASE_MODAL_TEMPLATE = """  
<div class="modal fade" id="ceModal-${ceId}" tabindex="-1" aria-labelledby="ceModalLabel-${ceId}" aria-hidden="true">  
  <div class="modal-dialog modal-lg" role="document">  
    <div class="modal-content">  
      <div class="modal-header" style="background-color: ${phaseColor};">  
        <div class="filled-box"></div>  
        <h5 class="modal-title" id="ceModalLabel-${ceId}">  
          <span class="node-icon me-2" style="color: ${phaseColor};">  
            <i class="${NODES[ceType]?.icon || 'fa-solid fa-icons'}"></i>  
          </span>  
          <span class="modal-header-title">${ceType.replace('_', ' ').toUpperCase()} // ${phaseName.toUpperCase()}</span>  
        </h5>  
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>  
      </div>  
      <div class="modal-body">  
        <p><span class="context-label">Source COS:</span><span class="context-text">${cos_content_with_pills}</span></p>  
        <p><span class="context-label">${ceType}:</span><span class="context-text">${ai_generated_data.contextual_description || 'No contextual description available.'}</span></p>  
        <div id="dynamicTable-${ceId}" class="tabulator-table mb-3"></div>  
  
        <div class="row justify-content-start mb-3">  
          <div class="col-auto">  
            <button type="button" class="btn btn-sm btn-danger" id="deleteSelectedRowsButton-${ceId}">Delete</button>  
            <button type="button" class="btn btn-sm btn-secondary" id="duplicateSelectedRowsButton-${ceId}">Duplicate</button>  
          </div>  
        </div>  
  
        <form id="ceForm-${ceId}">  
          ${generate_form_fields(fields_config, ai_generated_data.fields)}  
        </form>  
        <div class="row mt-2">  
          <div class="col">  
            <button type="button" class="btn btn-success w-100" id="addRowButton-${ceId}" style="padding-top: 10px;">Add ${ceType}</button>  
          </div>  
          <div class="col">  
            <button type="button" class="btn btn-primary w-100" id="generateRowButton-${ceId}" style="padding-top: 10px;">Generate ${ceType}</button>  
          </div>  
        </div>  
      </div>  
      <div class="modal-footer">  
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>  
        <button type="button" class="btn btn-primary btn-save-changes" data-ce-id="${ceId}">Save changes</button>  
      </div>  
    </div>  
  </div>  
</div>  
"""  

DEFAULT_FIELDS_CONFIG = [  
    {"type": "text", "name": "subject", "placeholder": "Subject"},  
    {"type": "textarea", "name": "details", "placeholder": "Details"},  
    {"type": "text", "name": "stakeholders", "placeholder": "Stakeholders"}  
]  
  
DEFAULT_TABULATOR_CONFIG = {  
    "columns": [  
        {"title": "Subject", "field": "subject", "editor": "input"},  
        {"title": "Details", "field": "details", "editor": "input"},  
        {"title": "Stakeholders", "field": "stakeholders", "editor": "input"}  
    ]  
}  
  
def generate_form_field(field_type, field_name, field_value='', placeholder='', options=None):  
    current_app.logger.debug(f"Generating form field: type={field_type}, name={field_name}, value={field_value}, placeholder={placeholder}")  
    field_templates = {  
        'text': '<div class="form-group"><label for="{name}">{label}</label><input type="text" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',  
        'number': '<div class="form-group"><label for="{name}">{label}</label><input type="number" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',  
        'textarea': '<div class="form-group"><label for="{name}">{label}</label><textarea class="form-control" id="{name}" name="{name}" placeholder="{placeholder}" data-placeholder="{placeholder}" rows="4">{value}</textarea></div>',  
        'email': '<div class="form-group"><label for="{name}">{label}</label><input type="email" class="form-control" id="{name}" name="{name}" value="{value}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',  
        'password': '<div class="form-group"><label for="{name}">{label}</label><input type="password" class="form-control" id="{name}" name="{name}" placeholder="{placeholder}" data-placeholder="{placeholder}"/></div>',  
        'date': '<div class="form-group"><label for="{name}">{label}</label><input type="date" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',  
        'time': '<div class="form-group"><label for="{name}">{label}</label><input type="time" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',  
        'datetime-local': '<div class="form-group"><label for="{name}">{label}</label><input type="datetime-local" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',  
        'color': '<div class="form-group"><label for="{name}">{label}</label><input type="color" class="form-control" id="{name}" name="{name}" value="{value}" data-placeholder="{placeholder}"/></div>',  
        'checkbox': '<div class="form-check"><input type="checkbox" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',  
        'radio': '<div class="form-check"><input type="radio" class="form-check-input" id="{name}" name="{name}" value="{value}" {checked}/><label class="form-check-label" for="{name}">{placeholder}</label></div>',  
        'select': '<div class="form-group"><label for="{name}">{label}</label><select class="form-control" id="{name}" name="{name}">{options}</select></div>',  
    }  
  
    checked = 'checked' if field_value and field_type in ['checkbox', 'radio'] else ''  
    label = field_name.replace('_', ' ').title()  # Generate a label from the field name  
  
    if field_type in ['radio', 'select']:  
        options_html = ''.join(f'<option value="{opt_value}" {"selected" if field_value and opt_value == field_value else ""}>{opt_label}</option>' for opt_value, opt_label in (options or {}).items())  
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, options=options_html)  
    else:  
        return field_templates.get(field_type, field_templates['text']).format(name=field_name, label=label, value=field_value, placeholder=placeholder, checked=checked)  
  
def generate_form_fields(fields_config, ai_generated_data=None):  
    if not fields_config:  
        current_app.logger.error("No fields_config provided to generate form fields.")  
        return "No form fields available."  
    current_app.logger.debug(f"Generating form fields with config: {fields_config}")  
    form_fields_html = ""  
    for field in fields_config:  
        current_app.logger.debug(f"Generating field: {field}")  
        # Check if AI-generated data exists for the field  
        field_value = ai_generated_data.get(field['name'], '') if ai_generated_data else ''  
        field_html = generate_form_field(  
            field_type=field['type'],  
            field_name=field['name'],  
            field_value=field_value,  
            placeholder=field.get('placeholder', ''),  
            options=field.get('options', None)  
        )  
        form_fields_html += field_html  
    return form_fields_html  
 

def generate_table_headers(fields_config):  
    table_headers_html = ""  
    for field in fields_config:  
        header_label = field['name'].replace('_', ' ').title()  
        table_headers_html += f"<th><strong>{header_label}</strong></th>"  
    return table_headers_html  

def generate_dynamic_modal(ce_type, ce_data=None, cos_content=None, ai_generated_data=None, phase_name=None, phase_index=None, ce_store=None):  
    current_app.logger.debug(f"Generating modal for CE type: {ce_type}")  
    current_app.logger.debug(f"CE data: {ce_data}")  
    current_app.logger.debug(f"COS content: {cos_content}")  
    current_app.logger.debug(f"AI generated data: {ai_generated_data}")  
    current_app.logger.debug(f"Phase name: {phase_name}")  
    current_app.logger.debug(f"Phase index: {phase_index}")  
  
    node_info = NODES.get(ce_type, NODES['Default'])  
    fields_config = node_info['modal_config']['fields']  
    tabulator_config = node_info['tabulator_config']  
  
    saved_form_data = ce_data.get('form_data', {}) if ce_data else {}  
    form_fields = generate_form_fields(fields_config, saved_form_data or ai_generated_data.get('fields', {}))  
    table_headers = generate_table_headers(fields_config)  
    table_data = ce_data.get('table_data', []) if ce_data else []  
  
    node_name = ce_type.replace('_', ' ').title()  
    ai_context_description = ai_generated_data.get('contextual_description', 'No contextual description provided.')  
  
    # Process the COS content to replace CE tags with CE pills  
    ces = list(ce_store.values())  # Ensure that ce_store contains the correct structure  
    for ce in ces:  
        if 'ce_type' not in ce:  
            ce['ce_type'] = 'Unknown'  
            current_app.logger.warning(f"Added missing 'ce_type' to CE: {ce}")  
  
    cos_content_with_pills = replace_ce_tags_with_pills(cos_content, ces)  
  
    modal_content = render_template_string(  
        BASE_MODAL_TEMPLATE,  
        ce_type=ce_type,
        icon_class = NODES[ce_type].get('icon') if ce_type in NODES else get_node_type_icon_and_name(ce_type),  
        node_info=node_info,  
        form_fields=form_fields,  
        table_headers=table_headers,  
        table_data=table_data,  
        tabulator_columns=[  
            { 'formatter': 'rowSelection', 'titleFormatter': 'rowSelection', 'hozAlign': 'center', 'headerSort': False, 'cellClick': lambda e, cell: cell.getRow().toggleSelect() },  
            *tabulator_config['columns'],  
        ],  
        ce_data=ce_data or {'id': 'unknown_ce_id'},  
        cos_content_with_pills=cos_content_with_pills,  # Use processed COS content with CE pills  
        ai_generated_data=ai_generated_data,  
        phase_name=phase_name,  
        phase_index=phase_index,  
        node_name=node_name,  
        ce_id=ce_data.get('id', 'unknown_ce_id') if ce_data else 'unknown_ce_id',  
        ai_context_description=ai_generated_data.get('contextual_description', 'No contextual description provided.')  
    )  
  
    return modal_content  

def get_node_type_icon_and_name(node_type):  
    messages = [  
        {"role": "system", "content": "You are an AI that suggests a FontAwesome 6 Solid (fas) class icon based on the node type. Output only the icon class in JSON format."},  
        {"role": "user", "content": f"What is the best FontAwesome icon class for the node type '{node_type}'?"}  
    ]  
    response_content = generate_chat_response(messages, role='Node Type Icon', task='Fetch Node Type FontAwesome Icon', temperature=0.37)  

    try:  
        response_data = json.loads(response_content)  
        icon_class = response_data.get("iconClass")  
        if not icon_class:  
            logging.error(f"Failed to retrieve icon class for node type '{node_type}'.")  
            raise ValueError("Icon class not provided by AI.")  
        return icon_class  

    except json.JSONDecodeError as e:  
        logging.error(f"JSON decoding error: {e}")  
        raise  
    except Exception as e:  
        logging.error(f"Unexpected error: {e}")  
        raise  



def assign_ce_type(ce):  
    if 'ce_type' not in ce or not ce['ce_type']:  
        # Assign a default CE type if none is provided  
        ce['ce_type'] = 'General'  
        logging.info(f"Assigned default 'ce_type' to CE: {ce}")  
    return ce 

def extract_full_cos_text(cos_content):
    soup = BeautifulSoup(cos_content, 'html.parser')
    return ' '.join(soup.stripped_strings)

def generate_fa_icon_for_node_type(node_type):  
    messages = [  
        {"role": "system", "content": "You are an AI that suggests a FontAwesome 6 Solid (fas) class icon based on the node type name. Output only the icon class in JSON format."},  
        {"role": "user", "content": f"What is the best FontAwesome icon class for the node type '{node_type}'?"}  
    ]  
    response_content = generate_chat_response(messages, role='Icon Generation', task='Fetch FontAwesome 6 Icon', temperature=0.37)  
  
    try:  
        # Log the raw response content for debugging  
        current_app.logger.debug(f"Raw response content: {response_content}")  
  
        # Parse the JSON string into a dictionary  
        response_data = json.loads(response_content)  
        # Make sure to match the keys exactly with the response content  
        icon_class = response_data.get("iconClass")  # Changed from "icon" to "iconClass"  
  
        if not icon_class:  
            # Log a warning if expected keys are missing  
            current_app.logger.warning("Missing 'iconClass' in AI response.")  
            raise ValueError("Failed to generate icon. Please try again.")  
  
        return icon_class  
  
    except json.JSONDecodeError as e:  
        # Log the JSON parsing error  
        current_app.logger.error(f"JSON parsing error: {e}")  
        raise ValueError("Failed to parse JSON response. Please try again.")  
  
    except Exception as e:  
        # Log any other exceptions  
        current_app.logger.error(f"Unexpected error: {e}")  
        raise  
  
def replace_ce_tags_with_pills(content, ces):  
    def assign_ce_type(ce):  
        if 'ce_type' not in ce or not ce['ce_type']:  
            # Assign a default CE type if none is provided  
            ce['ce_type'] = 'General'  
            logging.info(f"Assigned default 'ce_type' to CE: {ce}")  
        return ce  
  
    soup = BeautifulSoup(content, 'html.parser')  
      
    for ce in ces:  
        # Ensure each CE has a valid type  
        ce = assign_ce_type(ce)  
  
        ce_uuid = str(uuid.uuid4())  
        new_tag = soup.new_tag('span', attrs={  
            'class': 'badge rounded-pill bg-secondary ce-pill position-relative',  
            'data-ce-id': ce_uuid,  
            'data-ce-type': ce['ce_type']  
        })  
        new_tag.string = ce['content']  
  
        # Add counter if applicable  
        if ce.get('count', 0) > 0:  
            counter_tag = soup.new_tag('span', attrs={  
                'class': 'badge rounded-pill bg-light text-dark ms-2'  
            })  
            counter_tag.string = str(ce['count'])  
            new_tag.append(counter_tag)  
  
        # Add indicator for new CEs  
        if ce.get('is_new'):  
            green_dot = soup.new_tag('span', attrs={  
                'class': 'position-absolute top-0 start-100 translate-middle p-2 bg-success border border-light rounded-circle'  
            })  
            visually_hidden_text = soup.new_tag('span', attrs={'class': 'visually-hidden'})  
            visually_hidden_text.string = 'New CE'  
            green_dot.append(visually_hidden_text)  
            new_tag.append(green_dot)  
  
        soup.append(new_tag)  
          
    return str(soup) 

def get_ce_modal(ce_type):  
    modal_html = generate_dynamic_modal(ce_type)  
    return modal_html  
  
def generate_ai_data(cos_text, ce_id, ce_type, ssol_goal, existing_ces=None):  
    if existing_ces is None:  
        existing_ces = []  # Default to an empty list if no existing CEs are provided  
  
    node_info = NODES.get(ce_type, NODES['Default'])  
    ai_context = node_info.get('modal_config', {}).get('ai_context', '')  
    modal_config_fields = node_info.get('modal_config', {}).get('fields', [])  
  
    if not ai_context:  
        current_app.logger.debug(f"No AI context provided for CE type: {ce_type}")  
        return {"summary": "No AI context provided.", "fields": {}}  
  
    valid_node_types = ', '.join(get_valid_node_types())  
    field_labels = [field['name'] for field in modal_config_fields]  
  
    messages = [  
        {  
            "role": "system",  
            "content": (  
                "You are a helpful assistant. Generate contextually relevant data based on the Structured Solution (SSOL) goal, "  
                "the parent Condition of Satisfaction (COS) text, and the specific Conditional Element Identifier (CE ID) and type provided. Use this information to generate "  
                "detailed and specific insights or data that can fulfill on satisfying the COS and ultimately achieving the SSOL goal. "  
                "Choose the most appropriate conditional element type from within the following list: {valid_node_types}."  
            ).format(valid_node_types=valid_node_types)  
        },  
        {  
            "role": "user",  
            "content": (  
                f"SSOL Goal: {ssol_goal}\n"  
                f"COS Text: {cos_text}\n"  
                f"CE ID: {ce_id}\n"  
                f"CE Type: {ce_type}\n"  
                f"Context: {ai_context}\n"  
                f"Form Field Labels: {', '.join(field_labels)}\n"  
                f"Existing Conditional Elements: {json.dumps(existing_ces)}\n"  # Include existing CEs  
                f"Based on the SSOL goal and the context provided by the parent COS and other conditional elements, "  
                f"generate a JSON response with the following structure:\n"  
                f"{{\n"  
                f"  \"summary\": \"Summary of the Conditional Element\",\n"  
                f"  \"contextual_description\": \"Contextual description of the CE\",\n"  
                f"  \"fields\": {{\n"  
                f"    \"field_label_1\": \"Unique value for field_label_1\",\n"  
                f"    \"field_label_2\": \"Unique value for field_label_2\",\n"  
                f"    ...\n"  
                f"  }}\n"  
                f"}}\n"  
                f"Ensure that the generated fields are unique and provide new information that complements the existing conditional elements."  
            )  
        }  
    ]  
  
    try:  
        response = generate_chat_response(messages, role='AI Contextual Query', task=f'Generate Data for {ce_type}')  
        current_app.logger.debug(f"AI Response: {response}")  
        ai_data = json.loads(response)  
        current_app.logger.debug(f"Parsed AI Data: {ai_data}")  
        return ai_data  
    except Exception as e:  
        current_app.logger.error(f"Error generating AI data: {e}")  
        return {"summary": "Error generating AI data.", "contextual_description": "Error generating context.", "fields": {}}  



